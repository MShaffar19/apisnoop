#+TITLE: Webapp Code, Deployment, and Reference Materials
#+TODO: TODO(t) IN-PROGRESS(i) WAITING(w) | DONE(d)

* Introduction 
  A web display for APIsnoop data, given from an APIsnoop GraphQL API.
* App Src
  :PROPERTIES:
  :header-args: :dir './app/src/'
  :END:
** Sapper Plumbing 
   There's a number of files necessary for any sapper project that ties to a graphql endpoint.  We don't do much with them, but they ensure the site actually runs.
*** client.js
    #+NAME: client.js
    #+begin_src js :tangle ./app/src/client.js
      import * as sapper from '@sapper/app';

      sapper.start({
        target: document.querySelector('#sapper')
      });
    #+end_src
*** server.js
    #+NAME: server.js
    #+begin_src js :tangle ./app/src/server.js
      import sirv from 'sirv';
      import polka from 'polka';
      import compression from 'compression';
      import * as sapper from '@sapper/server';

      const { PORT, NODE_ENV } = process.env;
      const dev = NODE_ENV === 'development';

      polka() // You can also use Express
        .use(
          compression({ threshold: 0 }),
          sirv('static', { dev }),
          sapper.middleware()
        )
        .listen(PORT, err => {
          if (err) console.log('error', err);
        });
    #+end_src
*** apollo.js
    Apollo connects our app to our graphql endpoint.  The app is designed to be run in cluster, so the endpoint is to the in-cluster address for hasura
    #+NAME: apollo.js
    #+begin_src js :tangle ./app/src/apollo.js
      import ApolloClient from 'apollo-boost';
      import fetch from 'node-fetch';

      const GQL_ENDPOINT = 'http://hasura:8080/v1/graphql'
      // const GQL_ENDPOINT = 'http://localhost/hasura/v1/graphql';

      export default new ApolloClient({
        uri: GQL_ENDPOINT,
        fetch: fetch
      });
    #+end_src
*** service-worker.js
    Stores assets and cache so site works well in intermittent internet
    #+NAME: service-worker.js
    #+begin_src js :tangle ./app/src/service-worker.js
      import { timestamp, files, shell, routes } from '@sapper/service-worker';

      const ASSETS = `cache${timestamp}`;

      // `shell` is an array of all the files generated by the bundler,
      // `files` is an array of everything in the `static` directory
      const to_cache = shell.concat(files);
      const cached = new Set(to_cache);

      self.addEventListener('install', event => {
        event.waitUntil(
          caches
            .open(ASSETS)
            .then(cache => cache.addAll(to_cache))
            .then(() => {
              self.skipWaiting();
            })
        );
      });

      self.addEventListener('activate', event => {
        event.waitUntil(
          caches.keys().then(async keys => {
            // delete old caches
            for (const key of keys) {
              if (key !== ASSETS) await caches.delete(key);
            }

            self.clients.claim();
          })
        );
      });

      self.addEventListener('fetch', event => {
        if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

        const url = new URL(event.request.url);

        // don't try to handle e.g. data: URIs
        if (!url.protocol.startsWith('http')) return;

        // ignore dev server requests
        if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

        // always serve static files and bundler-generated assets from cache
        if (url.host === self.location.host && cached.has(url.pathname)) {
          event.respondWith(caches.match(event.request));
          return;
        }

        // for pages, you might want to serve a shell `service-worker-index.html` file,
        // which Sapper has generated for you. It's not right for every
        // app, but if it's right for yours then uncomment this section
        /*
          if (url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
          event.respondWith(caches.match('/service-worker-index.html'));
          return;
          }
        ,*/

        if (event.request.cache === 'only-if-cached') return;

        // for everything else, try the network first, falling back to
        // cache if the user is offline. (If the pages never change, you
        // might prefer a cache-first approach to a network-first one.)
        event.respondWith(
          caches
            .open(`offline${timestamp}`)
            .then(async cache => {
              try {
                const response = await fetch(event.request);
                cache.put(event.request, response.clone());
                return response;
              } catch(err) {
                const response = await cache.match(event.request);
                if (response) return response;

                throw err;
              }
            })
        );
      });

    #+end_src
** Template for our html files
   This is used to build out our basic html page in which the app blooms within the script.  If you want to add meta content to the head of each page, here is where you'd do it.
   #+NAME: template.html
   #+begin_src html :tangle ./app/src/template.html
     <!doctype html>
     <html>
       <head>
         <meta charset='utf-8'>
         <meta name='viewport' content='width=device-width,initial-scale=1.0'>
         <meta name='theme-color' content='#333333'>

         %sapper.base%

         <link rel='stylesheet' href='global.css'>
         <link rel='manifest' href='manifest.json'>
         <link rel='icon' type='image/png' href='favicon.png'>

         <!-- Sapper generates a <style> tag containing critical CSS
              for the current page. CSS for the rest of the app is
              lazily loaded when it precaches secondary pages -->
           %sapper.styles%

           <!-- This contains the contents of the <svelte:head> component, if
                the current page has one -->
             %sapper.head%
       </head>
       <body>
         <!-- The application will be rendered inside this element,
              because `src/client.js` references it -->
         <div id='sapper'>%sapper.html%</div>

         <!-- Sapper creates a <script> tag containing `src/client.js`
              and anything else it needs to hydrate the app and
              initialise the router -->
           %sapper.scripts%
       </body>
     </html>


   #+end_src
** Layout
   :PROPERTIES:
   :header-args: :tangle ./app/src/routes/_layout.svelte
   :END:
   In sapper, you can add a special _layout.svelte_ file to your routes folder that will set a layout for all files in that directory and sub-directories (if there's layout in a subdirectory it will take that one instead)  this lets us design a single overall page with consistent header and footer no matter where in the site we are.
   
   #+NAME: _layout.svelte
   #+begin_src web
     <script>
      import Nav from '../components/Nav.svelte';

     </script>

     <style>
      main {
        position: relative;
        max-width: 1080px;
        margin: auto;
        padding: 2em;
        box-sizing: border-box;
      }
     </style>

     <Nav />
     <main>
       <slot></slot>
     </main>
   #+end_src
** Routes
*** index ('/')
    The home page.  This should show a coverage over time graph and a sunburst beneath it, the sunburst being set to the latest job on sig-release-blocking.
**** index.json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.json.js
     :END:
     #+NAME: index.json.js
     #+begin_src js 
       import client from "../apollo.js";
       import { determineBucketAndJob } from '../lib/helpers.js';
       import {
         ALL_BUCKETS_AND_JOBS_SANS_LIVE,
         ENDPOINTS_TESTS_AND_USERAGENTS,
         STABLE_ENDPOINT_STATS } from '../queries';

       export async function get(req, res) {
         let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;

         let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;

         let {bucket, job} = determineBucketAndJob(rawBucketsAndJobsPayload);

         let endpointsTestsAndUseragentsQuery = await client.query(
           {query: ENDPOINTS_TESTS_AND_USERAGENTS,
            variables: {bucket, job}
           });
         let endpointsTestsAndUseragentsPayload = endpointsTestsAndUseragentsQuery.data;

         const payload = JSON.stringify({
           stableEndpointStatsPayload,
           rawBucketsAndJobsPayload,
           endpointsTestsAndUseragentsPayload
         });

         res.writeHead(200, {
           'Content-Type': 'application/json'
         });
         res.end(payload);
       }
     #+end_src
   
**** index.svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.svelte
     :END:
     
     We want to show the sunburst, the sunburst derives its bucket and endpoints from the store.  We've added the raw bucket and job, but need to also bring in all endpoints for the default bucket and job. 
     #+NAME: index.svelte
     #+begin_src web
       <script context="module">
        export function preload({ params, query }) {
          return this.fetch(`index.json`)
                     .then(r => r.json())
                     .then(payload => ({ payload }));
        }
       </script>

       <script>
        import CoverageOverTime from '../components/CoverageOverTime/Wrapper.svelte'; 
        import Sunburst from '../components/Sunburst/Wrapper.svelte';
        import { isEqual} from 'lodash-es';
        import { goto } from '@sapper/app';
        import {
          activeFilters,
          stableEndpointStats,
          rawBucketsAndJobs,
          endpointsTestsAndUseragents
        } from '../stores';

        export let payload;
        const {
          rawBucketsAndJobsPayload,
          stableEndpointStatsPayload,
          endpointsTestsAndUseragentsPayload
        } = payload;
        let isLoading = false;

        rawBucketsAndJobs.update(raw => isEqual(raw, rawBucketsAndJobsPayload)
                                      ? raw
                                      : rawBucketsAndJobsPayload);

        stableEndpointStats.update(stats => isEqual(stats, stableEndpointStatsPayload)
                                          ? stats
                                          : stableEndpointStatsPayload);

        endpointsTestsAndUseragents.update(etu => isEqual(etu, endpointsTestsAndUseragentsPayload)
                                                ? etu
                                                : endpointsTestsAndUseragentsPayload);

        const navigateToDataPoint = async ({bucket, job}) => {
          isLoading = true;
          await goto(`${bucket}/${job}`);
          isLoading = false;
        }
        const updatePath = async (event) => {
          let {bucket, job, level, category, operation_id} = event.detail.params;
          activeFilters.update(af => ({...af, ...event.detail.params}));
          let filterSegments = compact([bucket, job, level, category, operation_id]);
          let urlPath = join([...filterSegments], '/');
          let x = window.pageXOffset;
          let y = window.pageYOffset;
          goto(urlPath).then(() => window.scrollTo(x,y));
        }
       </script>

       <svelte:head>
         <title>APISnoop</title>
       </svelte:head>
       <CoverageOverTime on:dataClick={({detail}) => navigateToDataPoint(detail)}/>
       {#if isLoading}
       <p>loading sunburst with data...</p>
       {:else}
       <Sunburst on:newPathRequest={updatePath} />
       {/if}
     #+end_src
     
*** [...params]
**** [...params].json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...params].json.js
     :END:
     #+NAME: [...params].json.js
     #+begin_src js 
       import client from "../apollo.js";
       import { determineBucketAndJob } from '../lib/helpers.js';
       import {
         ALL_BUCKETS_AND_JOBS_SANS_LIVE,
         ENDPOINTS_TESTS_AND_USERAGENTS,
         STABLE_ENDPOINT_STATS } from '../queries';

       export async function get (req, res, next) {
         let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;

         let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;

         let query = req.query;
         let [bucketParam, jobParam, level, category, operation_id] = req.params.params;
         let {bucket, job} = determineBucketAndJob(rawBucketsAndJobsPayload, bucketParam, jobParam);

         let endpointsTestsAndUseragentsFromQuery = await client.query(
           {query: ENDPOINTS_TESTS_AND_USERAGENTS,
            variables: {bucket, job}
           });
         let endpointsTestsAndUseragentsPayload = endpointsTestsAndUseragentsFromQuery.data

         let allTheThings = {
           bucket,
           bucketParam,
           category,
           endpointsTestsAndUseragentsPayload,
           job,
           jobParam,
           level,
           operation_id,
           query,
           rawBucketsAndJobsPayload,
           stableEndpointStatsPayload
         };

         let payload = JSON.stringify(allTheThings);
         console.log('payload! from server', bucket, job, endpointsTestsAndUseragentsPayload.endpoints.length);
         res.writeHead(200, {
           'Content-Type': 'application/json' ,
         });
         res.end(payload);
       };
     #+end_src
     
**** [...params].svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...params].svelte
     :END:
     
     #+NAME: [...params].svelte
     #+begin_src web
       <script context="module">
        import { join } from 'lodash-es';
        export function preload ({ params, query }) {
          let path = join(params.params, '/');
          return this
            .fetch(`${path}.json`)
            .then(r => r.json())
            .then(payload => ({ payload }));
        };
       </script>

       <script>
        import Sunburst from '../components/Sunburst/Wrapper.svelte';
        import CoverageOverTime from '../components/CoverageOverTime/Wrapper.svelte';
        import { goto } from '@sapper/app';
        import { onMount, afterUpdate } from 'svelte';
        import { isEqual, compact } from 'lodash-es';
        import {
          activeFilters,
          endpointsTestsAndUseragents,
          rawBucketsAndJobs,
          stableEndpointStats,
          warnings
        } from '../stores';

        export let payload;
        let isLoading = false;
        let  {
          bucket,
          bucketParam,
          category,
          endpointsTestsAndUseragentsPayload,
          job,
          jobParam,
          level,
          operation_id,
          query,
          rawBucketsAndJobsPayload,
          stableEndpointStatsPayload
        } = payload;

        activeFilters.update(af => ({
          ...af,
          bucket,
          job: job || '',
          level: level || '',
          category: category || '',
          operation_id: operation_id || ''
          ,
          ...query
        }));
        rawBucketsAndJobs.update(raw => isEqual(raw, rawBucketsAndJobsPayload)
                                      ? raw
                                      : rawBucketsAndJobsPayload);

        stableEndpointStats.update(stats => isEqual(stats, stableEndpointStatsPayload)
                                          ? stats
                                          : stableEndpointStatsPayload);

        endpointsTestsAndUseragents.update(etu => isEqual(etu, endpointsTestsAndUseragentsPayload)
                                                ? etu
                                                : endpointsTestsAndUseragentsPayload);

        onMount(() => {
          console.log('mounted');
          if (bucketParam && bucketParam !== bucket) {
            warnings.update(warnings => ({...warnings, invalidBucket: true}));
          }
          if (jobParam && jobParam !== job) {
            warnings.update(warnings => ({...warnings, invalidJob: true}));
          }
        })
        afterUpdate(() => {
          if (!isEqual(payload.endpointsTestsAndUseragentsPayload, $endpointsTestsAndUseragents)) {
            $endpointsTestsAndUseragents = payload.endpointsTestsAndUseragentsPayload
            $stableEndpointStats = payload.stableEndpointStatsPayload
            $rawBucketsAndJobs = payload.rawBucketsAndJobsPayload
            }
          })
        const navigateToDataPoint = async ({bucket, job}) => {
          isLoading = true;
          activeFilters.update(af => ({...af, bucket, job, level: '', category: '', operation_id: ''}))
          await goto(`${bucket}/${job}`);
          isLoading = false;
        }
        const updatePath = async (event) => {
          let {bucket, job, level, category, operation_id} = event.detail.params;
          activeFilters.update(af => ({...af, ...event.detail.params}));
          let filterSegments = compact([bucket, job, level, category, operation_id]);
          let urlPath = join([...filterSegments], '/');
          let x = window.pageXOffset;
          let y = window.pageYOffset;
          goto(urlPath).then(() => window.scrollTo(x,y));
        }
       </script>
       {#if $warnings.invalidBucket}
       <p><strong>Note: </strong><em>Could not find data for <code>{bucketParam}</code>. Displaying latest job for {bucket} instead.</em></p>
       <button on:click={() => $warnings.invalidBucket = false}>Got it</button>
       {/if}
       {#if !$warnings.invalidBucket && $warnings.invalidJob}
       <p><strong>Note: </strong><em>Could not find data for <code>{jobParam}</code>. Displaying latest job for {bucket} instead.</em></p>
       <button on:click={() => $warnings.invalidJob = false}>Got it</button>
       {/if}
       <CoverageOverTime on:dataClick={({detail}) => navigateToDataPoint(detail)}/>
       {#if isLoading}
       <p>loading sunburst with data...</p>
       {:else}
       <Sunburst on:newPathRequest={updatePath} />
       {/if}
     #+end_src
     We want to be able to have dynamic url routes that spring from home like '/bucket/job/stable'.  We also want to have all fetches of our data spring from the server instead of the client (as the client won't be able to access the endpoint if it is an internal k8s address).
   
     To facilitiate this, we build a small json api at the root which takes all requests, ddoes any data fetching ncessary, and returns an html page.  All of this will be done on the server, and the client only receives data from the server.

     Sapper has a naming convention for files that if they are in brackets they are treated as dynamic, with the name in the brackets mapping to the url params.  So we name our files [...index] which lets us be able to go to a route like '/bucket/job/stable' and we'll get a url params in a list [bucket, job, stable].  Helpful!
** Components
*** Outline of a Section
    What does a general graph section look like?
    It will be a section wrapper, plus a title, some explanatory text, and the graph.
    The graph could be made of a breakoutsection (like the sunburst's legend on the right), or just a simple legend. 
    
    This format would cover our CoverOVerTime, Sunburst, and TestsList.
    
    I feel that each title is different enough that a title component is more confusing than good, instead there should be a shared style for h2 tags, and a general style for section spacing.  So this is reduced futher to 
    #+begin_example web
    <section>
      <sectionHeader />
      <sectionGraphContainer />
    </section>
    #+end_example
    
    Each one will want to communicate url changes too, so we can update it to
    
    #+begin_example web
    
    <section>
      <sectionHeader on:dataClick{updateFiltersAndPath}/>
      <sectionGraphContainer on:dataClick{updateFiltersAndPath} />
    </section>
    #+end_example
    
    Which even cleaner would be to have our route bea ble to look something like:
    
    #+begin_example web
    
    <main>
      <CoverageOverTime on:dataClick{updateFiltersAndPath}/>
      <Sunburst on:dataClick{updateFiltersAndPath}/>
      <TestsList on:dataClick{updateFiltersAndPath} />
    </main>
    #+end_example
    
    And then we could only maintain path update logic in one place, the route component itself. 
    
*** CoverageOverTime
**** Wrapper
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/CoverageOverTime/Wrapper.svelte
     :END:
     #+NAME: CoverageOverTime Wrapper
     #+begin_src web
       <script>
        import Prologue from './Prologue.svelte';
        import Graph from './Graph.svelte';
       </script>

       <section id='coverage-over-time'>
         <Prologue />
         <Graph on:dataClick />
       </section>


       <style>
        section {
          margin-top: var(--section-spacing);
          margin-bottom: var(--section-spacing);
          padding: 1rem;
        }
       </style>
     #+end_src
**** Prologue
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/CoverageOverTime/Prologue.svelte
     :END:
     #+NAME: CoverageOverTime Wrapper
     #+begin_src web
       <script>
        import SectionHeader from '../SectionHeader.svelte';
        import { dates, coverage } from '../../stores/coverage-over-time.js';
        import { first, last } from 'lodash-es';
        import { releasePrecision } from '../../lib/helpers.js';
        import dayjs from 'dayjs';

        $: releases = $coverage
          .map(stat => ({release: releasePrecision(stat.release, 2) , date: stat.date}))
          .sort((a,b) => new Date(a.date) - new Date(b.date));
        $: latestRelease = last(releases);
        $: otherReleases = releases
          .filter(release => (
            release.date !== latestRelease.date
            && release.release !== latestRelease.release))

        $: pastReleaseSpread = () => {
          let uniqueReleases = [...new Set(otherReleases)]
            .map(r => r.release);

          return uniqueReleases.length > 1
                                       ? ` last ${uniqueReleases.length} releases, from ${first(uniqueReleases)} to ${last(uniqueReleases)}, `
                                       : `last release, ${first(uniqueReleases)}`;
        }
        $: latestUpdate = dayjs(latestRelease.date)
          .format('DD MMMM, YYYY');
       </script>

       <SectionHeader title="Coverage For Stable Endpoints, Over Time">
         <em>Updated on {latestUpdate}</em>
       </SectionHeader>

       <p>Below shows the testing coverage for stable Kubernetes endoints (where coverage is defined as the percentage of kubernetes endpoints hit by at least one test during an e2e test suite run).  We show coverage for both standard and conformance tests.
         {#if releases.length > 1}
         The data includes the {pastReleaseSpread()} along with the latest test run for {releasePrecision(latestRelease.release, 2)}.
         {:else}
         The data includes the latest test run for {releasePrecision(latestRelease.release, 2)}.
         {/if}
       </p>

       <p>The current goal, as reflected in the y-axis,  is to have at least 50% of kubernetes endpoints hit by tests.</p>
       <strong>Click on any data point to see that release's coverage in depth</strong>
     #+end_src
**** Graph
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/CoverageOverTime/Graph.svelte
     :END:
     #+begin_src web 
       <script>
        import dayjs from 'dayjs';
        import {
          first,
          last,
          isEmpty,
          uniqBy
        } from 'lodash-es';
        import { releasePrecision } from '../../lib/helpers.js';
        import { afterUpdate, createEventDispatcher } from 'svelte';
        import { scaleLinear, scaleTime } from 'd3-scale';
        import { prefetch, goto } from '@sapper/app';
        import {
          dates,
          coverage
        } from '../../stores/coverage-over-time.js';
        import {
          bucketsAndJobs
        } from '../../stores';
        const dispatch = createEventDispatcher();

        const padding = { top: 20, right: 15, bottom: 20, left: 25 };
        // create an array of numbers from 0 to max, incremented by step
        const range = (max, step) => [...Array(max + 1).keys()].filter(n => n % step === 0)
        // y is total percentage, from 0 to 100
        const yTicks = range(50, 5);

        // Coverage is sorted by timestamp, with oldest at [0]
        // X ticks will be from oldest audit run to today.
        $: xTicks = [
          dayjs($coverage[0].timestamp).subtract(1, 'day'),
          dayjs().subtract(8, 'month'),
          dayjs().subtract(4, 'month'),
          dayjs().subtract(2, 'month'),
          dayjs().add(1,'week')
        ];

        let width = 900;
        let height = 400;

        $: activeJob = {};
        $: minX = dayjs(first($dates));
        $: maxX = dayjs(last($dates));
        $: xScale = scaleTime()
          .domain([minX, maxX])
          .range([padding.left, width - padding.right]);
        $: yScale = scaleLinear()
          .domain([Math.min.apply(null, yTicks), Math.max.apply(null, yTicks)])
          .range([height - padding.bottom, padding.top]);

        $: testedPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_tested)}`).join('L')}`;
        $: testedArea = `${testedPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;

        $: confPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_conf_tested)}`).join('L')}`;
        $: confArea = `${confPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;

        $: releases = uniqBy($coverage
          .map(c => ({
            release: releasePrecision(c.release, 2),
            timestamp: c.timestamp
          })), 'release');

        const dispatchDataClick = (payload) => dispatch('dataClick', payload);
       </script>

       <div class="chart" bind:clientWidth={width} bind:clientHeight={height}>
         <svg>
           <!-- y axis -->
           <g class='axis y-axis' transform="translate(0, {padding.top})">
             {#each yTicks as tick}
             <g class="tick tick-{tick}" transform="translate(0, {yScale(tick) - padding.bottom})">
               <line x2="100%"></line>
               <text y="-4">{tick} {tick === 100 ? ' percent' : ''}</text>
             </g>
             {/each}
           </g>
           <!-- x axis -->
           <g class="axis x-axis">
             {#each xTicks as tick}
             <g class="tick tick-{ tick}" transform="translate({xScale(tick)},{height})">
               <line y1="-{height}" y2="-{padding.bottom}" x1="0" x2="0"></line>
               <text y="-2">{dayjs(tick).format('DD MMM, YY')}</text>
             </g>
             {/each}
           </g>
           <!-- Releases -->
           <g class="releases">
             {#each releases as r}
             <g class="release release-{r.release}" transform="translate({xScale(r.timestamp)},{height - 20})">
               <text y="-2">{r.release}</text>
             </g>
             {/each}
           </g>
           <path class='path-area' d={testedArea}></path>
           <path class='path-line' d={testedPath}></path>
           <path class='path-line conf' d={confPath}></path>
           <path class='path-area conf' d={confArea}></path>
           {#each $coverage as point, index}
           {#if index !== 0}
           <text
             x={xScale(point.timestamp)}
             y={yScale(point.percent_tested) - 20}
             text-anchor="middle"
             class="change {point.test_hits_increase >= 0 ? 'increase' : 'decrease'}"
           >

             {point.test_hits_increase > 0
             ? `+${point.test_hits_increase}`
             : point.test_hits_increase}
           </text>
           <text
             x={xScale(point.timestamp)}
             y={yScale(point.percent_tested) - 6}
             text-anchor="middle"
             class="change {point.percent_tested_increase >= 0 ? 'increase' : 'decrease'}"
           >
             {point.percent_tested_increase > 0
             ? `+${point.percent_tested_increase}%`
             : `${point.percent_tested_increase}%`}
           </text>
           {/if}
           <circle
             cx='{xScale(point.timestamp)}'
             cy='{yScale(point.percent_tested)}'
             r='5'
             class='point'
             on:mouseover={() => {
             prefetch(`${point.bucket}/${point.job}`)
             activeJob = point
             }}
             on:mouseleave={() => activeJob = {}}
             on:click={() => dispatchDataClick({bucket: point.bucket, job: point.job})}
           />
           {#if index !== 0}
           <text
             x={xScale(point.timestamp)}
             y={yScale(point.percent_conf_tested) - 20}
             text-anchor="middle"
             class="change {point.conf_hits_increase >= 0 ? 'increase' : 'decrease'}"
           >

             {point.conf_hits_increase > 0
             ? `+${point.conf_hits_increase}`
             : point.conf_hits_increase}
           </text>
           <text
             x={xScale(point.timestamp)}
             y={yScale(point.percent_conf_tested) - 6}
             text-anchor="middle"
             class="change {point.percent_conf_tested_increase >= 0 ? 'increase' : 'decrease'}"
           >
             {point.percent_conf_tested_increase > 0
             ? `+${point.percent_conf_tested_increase}%`
             : `${point.percent_conf_tested_increase}%`}
           </text>
           {/if}
           <circle
             cx='{xScale(point.timestamp)}'
             cy='{yScale(point.percent_conf_tested)}'
             r='5'
             class='point conf'
             on:mouseover={() => {
             prefetch(`${point.bucket}/${point.job}`)
             activeJob = point
             }}
             on:mouseleave={() => activeJob = {}}
             on:click={() => dispatchDataClick({bucket: point.bucket, job: point.job})}
           />
           {/each}
           {#if !isEmpty(activeJob)}
           <text
             transform="translate({width/2 + 50},{height - 100})"
             alignment-baseline="middle"
             text-anchor="middle"
             font-size="12"
           >
             <tspan x="0" dy=".6em">{dayjs(activeJob.date).format('DD MMM, YY')}</tspan>
             <tspan x= "0" dy="1.2em">{activeJob.total_endpoints} stable endpoints</tspan>
             <tspan x="0" dy="1.2em">{activeJob.percent_tested}% tested</tspan>
             <tspan x="0" dy="1.2em">{activeJob.percent_conf_tested}% conformance tested</tspan>
           </text>
           {/if}
         </svg>
       </div>
       <div id="legend">
         <p><span class='tests'></span> Coverage by tests</p>
         <p><span class='conformance'></span>Coverage by conformance tests</p>
       </div>

       <style>
        .chart {
          max-width: 900px;
          margin-left: auto;
          margin-right: auto;
        }

        svg {
          position: relative;
          width: 100%;
          height: 450px;
          overflow: visible;
        }

        .tick {
          font-size: .725em;
          font-weight: 200;
        }

        .tick line {
          stroke: #aaa;
          stroke-dasharray: 2;
        }

        .tick text {
          fill: #666;
          text-anchor: start;
        }

        .tick.tick-0 line {
          stroke-dasharray: 0;
        }

        .x-axis .tick text {
          text-anchor: middle;
        }

        .releases .release text {
          fill: gray;
          font-style: italic;
        }

        .path-line {
          fill: none;
          stroke: rgb(234,226,108);
          stroke-linejoin: round;
          stroke-linecap: round;
          stroke-width: 1;
        }

        .path-line.conf {
          stroke: rgb( 0, 100, 100);
        }

        .path-area {
          fill: rgba(234, 226, 108, 0.2);
        }

        .path-area.conf {
          fill: rgba(0, 100, 100, 0.2);
        }

        circle.point {
          fill: orange;
          fill-opacity: 0.6;
          stroke: rgba(0,0,0,0.5);
          cursor: pointer;
        }

        circle.point.conf {
          fill: green;
        }

        #legend {
          width: 25%;
          border: 1px solid black;
          padding: 0.25rem;
          font-size: 0.75rem;
          margin-top: 1.25rem;
        }
        #legend p {
          display: flex;
          align-items: center;
          margin: 0;
          padding: 0;
        }
        #legend span {
          display: block;
          width: 2rem;
          height: 0.75rem;
          margin-right: 0.75rem;
        }
        #legend span.tests {
          background: rgba(234, 226, 108, 0.5);
        }

        #legend span.conformance {
          background: rgba(0, 100, 100, 0.5);
        }

        text.change {
          font-size: 0.75em;
          font-weight: 200;
        }

        text.increase {
          fill: green;
        }
        text.decrease {
          fill: red;
        }
       </style>

     #+end_src
*** Sunburst
**** Wrapper
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/Sunburst/Wrapper.svelte
     :END:
     #+NAME: SunburstWrapper
     #+begin_src web 
       <script>
        import Prologue from './Prologue.svelte';
        import Breadcrumb from './Breadcrumb.svelte';
        import Graph from './Graph.svelte';
        import Stats from './Stats.svelte';
       </script>

       <section id='coverage'>
         <Prologue />
         <Breadcrumb />
         <Graph on:newPathRequest />
         <Stats />
       </section>

       <style>
        section {
          display: grid;
          grid-template-columns: 700px 1fr;
        }
        @media (max-width: 667px) {
          section {
            display: flex;
            flex-flow: column;
          }
        }
       </style>
     #+end_src
**** Prologue 
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/Sunburst/Prologue.svelte
     :END:
     #+NAME: SunburstHeader
     #+begin_src web 
       <script>
        import dayjs from 'dayjs';
        import { goto } from '@sapper/app';
        import SectionHeader from '../SectionHeader.svelte';
        import { activeRelease } from '../../stores/coverage-over-time.js';

        const SPYGLASS_URL = 'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs'

        $: ({
          bucket,
          job,
          release,
          date,
          test_hits_increase,
          conf_hits_increase,
          total_endpoints
        } = $activeRelease);

        $: link = `${SPYGLASS_URL}/${bucket}/${job}`

         </script>
         {#if release}
         <SectionHeader title='{release} In Depth'>
           <em>Data from <a href="{link}" title="spyglass link" target="_blank_" rel="noreferrer noopener">an e2e test suite run</a>, from {date}</em>
         </SectionHeader>
         {/if}

       <style>
       </style>


     #+end_src
**** Breadcrumb
     :PROPERTIES:
     :header-args: :tangle ./app/src/components/Sunburst/Breadcrumb.svelte
     :END:
     #+NAME: Breadcrumb
     #+begin_src web
       <script>
        import {
          breadcrumb,
          mouseOverPath,
          opIDs
        } from '../../stores';
        import {
          levelColours,
          categoryColours,
          endpointColour
        } from '../../lib/colours.js';

        $: [level, category, operation_id] = $breadcrumb;
        $: lColour = levelColours[level] || 'white';
        $: cColour = categoryColours[category] || 'white';
        $: eColour = $opIDs[operation_id]
                   ? endpointColour($opIDs[operation_id]) 
                   : 'white';
        $: eTextColour = $opIDs[operation_id]
                       ? $opIDs[operation_id]['tested'] ? endpointColour($opIDs[operation_id]) : 'gray'
                       : 'white';
       </script>

       <div id='breadcrumb'>
         {#if $mouseOverPath.length > 0}
         <p>{#if level}<span style='border-color: {lColour}; background-color: {lColour};'>{level}</span>{/if}{#if category}<span style='background-Color: {cColour}; border-color: {cColour};'>{category}</span>{/if}{#if operation_id}<span style='border-color: {eColour}; color: {eTextColour};'> {operation_id}</span>{/if}</p>
         {/if}
       </div>

       <style>
        div{
          height: 3em;
          grid-column: 1/2;
          margin-bottom: 1em;
        }
        p {
          font-size: 1.3em;
          font-color: aliceblue;
        }
        span {
          margin: 0;
          color: #EEEEEE;
          padding: 0.25em;
          border: 1px solid;
        }
       </style>


     #+end_src
**** Graph
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Sunburst/Graph.svelte
    :END:
    
    #+NAME: Sunburst
    #+begin_src web 
      <script>

       import * as d3 from 'd3';
       import { goto } from '@sapper/app';
       import {
         compact,
         join
       } from 'lodash-es';
       import {
         activeBucketAndJob,
         activeFilters,
         mouseOverPath,
         zoomedSunburst
       } from '../../stores';
       import { createEventDispatcher } from 'svelte';
       const dispatch = createEventDispatcher();
       $: activeDepth = determineDepth($activeFilters);

       const format = d3.format(",d")
       const width = 932
       const radius = width / 8
       const arc = d3.arc()
                     .startAngle(d => d.x0)
                     .endAngle(d => d.x1)
                     .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                     .padRadius(radius * 1.5)
                     .innerRadius(d => d.y0 * radius)
                     .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))

       function determineDepth (filters) {
         // check out depth based on which filters are set.
         let { level, category, operation_id } = filters;
         let setFilters = compact([level, category, operation_id]) // compact will remove falsy values.
         if (setFilters.length === 3) {
           return 'operation_id'
         } else if (setFilters.length === 2) {
           return 'category';
         } else if (setFilters.length === 1) {
           return 'level';
         } else {
           return 'root'
         }
       };

       function depthUp () {
         // reset the activeFilter for whatever is our current depth.  
         // This will cause the sunburst to expand to the next previous filter, going up a level.
         $mouseOverPath = [];
         if (activeDepth === 'root') {
           return null
         } else if (activeDepth === 'operation_id') {
           $activeFilters['operation_id'] = '';
           $activeFilters['category'] === '';
         } else {
           $activeFilters[activeDepth] = '';
         }
         dispatch('newPathRequest', { params: $activeFilters })
       };

       function labelVisible(d) {
         return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
       }

       function labelTransform(d) {
         const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
         const y = (d.y0 + d.y1) / 2 * radius;
         return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
       }

       function mouseOver(d) {
         $mouseOverPath = d.ancestors().reverse().slice(1);
       }

       function mouseLeave () {
         $mouseOverPath = [];
       }

       function clicked (node, e) {
         // upon clicking of a node, update the active filters and url.
         let {
           bucket,
           job
         } = $activeBucketAndJob;
         let {
           level,
           category,
           operation_id
         } = node.data;
         let params = { bucket, job, level, category, operation_id}
         dispatch('newPathRequest', { params })
       };

       function setURL () {
         // push state without triggering a reload, using our active filters in order.
         // this assumes that activeFilters were set correctly before calling this function.
         let {
           bucket,
           job,
           level,
           category,
           operation_id
         } = $activeFilters;
         let filterSegments = compact([bucket, job, level, category, operation_id]);
         let urlPath = join([...filterSegments], '/');
         goto(urlPath);
       };

       $: partition = data => {
         const root = d3.hierarchy(data)
                        .sum(d => d.value)
                        .sort((a, b) => (b.data.tested - a.data.tested))
                        .sort((a, b) => (b.data.conf_tested - a.data.tested));
         return d3.partition()
                  .size([2 * Math.PI, root.height + 1])
         (root);
       }
       $: root = partition($zoomedSunburst).each(d=> d.current = d);
       $: nodes = root
         .descendants()
         .slice(1)
         .map((node) => {
           // take node and determine its opacity based on if its visible and active
           let currentOpacity = 1;
           if ($activeFilters.operation_id !== '' && node.data.operation_id !== '') {
             // if you and endpoint and we've filtered to endpoint, fade yrself if you aren't the filtered endpoint.
             currentOpacity = ($activeFilters.operation_id === node.data.name)
                            ? 1
                            : 0.3
           }
           if ($mouseOverPath.length > 0) {
             currentOpacity = ($mouseOverPath.indexOf(node) >= 0 || $activeFilters.operation_id === node.data.name)
                            ? 1
                            : 0.3
           }
           return {...node, currentOpacity};
         })
      </script>
      <div class="chart">
        <svg viewBox="0,0,932,932" style="font: 12px sans-serif;" on:mouseleave={mouseLeave} id='sunburst'>
          <g transform="translate({width/2},{width/2})" id='big-g'>
            <g>
              {#each nodes as node}
              <path
                fill={node.data.color}
                fill-opacity={node.currentOpacity}
                d={arc(node.current)}
                on:mouseover={() => mouseOver(node.current)}
                style="cursor: pointer;"
                on:mousedown={(e)=> clicked(node, e)} />
              {/each}
            </g>
            <g pointer-events='none' text-anchor='middle' style='user-select: none;'>
              {#each nodes as node}
              <text
                dy='0.35em'
                fill-opacity = {+labelVisible(node.current)}
                transform = {labelTransform(node.current)}
              >
                {node.children ? node.data.name : ''}
              </text>
              {/each}
            </g>
            <circle
              r={radius}
              fill={root.data.color}
              pointer-events="all"
              on:click={depthUp}
            />

            <text
              text-anchor='middle'
              font-size='2em'
              fill='white'
              transform={$activeFilters.category.length > 0 ? "translate(0, -15)" : ""} >
              {$activeFilters.level}
            </text>
            <text
              text-anchor='middle'
              font-size='2em'
              fill='white'
              transform="translate(0,15)">
              {$activeFilters.category}
            </text>
          </g>
        </svg>
      </div>

      <style>
       .chart {
         position: relative;
         grid-column: 1;
       }
      </style>
    #+end_src
**** Stats
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Sunburst/Stats.svelte
    :END:
    #+NAME: SunburstStats
    #+begin_src web 
      <script>
       import EndpointStats from './EndpointStats.svelte';
       import { isEmpty } from 'lodash-es';
       import { currentDepth, breadcrumb, coverageAtDepth } from '../../stores';

       let percentage = (sum, total) => ((sum / total) * 100).toFixed(2);
       $: total = $coverageAtDepth.totalEndpoints;
       $: tested = $coverageAtDepth.testedEndpoints;
       $: confTested = $coverageAtDepth.confTestedEndpoints;
       $: percentTested = `${percentage(tested,total)}%`;
       $: percentConfTested = `${percentage(confTested, total)}%`;
       $: level = $breadcrumb[0] || '';
       $: category= $breadcrumb[1] || '';
       $: endpoint = $breadcrumb[2] || '';
      </script>

      {#if $currentDepth === 'endpoint'}
      <EndpointStats />
      {:else}
      <div id='coverage-stats'>
        <p class='breadcrumb'>{level} {category}</p>
        <h2> Coverage</h2>
        <ul>
          <li><strong>{total}</strong> total endpoints</li>
          <li> <strong>{percentTested}</strong> tested ({tested} endpoints)</li>
          <li><strong>{percentConfTested}</strong> conformance tested ({confTested} endpoints)</li>
        </ul>
      </div>
      {/if}



      <style>
       div {
         grid-column: 2;
         padding-left: 1em;
         padding-right: 1em;
       }

       h2 {
         margin-bottom: 0;
       }

       p {
         margin-top: 0;
         margin-bottom: 0;
         padding: 0;
         font-weight: 200;
         font-size: 1.3em;
         height: 1.5em;
         font-variant-caps: small-caps;
       }


       ul {
         padding-left: 0;
         list-style-type: none;
       }

       strong {
         font-family: monospace;
       }

      </style>



    #+end_src
**** EndpointStats
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Sunburst/EndpointStats.svelte
    :END:
    #+NAME: EndpointStats
    #+begin_src web
      <script>
       import { endpointCoverage } from '../../stores';
       import Icon from 'fa-svelte';
       import { faCheckCircle } from '@fortawesome/free-solid-svg-icons/faCheckCircle';
       import TestTagsList from './TestTagsList.svelte';

       let checkmark = faCheckCircle;

       $: ({
         operation_id,
         tested,
         confTested,
         description,
         path,
         group,
         version,
         kind
       } = $endpointCoverage);
      </script>


      <div id='coverage-stats'>
        <p class='path'>{path}</p>
        <h2>{operation_id}</h2>

        <dl id='endpoint-details'>
          <dt>description</dt><dd>{description}</dd>
          {#if group}<dt>group</dt><dd>{group}</dd>{/if}
          {#if version}<dt>version</dt><dd>{version}</dd>{/if}
          {#if kind}<dt>kind</dt><dd>{kind}</dd>{/if}
        </dl>

        {#if tested}
        <p class='stat'> <span><Icon class='success check' icon={checkmark} /></span> Tested!</p>
        {:else}
        <p class='stat'> <span><Icon class='check fail' icon={checkmark} /></span> Untested</p>
        {/if}

        {#if confTested}
        <p class='stat'> <span><Icon class='check success' icon={checkmark} /></span> Conformance Tested</p>
        {:else}
        <p class='stat'> <span><Icon class='check fail' icon={checkmark} /></span> No Conformance Tests</p>
        {/if}
        <TestTagsList />
      </div>

      <style>
       div#coverage-stats {
         grid-column: 2;
         padding-left: 1em;
         padding-right: 1em;
       }

       h2 {
         margin-bottom: 1em;
       }

       p.path {
         margin-top: 0;
         margin-bottom: 0;
         padding: 0;
         font-weight: 200;
         font-size: 1.3em;
         font-variant-caps: small-caps;
       }

       p.stat {
         display: flex;
         align-items: center;
         font-size: 1.3em;
         margin: 0;
         font-style: italic;
         font-weight: 200;
       }

       div :global(.check) {
         font-size: 1.3em;
         padding-right: 0.25em;
         margin-top: 0.1em;
       }
       div :global(.success) {
         color: rgba(60, 180, 75, 1);
       }

       div :global(.fail) {
         color: rgba(233, 233, 233, 1);
       }

       dl {
         display: grid;
         font-size: 0.85em;
         grid-template-columns: 5rem 1fr;
         grid-template-rows: 1fr 1fr 1fr;
         width: 90%;
       }

       dt {
         border: 1px solid black;
         border-top: none;
         border-right: none;
         display: flex;
         justify-content: center;
         align-items: center;
         padding: 0;
         margin: 0;
         background: #CCCCCC;
       }

       dd {
         border: 1px solid black;
         border-top: none;
         display: inloine;
         padding: 0;
         padding-left: 1em;
         margin: 0;
         font-family: monospace;
       }

       dt:first-of-type , dd:first-of-type {
         border-top: 1px solid black;
       }






      </style>


    #+end_src
**** TestTagsList
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Sunburst/TestTagsList.svelte
    :END:
    #+begin_src web
      <script>
       import {
         activeFilters,
         testTagsForEndpoint
       } from '../../stores';
       import { goto, stores } from '@sapper/app';
       import { updateQueryParams } from '../../lib/helpers.js';

       const { page} = stores();

       function handleClick (tag) {
         let queryParams = updateQueryParams($page, {test_tags: [tag]});
         let url = `${$page.path}${queryParams}#tests`;

         activeFilters.update(af => ({...af, test_tags: [tag]}))
         document.getElementById('tests').scrollIntoView();

         goto(url)
           .then(() => {
             document.getElementById('tests').scrollIntoView();
           });
       };
      </script>


      {#if $testTagsForEndpoint.length > 0}
      <div id='test-tags'>
        <ul>
          {#each $testTagsForEndpoint as testTag}
          <li role='button' on:click={() => handleClick(testTag)}>{testTag}</li>
          {/each}
        </ul>
      </div>
      {/if}


      <style>
       li {
         cursor: pointer;
       }
      </style>


    #+end_src
*** Nav
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Nav.svelte
    :END:
    #+NAME: Nav
    #+begin_src web
      <nav>
        <img src='logo.png' alt="apisnoop logo, a magnifying glass with a 3 color pie chart inside." />
        <a href='/' class='title'>APISnoop</a>
      </nav>

      <style>
       nav {
         background: #9EEBCF; 
         color: #5E2CA5; 
         display: flex;
         align-items: center;
         padding: 0.25em;
       }
       a.title {
         margin: 0;
         font-size: 1.5em;
         color: inherit;
         text-decoration: none;
       }

       img {
         max-height: 2em;
         margin-right: 0.5em;
       }
      </style>


    #+end_src
*** TestTagsList
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/TestTagsList.svelte
    :END:
    #+begin_src web
      <script>
       import {
         activeFilters,
         testTagsForEndpoint
       } from '../stores';
       import { goto, stores } from '@sapper/app';
       import { updateQueryParams } from '../lib/helpers.js';

       const { page} = stores();

       function handleClick (tag) {
         let queryParams = updateQueryParams($page, {test_tags: [tag]});
         let url = `${$page.path}${queryParams}#tests`;

         activeFilters.update(af => ({...af, test_tags: [tag]}))
         document.getElementById('tests').scrollIntoView();

         goto(url)
           .then(() => {
             document.getElementById('tests').scrollIntoView();
           });
       };
      </script>


      {#if $testTagsForEndpoint.length > 0}
      <div id='test-tags'>
        <ul>
          {#each $testTagsForEndpoint as testTag}
          <li role='button' on:click={() => handleClick(testTag)}>{testTag}</li>
          {/each}
        </ul>
      </div>
      {/if}


      <style>
       li {
         cursor: pointer;
       }
      </style>


    #+end_src
*** Tests List
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/TestsList.svelte
    :END:
    
    #+begin_src web
      <script>
       import { 
         activeFilters,
         breadcrumb,
         testsForEndpoint,
         testTagsForEndpoint,
         filteredTests
       } from '../stores';
       import { goto, stores } from '@sapper/app';
       import { updateQueryParams } from '../lib/helpers.js';
       import { isEmpty} from 'lodash-es';

       const { page } = stores();


       $: isActiveTag = (tag) => $activeFilters.test_tags.includes(tag);
       $: endpoint = $breadcrumb[2] || 'this Endpoint';

       function toggleFilter (tag) {
         let testTags = $activeFilters.test_tags;
         let activeFilter = isActiveTag(tag);
         testTags = activeFilter
                  ? testTags.filter(t => t !== tag)
                  : testTags.concat(tag);
         let queryParams = updateQueryParams($page, {test_tags: [...testTags]});
         let url = `${$page.path}${queryParams}#tests`;
         activeFilters.update(af => ({...af, test_tags: testTags}))
         document.getElementById('tests').scrollIntoView();
         goto(url)
           .then(() => {
             document.getElementById('tests').scrollIntoView();
           });
       };

      </script>

      {#if $testsForEndpoint.length > 0 }
      <div id='tests'>
        <h2>Tests for {$breadcrumb[2]}</h2>
        <div class='tag-filter'>
          <p>filter by test tag:</p>
          <ul>
            {#each $testTagsForEndpoint as testTag}
            <li class:active={isActiveTag(testTag)} on:click={() => toggleFilter(testTag)}>{testTag}</li>
            {/each}
          </ul>
        </div>
        <ul id='tests'>
          {#each $filteredTests as fTest}
          <li>{fTest.test}</li>
          {/each}
        </ul>
      </div>
      {/if}


      <style>

       div#tests {
         min-height: 100vh;
       }

       div.tag-filter {
         padding: 0.55em;
         border: 1px solid #cccccc;
         font-size: 0.9em;
       }

       div.tag-filter p {
         font-variant-caps: small-caps;
         font-weight: 800;
       }

       div.tag-filter ul {
         display: flex;
         flex-wrap: wrap;
         list-style-type: none;
         padding-left: 0;
       }

       div.tag-filter li {
         margin: 0.25em;
         background: #f4f4f4;
         cursor: pointer;
         font-weight: 200;
       }

       div.tag-filter li.active {
         font-weight: 500;
         background: #96ccff;
         color: #001B44;
       }
      </style>



    #+end_src
*** Section Header
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/SectionHeader.svelte
    :END:
    This is to set consistent styling and spacing for each part of our homepage 
    I will be an h2 tag with particular styling, plus slots for explanatory text and timestamps and what not.
    #+NAME: Section Header
    #+begin_src web 
      <script>
       export let title;
      </script>

      <header>
        <h2>{title}</h2>
        <slot></slot>
      </header>

      <style>
       h2 {
         font-size: 1.66rem;
         font-weight: 300;
         margin: 0;
         padding: 0;
       }
      </style>
    #+end_src
    
*** Filters
    in progress
    #+NAME: Filters
    #+begin_src web

      <script>
       import {
         activeFilters,
         filteredEndpoints
       } from '../stores';
       $: filtersVisible = false;

       function visToggle () {
         filtersVisible = !filtersVisible;
       };
      </script>

      {#if !filtersVisible}
      <div class='filters off'>
        <button on:click={visToggle}>Set Filters</button>
      </div>
      {:else}
      <div class='filters on'>
        <button on:click={visToggle} class='close'>Close Filters</button>
        <h2>Set Filters</h2>
        <label>
          <input type='checkbox' bind:checked={$activeFilters.hide_tested} on:click={() => console.log('af', $activeFilters, $filteredEndpoints.length)}/>
          hide tested
        </label>
      </div>
      {/if}


      <style>
       div.filters.on {
         position: absolute;
         width: 350px;
         top: 0;
         right: 0;
         min-height: 100vh;
         background: blanchedalmond;
       }

      </style>

    #+end_src
** Queries
   :PROPERTIES:
   :header-args: :tangle ./app/src/queries/index.js
   :END:
   These are graphql queries to our postgres db.  At this moment, there is not alot of graphql magic going on, they map pretty direct to the underlying postgres sql statement.
   
   We use apollo boost for our graphql connection
   
   #+NAME: import apollo-boost
   #+begin_src js
     import { gql } from 'apollo-boost';

   #+end_src
   
*** Endpoints Tests and Useragents
    #+NAME: ENDPOINTS_TESTS_AND_USERAGENTS
    #+begin_src js
      export const ENDPOINTS_TESTS_AND_USERAGENTS = gql`
      query ENDPOINTS_TESTS_AND_USERAGENTS($bucket: String, $job: String) {
        endpoints: endpoint_coverage(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          operation_id
          level
          category
          conf_tested
          tested
          hit
          details {
            description
            path
            k8s_group
            k8s_kind
          }
        }
        tests(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          test
          test_tags
          operation_ids
        }
        useragents(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          useragent
          operation_ids
        }
      }
      `
    #+end_src
*** All Buckets and Jobs, Sans Live    
    #+NAME: ALL_BUCKETS_AND_JOBS_SANS_LIVE
    #+begin_src js
      // All buckets and jobs available in db that are not 'live'
      export const ALL_BUCKETS_AND_JOBS_SANS_LIVE = gql`
      {
        bucket_job_swagger(where: {bucket: {_neq: "apisnoop"}}) {
          bucket
          job
          job_timestamp
        }
      }
      `;
    #+end_src
*** Stable Endpoint Stats    
    #+NAME: STABLE_ENDPOINT_STATS
    #+begin_src js
      export const STABLE_ENDPOINT_STATS = gql`
      query STABLE_ENDPOINT_STATS {
        stable_endpoint_stats(where: {job: {_neq: "live"}}) {
          conf_hits
          conf_hits_increase
          date
          job
          percent_conf_tested
          percent_conf_tested_increase
          percent_tested
          percent_tested_increase
          release
          test_hits
          test_hits_increase
          total_endpoints
        }
      }
      `;
    #+end_src
** Stores
*** index
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/index.js
    :END:
    #+NAME: stores/index
    #+begin_src js
      import { writable, derived } from 'svelte/store';
      import client from '../apollo.js';
      import {
        hitByMatchingItems,
        hitByMatchingTestTags,
        isValidRegex,
        toBoolean
      } from '../lib/helpers.js';

      import {
        compact,
        concat,
        isArray,
        isEmpty,
        flattenDeep,
        groupBy,
        intersection,
        keyBy,
        map,
        mapValues,
        orderBy,
        sortBy,
        take,
        uniq
      } from 'lodash-es';

      import {
        levelColours,
        categoryColours,
        endpointColour
      } from '../lib/colours.js';

      // Based on url query params, any filters being set.
      export const activeFilters = writable({
        test_tags: [],
        hide_tested: "false",
        hide_conf_tested: "false",
        hide_untested: "false",
        useragent: '',
        tests_match: '',
        test_tags_match: '',
        bucket: '',
        job: '',
        level: '',
        category: '',
        operation_id: ''
      })

      export const mouseOverPath = writable([]);
      export const stableEndpointStats = writable([]);

      export const breadcrumb = derived(
        [activeFilters, mouseOverPath],
        ([$active, $mouse], set) => {
          let mouseCrumbs = $mouse.map(m => m.data.name);
          let activeAndMouseCrumbs = compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs]));
          let crumbs = [];
          // if length is 4, it means we are zoomed into an endpoint, and hovering over a different endpoint.
          if (activeAndMouseCrumbs.length === 4) {
            // if that's the case, we want to show the one we are hovered on.
            crumbs = activeAndMouseCrumbs.filter(crumb => crumb !== $active.operation_id);
          } else {
            crumbs = take(compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs])), 3);
          }
          set(crumbs)
        }
      );

      export const warnings = writable({
        invalidBucket: false,
        invalidJob: false,
        invalidLevel: false,
        invalidCategory: false,
        invalidEndpoint: false
      })

      // Buckets and Jobs
      export const rawBucketsAndJobs = writable([]);

      export const bucketsAndJobs = derived(
        rawBucketsAndJobs,
        ($raw, set) => {
          if ($raw.length === 0) {
            set([]);
          } else {
            let buckets = groupBy($raw, 'bucket');
            let bjs = mapValues(buckets, (allJobs) => {
              let jobs = allJobs
                  .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
                  .map(j => ({
                    job: j.job,
                    timestamp: j.job_timestamp
                  }));

              let [latestJob] = jobs;

              return {
                latestJob,
                jobs
              };
            });
            set(bjs);
          };
        }
      );

      export const defaultBucketAndJob = derived(
        bucketsAndJobs,
        ($bjs, set) => {
          if ($bjs.length === 0) {
            set({
              bucket: '',
              job: '',
              timestamp: ''
            });
          } else {
            let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
            let defaultBucket = Object.keys($bjs).includes(releaseBlocking)
                ? releaseBlocking
                : Object.keys($bjs)[0];

            set({
              bucket: defaultBucket,
              job: $bjs[defaultBucket].latestJob.job,
              timestamp: $bjs[defaultBucket].latestJob.job_timestamp
            });
          };
        }
      );

      export const activeBucketAndJob = derived(
        [activeFilters, defaultBucketAndJob, bucketsAndJobs],
        ([$filters, $default, $all], set) => {
          let base = {
            bucket: '',
            job: '',
            timestamp: ''
          };
          if ($default.bucket === '') {
            set({...base});
          } else if ($filters.bucket === '') {
            set({
              ...base,
              bucket: $default.bucket,
              job: $default.job,
              timestamp: $default.timestamp
            });
          } else {
            let timestamp = $all[$filters.bucket]['jobs'].find(job => job.job === $filters.job)['timestamp'];
            set({
              ...base,
              bucket: $filters.bucket,
              job: $filters.job,
              timestamp: timestamp
            });
          };
        });

      // All our data, for the active bucket and job. 
      export const endpointsTestsAndUseragents = writable({endpoints: '', tests: '', useragents: ''});
      export const endpoints = derived(endpointsTestsAndUseragents, $etu => $etu.endpoints);
      export const allTestsAndTags = derived(endpointsTestsAndUseragents, $etu => $etu.tests);
      export const allUseragents = derived(endpointsTestsAndUseragents, $etu => $etu.useragents);
      // Based on the url params, the exact [level, category, endpoint] we are focused on.
      export const activePath = writable([]);

      export const opIDs = derived(endpoints, ($ep, set) => {
        if ($ep.length > 0) {
          set(keyBy($ep, 'operation_id'));
        } else {
          set([]);
        }
      });

      export const filteredEndpoints = derived(
        [activeFilters, endpoints, allUseragents, allTestsAndTags],
        ([$af, $ep, $ua, $tt], set) => {
          if ($ep.length === 0) {
            set([]);
          } else {
            let endpoints = $ep
                .filter(ep => toBoolean($af.hide_tested) ? (ep.tested === false || ep.conf_tested === true) : ep)
                .filter(ep => toBoolean($af.hide_conf_tested) ? ep.conf_tested === false : ep)
                .filter(ep => toBoolean($af.hide_untested) ? ep.tested === true : ep)
                .filter(ep => ($af.useragent.length > 0 && isValidRegex($af.useragent) && $ua)
                        ? hitByMatchingItems($ua, 'useragent', $af.useragent, ep)
                        : ep)
                .filter(ep => ($af.tests_match.length > 0 && isValidRegex($af.tests_match) && $tt)
                        ? hitByMatchingItems($tt, 'test', $af.tests_match, ep)
                        : ep)
                .filter(ep => ($af.test_tags_match.length > 0 && isValidRegex($af.test_tags_match) && $tt)
                        ? hitByMatchingTestTags($tt, $af.test_tags_match, ep)
                        : ep);
            set(endpoints)
          }
        });

      export const groupedEndpoints = derived(filteredEndpoints, ($ep, set) => {
        if ($ep.length > 0) {
          let endpointsByLevel = groupBy($ep, 'level')
          set(mapValues(endpointsByLevel, endpointsInLevel => {
            let endpointsByCategory = groupBy(endpointsInLevel, 'category')
            return mapValues(endpointsByCategory, endpointsInCategory => {
              return endpointsInCategory.map (endpoint => {
                return {
                  ...endpoint,
                  name: endpoint.operation_id,
                  value: 1,
                  color: endpointColour(endpoint)
                };
              });
            });
          }));
        } else {
          set({});
        }
      });


      export const sunburst = derived(groupedEndpoints, ($gep, set) => {
        if (!isEmpty($gep)) {
          var sunburst = {
            name: 'root',
            color: 'white',
            children: map($gep, (endpointsByCategoryAndOpID, level) => {
              return {
                name: level,
                color: levelColours[level] || levelColours['unused'],
                level: level,
                category: '',
                operation_id: '',
                children: map(endpointsByCategoryAndOpID, (endpointsByOpID, category) => {
                  return {
                    name: category,
                    level: level,
                    category: category,
                    operation_id: '',
                    color: categoryColours[category] ||  'rgba(183, 28, 28, 1)', // basic color so things compile right.
                    children: sortBy(endpointsByOpID, [
                      (endpoint) => endpoint.testHits > 0,
                      (endpoint) => endpoint.conformanceHits > 0
                    ])
                  };
                })
              };
            })
          };
          sunburst.children = orderBy(sunburst.children, 'name', 'desc');
          set(sunburst)
        } else {
          set({})
        }
      });

      export const zoomedSunburst = derived(
        [sunburst, activeFilters],
        ([$sunburst, $filters], set) => {
          let level = $filters.level;
          let category = $filters.category
          if (category) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            let sunburstAtCategory = sunburstAtLevel.children.find(child => child.name === category);
            set(sunburstAtCategory);
          } else if (!category && level) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            set(sunburstAtLevel);
          } else {
            set($sunburst)
          }
        })

      export const currentDepth = derived(breadcrumb, ($breadcrumb, set) => {
        let depths = ['root', 'level', 'category', 'endpoint']
        let depth = $breadcrumb.length;
        set(depths[depth])
      });

      export const coverageAtDepth = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $depth, $eps], set) => {
        let eps;
        if (isEmpty($eps)) {
          set({})
          return;
        } else if ($bc.length === 0) {
          eps = $eps;
        } else if ($bc.length === 1) {
          eps = $eps.filter(ep => ep.level === $bc[0])
        } else if ($bc.length === 2) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1])
        } else if ($bc.length === 3) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1] && ep.operation_id === $bc[2])
        } else {
          eps = $eps;
        }
        let totalEndpoints = eps.length;
        let testedEndpoints = eps.filter(ep => ep.tested).length;
        let confTestedEndpoints = eps.filter(ep => ep.conf_tested).length;
        set({
          totalEndpoints,
          testedEndpoints,
          confTestedEndpoints
        });
      });

      export const endpointCoverage = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $cd, $eps], set) => {
        let endpoint;
        let opId;
        let defaultCoverage = {
          tested: '',
          operation_id : '',
          confTested: '',
          description: '',
          path: '',
          group: '',
          version: '',
          kind: ''
        };
        if (isEmpty($eps) || $cd !== 'endpoint') {
          set(defaultCoverage);
        } else {
          opId = $bc[2]
          endpoint = $eps.find(ep => ep.operation_id === opId)
          let {
            tested,
            conf_tested: confTested,
            operation_id,
            details : {
              path,
              description,
              k8s_group: group,
              k8s_version: version,
              k8s_kind: kind
            }
          } = endpoint;
          set({
            tested,
            confTested,
            operation_id,
            path,
            description,
            group,
            version,
            kind
          });
        }
      });

      export const testsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let tests = $tt
                .filter(t => t.operation_ids.includes(opID))
            set(tests);
          }
        }
      );


      export const testTagsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let testTags = $tt
                .filter(t => t.operation_ids.includes(opID))
                .map(t => t.test_tags);
            let testTagsUniq = uniq(flattenDeep(testTags))
            set(testTagsUniq);
          }
        }
      );

      export const validTestTagFilters = derived(
        [activeFilters, testTagsForEndpoint],
        ([$af, $tt], set) => {
          if ($af.test_tags.length === 0 || $tt.length === 0) {
            set([]);
          } else {
            let validFilters = isArray($af.test_tags)
                ? $af.test_tags.filter(f => $tt.includes(f))
                : [$af.test_tags].filter(f => $tt.includes(f));
            set(validFilters);
          }
        });

      export const filteredTests = derived(
        [testsForEndpoint, validTestTagFilters],
        ([$t, $vf]) => {
          let tests;
          if ($vf.length === 0) {
            tests = $t; 
          } else {
            tests = $t.filter(test => {
              return intersection(test.test_tags, $vf).length > 0;
            });
          }
          return tests;
        });


    #+end_src
*** CoverageOverTime
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/coverage-over-time.js
    :END:
    #+NAME: coverage-over-time.js
    #+begin_src js
      import dayjs from 'dayjs';
      import { derived }  from 'svelte/store';
      import {
        findKey,
        flatten,
        sortBy
      } from 'lodash-es';
      import {
        bucketsAndJobs,
        defaultBucketAndJob,
        stableEndpointStats,
        activeFilters
      } from './index.js';


      export const dates = derived(
        [bucketsAndJobs, defaultBucketAndJob],
        ([$bjs, $default], set) => {
          if ($bjs.length === 0) {
            set([])
          } else {
            // let bucket = $default.bucket;
            let buckets = Object.keys($bjs);
            let allJobs = buckets.reduce((acc, cur) => {
              let jobs = sortBy($bjs[cur]['jobs'], 'timestamp');
              return [...acc, ...jobs];
            }, []);

            allJobs = sortBy(allJobs,'timestamp');
            set(allJobs.map(job => job.timestamp));
          }
        }
      );

      export const coverage = derived(
        [defaultBucketAndJob, stableEndpointStats, bucketsAndJobs],
        ([$default, $stats, $bjs], set) => {
          if ($default.bucket === '') {
            set([]);
          } else {
            let coverageStats = $stats
                .filter(stat => stat.job !== 'live')
                .map(stat => {
                  let bucket = findKey($bjs, (o) => o.jobs.map(job => job.job).includes(stat.job))
                  return {
                    ...stat,
                    bucket,
                    timestamp: dayjs(stat.date)
                  };
                });
            coverageStats = sortBy(coverageStats, 'timestamp');
            set(coverageStats);
          }
        }
      );

      export const activeRelease = derived(
      [activeFilters, coverage],
      ([$af, $c], set) => {
      if ($af.bucket && $c.length >0) {
      let active = $c.find(cov => cov.bucket === $af.bucket && cov.job === $af.job)
      set(active)
      } else {
      set({})
      }
      }


      #+end_src);
** Utility Functions (/lib/)
*** helpers
    :PROPERTIES:
    :header-args: :tangle ./app/src/lib/helpers.js
    :END:
    #+NAME: helpers
    #+begin_src js
      import {
        forEach,
        trimEnd,
        groupBy,
        mapValues,
        trimStart,
        flatten,
        uniq
      } from 'lodash-es';

      export const updateQueryParams = (page, query) => {
        // given a sapper page store, and new queries
        // construct a url string with old and new queries.
        let newQueries = {
          ...page.query,
          ...query
        };

        let queryStrings = {};
        forEach(newQueries, (v, k) => {
          queryStrings[k] = trimStart(v.reduce((acc, cur) => `${acc}${k}=${cur}&`, ''), '&');
        });

        let queryNames = Object.keys(queryStrings);
        let fullQueryString = trimEnd(queryNames.reduce((acc, cur) => `${acc}${queryStrings[cur]}`, '?'), '&');
        return fullQueryString;
      };

      export const toBoolean = (str) => {
        str = str.toString().toLowerCase();
        let truths = ["true", "t", "yes", "1", "truth"]
        return truths.includes(str)
      }

      export const isValidRegex = (regex) => {
        try {
          new RegExp(regex);
        } catch (e) {
          return false;
        }
        return true;
      };

      export const hitByMatchingItems = (items, key,  regex, endpoint) => {
        // given an array of objects, items, a key to compare, and the regex to match.
        // return true if endpoint is hit by any item whose key value matches the regex.
        regex = new RegExp(regex);
        let matchingItems = items.filter(ua => regex.test(ua[key]));
        let endpointsHitByItems = uniq(flatten(matchingItems.map(item => item.operation_ids)));
        return endpointsHitByItems.includes(endpoint.operation_id);
      };

      export const hitByMatchingTestTags = (tests, regex, endpoint) => {
        // given an array of tests, each containing an array of test_tags, and the regex to match.
        // filter tests by those with at least one tag that matches regex filter.
        // return true if endpoint is hit by any of these filtered tests.
        regex = new RegExp(regex);
        let matchingTests = tests.filter(test => test.test_tags.some((tag) => regex.test(tag)));
        let endpointsHitByTests = uniq(flatten(matchingTests.map(test => test.operation_ids)));
        return endpointsHitByTests.includes(endpoint.operation_id);
      };

      export const determineBucketAndJob = (bucketsAndJobs, bucketParam, jobParam) => {
        let bucket;
        let job;
        let buckets = groupBy(bucketsAndJobs, 'bucket');
        let bj = mapValues(buckets, (allJobs) => {
          let jobs = allJobs
              .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
              .map(j => ({job: j.job, timestamp: j.job_timestamp}));
          let [latestJob] = allJobs.map(j => ({job: j.job, timestamp: j.job_timestamp}));
          return {
            latestJob,
            jobs
          };
        });

        let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
        let defaultBucket = Object.keys(bj).includes(releaseBlocking)
            ? releaseBlocking
            : Object.keys(bj)[0];
        let defaultJob = bj[defaultBucket]['latestJob'].job;

        if (!bucketParam) {
          bucket = defaultBucket;
          job = defaultJob;
        } else if (bucketParam && !jobParam) {
          bucket = isValidBucket(bucketParam, bj)
            ? bucketParam
            : defaultBucket;
          job = bj[bucket]['latestJob'].job
        } else {
          bucket = isValidBucket(bucketParam, bj)
            ? bucketParam
            : defaultBucket;
          job = isValidJob(bj[bucket], jobParam)
            ? jobParam
            : bj[bucket]['latestJob'].job
        }
        return {
          bucket,
          job
        };
      }

      function isValidBucket (bucket, bjs) {
        return Object.keys(bjs).includes(bucket);
      }

      function isValidJob  (bucket, job) {
        let jobs = bucket.jobs.map(job => job.job);
        return jobs.includes(job);
      }

    #+end_src
**** releasePrecision
     #+NAME: releasePrecision
     #+begin_src js
       // SemverString Number -> SemVerString
       // SemverString : Numbers separated by points, representing a software release
       // Given SemverString s and number n, return string of n level specificity
       export const releasePrecision = (s , n) => s.split('.').slice(0,n).join('.');
     #+end_src
* Building the App
** Dockerfile
   #+begin_src dockerfile :tangle ./app/Dockerfile
     FROM node:slim

     RUN addgroup --system --gid 1001 appuser \
       &&  adduser --system --uid 1001 --ingroup appuser appuser

     COPY . /webapp

     RUN chown -R appuser:appuser /webapp

     USER appuser

     WORKDIR /webapp

     RUN npm install

     EXPOSE 3000
     # EXPOSE 10000

     # RUN npm run build
     # USER root

     # CMD ["npm", "start"]
     CMD ["npm", "run", "dev"]
   #+end_src

** cloudbuild.yaml
   #+begin_src yaml :tangle ./app/cloudbuild.yaml
     steps:
       - name: gcr.io/cloud-builders/docker
         args: ['build', '-t', 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
                '--build-arg', 'IMAGE_ARG=gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
                '.']
     substitutions:
       _GIT_TAG: '12345'
     images:
       - 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG'
     options:
       substitution_option: 'ALLOW_LOOSE'
   #+end_src

* Deployment
** deployment.yaml
   #+begin_src yaml :tangle ./deployment/deployment.yaml
     apiVersion: apps/v1
     kind: Deployment
     metadata:
       name: webapp
     spec:
       replicas: 1
       selector:
         matchLabels:
           io.apisnoop.webapp: webapp
       template:
         metadata:
           labels:
             io.apisnoop.webapp: webapp
         spec:
           restartPolicy: Always
           containers:
           - name: webapp
             image: "gcr.io/k8s-staging-apisnoop/webapp:v20200211-0.9.34-1-g24cf96f"
             ports:
             - containerPort: 3000
   #+end_src

** ingress.yaml
   #+begin_src yaml :tangle ./deployment/ingress.yaml
     apiVersion: extensions/v1beta1
     kind: Ingress
     metadata:
       name: webapp-ingress
       annotations:
         nginx.ingress.kubernetes.io/server-alias: "apisnoop.local.ii.coop, apisnoop.local.ii.nz, apisnoop.local.sharing.io"
       # annotations:
       #   nginx.ingress.kubernetes.io/app-root: /
       # annotations:
       #   nginx.ingress.kubernetes.io/rewrite-target: /$2
     spec:
       rules:
       - host: apisnoop.localho.st
         http:
           paths:
           - path: /
             backend:
               serviceName: webapp
               servicePort: 3000
   #+end_src

** kustomization.yaml
   #+begin_src yaml :tangle ./deployment/kustomization.yaml
     apiVersion: kustomize.config.k8s.io/v1beta1
     kind: Kustomization
     resources:
       - deployment.yaml
       - service.yaml
       - ingress.yaml
       # TODO set ingress to apisnoop.local.sharing.io 
   #+end_src

** service.yaml
   #+begin_src yaml :tangle ./deployment/service.yaml
     apiVersion: v1
     kind: Service
     metadata:
       name: webapp
     spec:
       selector:
         io.apisnoop.webapp: webapp
       ports:
       - name: "3000"
         port: 3000
         targetPort: 3000
   #+end_src

* Footnotes
** Scratch sql
   #+begin_src sql-mode
     select bucket from bucket_job_swagger; 
   #+end_src

   #+RESULTS:
   #+begin_src sql-mode
     bucket           
       ---------------------------
       ci-kubernetes-e2e-gci-gce
       apisnoop
       (2 rows)

   #+end_src

   
