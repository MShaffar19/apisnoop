# -*- ii: apisnoop; -*-
#+TITLE: Get Operations and Their Tests

* Purpose
  This org prepares a view for looking at get operations and the tests that hit them.
  We do this using the new schema and tables created in [[file:~/apisnoop/tickets/apisnoop/351_conformance_progress.org][351: conformance progress]] , but i'll bring over the main views here to make setting it up in the future quicker (in case this connection dies).
* Setup  
** Setup schema
   #+NAME: Create Conformance Schema
   #+begin_src sql-mode :results silent
   CREATE SCHEMA "conformance";
   #+end_src
   
** Create tables
   #+NAME: create open_api table
   #+begin_src sql-mode :results silent
     CREATE TABLE "conformance"."open_api"(
       release text,
       release_date timestamp,
       endpoint text,
       level text,
       category text,
       path text,
       k8s_group text,
       k8s_version text,
       k8s_kind text,
       k8s_action text,
       deprecated boolean,
       description text,
       spec text,
       PRIMARY KEY (release, endpoint)
     );
   #+end_src
   
   #+NAME: create tests_info table
    #+begin_src sql-mode :results silent
      CREATE TABLE conformance.test_info(
        testname text,
        codename text,
        release text,
        description text,
        file text
      );
    #+end_src
    
 #+NAME: audit_event
 #+BEGIN_SRC sql-mode
   CREATE UNLOGGED TABLE conformance.audit_event (
     release text,
     release_date text,
     audit_id text NOT NULL,
     endpoint text,
     useragent text,
     test text,
     test_hit boolean,
     conf_test_hit boolean,
     data jsonb NOT NULL,
     id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     ingested_at timestamp DEFAULT CURRENT_TIMESTAMP
   );
 #+END_SRC

 #+RESULTS: audit_event
 #+begin_src sql-mode
 CREATE TABLE
 #+end_src

 #+NAME: index the raw_audit_event
 #+BEGIN_SRC sql-mode
 CREATE INDEX idx_conf_audit_event_endpoint  ON conformance.audit_event(endpoint);
 CREATE INDEX idx_conf_audit_event_test_hit ON conformance.audit_event(test_hit);
 CREATE INDEX idx_conf_audit_event_conf_test_hit ON conformance.audit_event(conf_test_hit);
 #+END_SRC

 #+RESULTS: index the raw_audit_event
 #+begin_src sql-mode
 CREATE INDEX
 #+end_src

** Create loading functions
   #+NAME: load_open_api.sql
   #+BEGIN_SRC sql-mode :results silent
     set role dba;
     DROP FUNCTION IF EXISTS "conformance"."load_open_api";
     CREATE OR REPLACE FUNCTION "conformance"."load_open_api"(
       custom_release text default null
       )
     RETURNS text AS $$
     <<load_open_api.py>>
     plpy.execute((sql))
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC

   #+NAME: load_open_api.py
   #+BEGIN_SRC python :results output
          from string import Template
          import json
          import time  
          import datetime
          from urllib.request import urlopen, urlretrieve
          from snoopUtils import determine_bucket_job, fetch_swagger
          K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
          OPEN_API_PATH = "/api/openapi-spec/swagger.json"

          release_dates = {
            "v1.0.0": "2015-07-10",
            "v1.1.0": "2015-11-09",
            "v1.2.0": "2016-03-16",
            "v1.3.0": "2016-07-01",
            "v1.4.0": "2016-09-26",
            "v1.5.0": "2016-12-12",
            "v1.6.0": "2017-03-28",
            "v1.7.0": "2017-06-30",
            "v1.8.0": "2017-08-28",
            "v1.9.0": "2017-12-15",
            "v1.10.0": "2018-03-26",
            "v1.11.0":  "2018-06-27",
            "v1.12.0": "2018-09-27",
            "v1.13.0": "2018-12-03" ,
            "v1.14.0": "2019-03-25",
            "v1.15.0": "2019-06-19",
            "v1.16.0": "2019-09-18",
            "v1.17.0": "2019-12-07",
            "v1.18.0": "2020-03-25"
          }
          if custom_release is not None:
            release = custom_release
            open_api_url = K8S_REPO_URL + release + OPEN_API_PATH
            open_api = json.loads(urlopen(open_api_url).read().decode('utf-8')) # may change this to ascii
            rd = release_dates[release]
            release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
          else:
            bucket, job = determine_bucket_job()
            swagger, metadata, commit_hash = fetch_swagger(bucket, job)
            open_api = swagger
            open_api_url = K8S_REPO_URL + commit_hash + OPEN_API_PATH
            release_date = int(metadata['timestamp'])
            release = metadata["version"].split('-')[0].replace('v','')

          sql = Template("""
             WITH open AS (
               SELECT '${open_api}'::jsonb as api_data)
                 INSERT INTO "conformance"."open_api"(
                   release,
                   release_date,
                   endpoint,
                   level,
                   category,
                   path,
                   k8s_group,
                   k8s_version,
                   k8s_kind,
                   k8s_action,
                   deprecated,
                   description,
                   spec
                 )
             SELECT
               trim(leading 'v' from '${release}') as release,
               to_timestamp(${release_date}) as release_date,
               (d.value ->> 'operationId'::text) as endpoint,
               CASE
                 WHEN paths.key ~~ '%alpha%' THEN 'alpha'
                 WHEN paths.key ~~ '%beta%' THEN 'beta'
                 ELSE 'stable'
               END AS level,
               split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
               ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
               ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
               ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
               paths.key AS path,
               (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
               CASE
                 WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
                 ELSE false
               END AS deprecated,
               (d.value ->> 'description'::text) AS description,
               '${open_api_url}' as spec
               FROM
                   open
                    , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
                    , jsonb_each(paths.value) d(key, value)
                    , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
              ORDER BY paths.key;
                        """).substitute(release = release,
                                        release_date = release_date,
                                        open_api = json.dumps(open_api).replace("'","''"),
                                        open_api_url = open_api_url)
      #+END_SRC
      
   #+NAME: load_tests
   #+BEGIN_SRC sql-mode :results silent
     set role dba;
     DROP FUNCTION IF EXISTS load_tests;
     CREATE OR REPLACE FUNCTION conformance.load_tests()
     RETURNS text AS $$
     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   WITH jsonb_array AS (
                   SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                   INSERT INTO conformance.test_info(testname, codename, release, description, file)
                      SELECT
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      CASE
                        WHEN ((test_data->>'release') = '') THEN '1.8.0'
                        WHEN ((test_data->>'release') like '%,%')
                          THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                        ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                      END as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     try:
         plpy.execute(sql)
         return 'conformance.yaml loaded into conformance.tests_info!'
     except Exception as e:
         return 'error occured: ', e
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC
      
    #+NAME: load_audit_events.sql
    #+BEGIN_SRC sql-mode :noweb yes :results silent
      set role dba;
      CREATE OR REPLACE FUNCTION conformance.load_audit_events(
        custom_bucket text default null,
        custom_job text default null)
        RETURNS text AS $$
        from string import Template
        from snoopUtils import determine_bucket_job, download_and_process_auditlogs, fetch_swagger

        bucket, job = determine_bucket_job(custom_bucket, custom_job)
        auditlog_file = download_and_process_auditlogs(bucket, job)
        _, metadata, _ = fetch_swagger(bucket, job)
        release_date = int(metadata['timestamp'])
        release = metadata["version"].split('-')[0].replace('v','')
  
        sql = Template("""
          CREATE TEMPORARY TABLE conformance_audit_event_import(data jsonb not null) ;
          COPY conformance_audit_event_import(data)
          FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

          INSERT INTO conformance.audit_event(release, release_date,
                                  audit_id, endpoint,
                                  useragent, test,
                                  test_hit, conf_test_hit,
                                  data)

          SELECT trim(leading 'v' from '${release}') as release,
                  '${release_date}',
                  (raw.data ->> 'auditID'),
                  (raw.data ->> 'operationId') as endpoint,
                  (raw.data ->> 'userAgent') as useragent,
                  CASE
                    WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                      THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                    ELSE null
                  END as test,
                  ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                  ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                  raw.data
            FROM conformance_audit_event_import raw;
                  """).substitute(
                      audit_logfile = auditlog_file,
                      release = release,
                      release_date = release_date,
                  )
        try:
            plpy.execute(sql)
            return "it worked"
        except plpy.SPIError as plpyError:
            print("something went wrong with plpy: ") 
            return plpyError
        except:
            return "something unknown went wrong"
        $$ LANGUAGE plpython3u ;
        reset role;
    #+END_SRC
** Import data using loading functions
    #+NAME: load open_api
    #+begin_src sql-mode
      WITH releases AS (
        SELECT column1 as release
          FROM (VALUES
                ('v1.9.0'),
                ('v1.10.0'),
                ('v1.11.0'),
                ('v1.12.0'),
                ('v1.13.0'),
                ('v1.14.0'),
                ('v1.15.0'),
                ('v1.16.0'),
                ('v1.17.0'),
                ('v1.18.0')
          ) as rlist
        )
  SELECT f.*
    FROM
        releases r
      , LATERAL conformance.load_open_api(r.release) f
        ;
#+end_src

    #+NAME: Load test_info
    #+begin_src sql-mode
    select * from conformance.load_tests();
    #+end_src

    #+RESULTS: Load test_info
    #+begin_src sql-mode
                          load_tests                      
    ------------------------------------------------------
     conformance.yaml loaded into conformance.tests_info!
    (1 row)

    #+end_src
    

    #+NAME: load audit_event
    #+begin_src sql-mode :results silent
    select * from conformance.load_audit_events();
    #+end_src


** Create Views
   #+NAME: Stable Endpoints
   #+begin_src sql-mode :results silent
     CREATE MATERIALIZED VIEW conformance.stable_endpoint_first AS
     SELECT DISTINCT
       oa.endpoint,
       (array_agg(test.release order by string_to_array(test.release, '.')::int[]))[1] as first_conformance_test,
       (array_agg(test.testname order by string_to_array(test.release, '.')::int[]))[1] as test,
       (array_agg(test.codename order by string_to_array(test.release, '.')::int[]))[1] as codename,
       (array_agg(test.file order by string_to_array(test.release, '.')::int[]))[1] as file,
       (array_agg(oa.release order by string_to_array(oa.release, '.')::int[]))[1] as first_release
       FROM
           conformance.audit_event ae
           JOIN conformance.open_api oa ON(ae.endpoint = oa.endpoint)
           LEFT JOIN conformance.test_info test on (ae.test = test.codename)
        WHERE oa.level = 'stable'
        GROUP BY 1
        ; 
   #+end_src


  #+NAME: conformance progress and still untested
  #+begin_src sql-mode :results silent
  CREATE VIEW conformance.conformance_progress AS 
    WITH current_stable_endpoints AS (
      SELECT
        open_api.endpoint
        FROM
            conformance.open_api
        WHERE
          release = '1.19.0'
          AND level = 'stable'
          AND deprecated is false
    ), endpoints_per_release AS (
      SELECT
        release,
        endpoint
        FROM
            conformance.open_api
            NATURAL INNER JOIN current_stable_endpoints
    )
    SELECT
      release,
      count(*) as stable_endpoints,
      count(*) FILTER (WHERE epr.release = firsts.first_release) as rel_endpoints,
      count(*) FILTER (WHERE epr.release = firsts.first_release AND epr.release = firsts.first_conformance_test) as rel_endpoints_conf_tested,
      count(*) FILTER (WHERE epr.release = firsts.first_release AND firsts.first_conformance_test IS NULL) as rel_endpoints_still_untested,
      count(*) FILTER (WHERE firsts.first_conformance_test IS NULL) as total_endpoints_still_untested
      FROM
          endpoints_per_release epr
            LEFT JOIN conformance.stable_endpoint_first firsts ON (epr.endpoint = firsts.endpoint)
      GROUP BY 1
        ORDER BY string_to_array(release, '.')::int[]
              ;
  #+end_src
** Explore
    #+NAME: endpoints and their tests
    #+begin_src sql-mode
    
    #+end_src
   
   
   
