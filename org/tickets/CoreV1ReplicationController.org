# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
* TODO [0%] In-Cluster Setup                                    :neverexport:
  :PROPERTIES:
  :LOGGING:  nil
  :END:
** TODO Connect demo to right eye

   #+begin_src tmate :session foo:hello :eval never-export
     echo "What parts of Kubernetes do you depend on $USER?"
   #+end_src
** Tilt Up
   #+begin_src tmate :session foo:hello :eval never-export
     cd ~/apisnoop
     tilt up --host 0.0.0.0
   #+end_src
** TODO Verify Pods Running
   #+begin_src shell
     kubectl get pods
   #+end_src

   #+RESULTS:
   #+begin_example
   NAME                                    READY   STATUS    RESTARTS   AGE
   apisnoop-auditlogger-6c6865b55c-5lpfl   1/1     Running   1          4m53s
   hasura-75bf5b5869-mjzjz                 1/1     Running   0          4m46s
   kubemacs-0                              1/1     Running   0          8m51s
   pgadmin-fbb7659d7-jf2l5                 1/1     Running   0          4m53s
   postgres-6d9dbb6fc8-88x7b               1/1     Running   0          4m53s
   webapp-864985fb7f-6trtc                 1/1     Running   0          4m30s
   #+end_example

** TODO Check it all worked

   #+begin_src sql-mode :results replace
     \d+
   #+end_src

   #+RESULTS:
   #+begin_SRC example
                                                                              List of relations
    Schema |               Name               |       Type        |  Owner   |  Size   |                                    Description                                    
   --------+----------------------------------+-------------------+----------+---------+-----------------------------------------------------------------------------------
    public | api_operation                    | view              | apisnoop | 0 bytes | 
    public | api_operation_material           | materialized view | apisnoop | 3056 kB | details on each operation_id as taken from the openAPI spec
    public | api_operation_parameter_material | materialized view | apisnoop | 5008 kB | the parameters for each operation_id in open API spec
    public | audit_event                      | view              | apisnoop | 0 bytes | a record for each audit event in an audit log
    public | bucket_job_swagger               | table             | apisnoop | 3128 kB | metadata for audit events  and their respective swagger.json
    public | endpoint_coverage                | view              | apisnoop | 0 bytes | the test hits and conformance test hits per operation_id & other useful details
    public | endpoint_coverage_material       | materialized view | apisnoop | 144 kB  | 
    public | endpoints_hit_by_new_test        | view              | apisnoop | 0 bytes | list endpoints hit during our live auditing alongside their current test coverage
    public | projected_change_in_coverage     | view              | apisnoop | 0 bytes | overview of coverage stats if the e2e suite included your tests
    public | raw_audit_event                  | table             | apisnoop | 379 MB  | a record for each audit event in an audit log
    public | stable_endpoint_stats            | view              | apisnoop | 0 bytes | coverage stats for entire test run, looking only at its stable endpoints
    public | tests                            | view              | apisnoop | 0 bytes | 
    public | untested_stable_core_endpoints   | view              | apisnoop | 0 bytes | list stable core endpoints not hit by any tests, according to their test run
    public | useragents                       | view              | apisnoop | 0 bytes | 
   (14 rows)

   #+end_SRC

** TODO Check current coverage
   #+NAME: stable endpoint stats
   #+begin_src sql-mode
     select * from stable_endpoint_stats where job != 'live';
   #+end_src

* Identify an untested feature Using APISnoop                        :export:

According to this APIsnoop query, there are still some remaining ConfigMap endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      path,
      description
      FROM untested_stable_core_endpoints
      where path not like '%volume%'
      and operation_id ilike '%ReplicationController%'
     ORDER BY operation_id desc
     -- LIMIT 25
           ;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
                       operation_id                      |                                path                                 |                          description                           
  -------------------------------------------------------+---------------------------------------------------------------------+----------------------------------------------------------------
   replaceCoreV1NamespacedReplicationControllerStatus    | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | replace status of the specified ReplicationController
   readCoreV1NamespacedReplicationControllerStatus       | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | read status of the specified ReplicationController
   patchCoreV1NamespacedReplicationControllerStatus      | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status | partially update status of the specified ReplicationController
   patchCoreV1NamespacedReplicationControllerScale       | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale  | partially update scale of the specified ReplicationController
   patchCoreV1NamespacedReplicationController            | /api/v1/namespaces/{namespace}/replicationcontrollers/{name}        | partially update the specified ReplicationController
   listCoreV1ReplicationControllerForAllNamespaces       | /api/v1/replicationcontrollers                                      | list or watch objects of kind ReplicationController
   deleteCoreV1CollectionNamespacedReplicationController | /api/v1/namespaces/{namespace}/replicationcontrollers               | delete collection of ReplicationController
  (7 rows)

  #+end_SRC

* Use API Reference to Lightly Document the Feature                  :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [client-go - MyResourceReplaceMe](https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/resourcename.go)

* The mock test                                                      :export:
** Test outline
1. Create a ReplicationController with a static label and scale of one

2. Patch the ReplicationController with a new Label and updated data

3. Get the ReplicationController to ensure it's patched

4. Scale the ReplicationController up to three

5. Get ReplicationController(1), ensure that it has a scale of three 

5. Patch the ReplicationControllerStatus

6. List all ReplicationControllers in all Namespaces with a LabelSelector
   find the ReplicationController(1)
   ensure that the ReplicationController is found and is patched
   ensure that the ReplicationControllerStatus has an updated Status

7. Delete Namespaced ReplicationController(1) via a Collection with a LabelSelector

** Example in Go
   #+begin_src go
     package main

     import (
       "fmt"
       "flag"
       "os"
       "encoding/json"
       v1 "k8s.io/api/core/v1"
       //v1 "k8s.io/kubernetes/pkg/apis/core"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/client-go/kubernetes"
       "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
       autoscalingv1 "k8s.io/api/autoscaling/v1"
     )

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
         fmt.Println(err)
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)

       testDefaultNS := "default"
       testResourceName := "testRC"
       testRcInitialScale := int32(1)
       testRcIncreaseByScale := int32(2)
       testRcExpectedScale := testRcInitialScale + testRcIncreaseByScale

       _, err = ClientSet.CoreV1().ReplicationController(testDefaultNS).Create(*v1.ReplicationController{
         ObjectMeta: metav1.ObjectMeta{
           Name: testResourceName,
           Labels: map[string]string{"rc-static": "true"},
         },
         Spec: v1.ReplicationControllerSpec{
           Replicas: *testRcInitialScale,
           Template: v1.PodTemplateSpec{
             Spec: v1.PodSpec{
               Containers: []v1.Container{
                 {
                   Name: testResourceName,
                   Image: "nginx",
                 },
               },
             },
           },
         },
       })
       if err != nil {
         fmt.Println(err)
         return
       }
       fmt.Println("[status] created ReplicationController")

       rcPatch, err := json.Marshal(map[string]interface{}{
         "metadata": map[string]interface{}{
           "labels": map[string]string{
             "rc": "patched",
           },
         },
       })
       if err != nil {
         fmt.Println(err)
         return
       }
       _, err = ClientSet.CoreV1().ReplicationController(testDefaultNS).Patch(testResourceName, types.StrategicMergePatchType, []byte(rcPatch))
       if err != nil {
         fmt.Println(err)
         return
       }
       fmt.Println("[status] patched ReplicationController")

       rcGet, err := ClientSet.CoreV1().ReplicationController(testDefaultNS).Get(testResourceName, metav1.GetOptions{})
       if err != nil {
         fmt.Println(err)
         return
       }
       if rcGet.ObjectMeta.Labels["rc"] != "patched" {
         fmt.Println("[error] ReplicationController was not successfully patched")
         return
       }
       if rcGet.Spec.Replicas != testRcInitialScale {
         fmt.Println("[error] incorrect count of Replicas in ReplicationController")
         return
       }
       fmt.Println("[status] found ReplicationController")

       scale := autoscalingv1.Scale{
         Spec: autoscalingv1.ScaleSpec{
           Replicas: testRcInitialScale + testRcIncreaseByScale,
         },
       }

       _, err = ClientSet.CoreV1().ReplicationController(testDefaultNS).UpdateScale(testResourceName, &scale, metav1.UpdateOptions{})
       if err != nil {
         fmt.Println(err)
         return
       }

       rcGet, err = ClientSet.CoreV1().ReplicationController(testDefaultNS).Get(testResourceName, metav1.GetOptions{})
       if err != nil {
         fmt.Println(err)
         return
       }
       if rcGet.Spec.Replicas != testRcExpectedScale {
         fmt.Println("[error] incorrect count of Replicas in ReplicationController")
         return
       }
       fmt.Println("[status] found ReplicationController")

       // patch ReplicationControllerStatus using client-go's DynamicClient

       rcList, err := ClientSet.CoreV1().ReplicationController(testDefaultNS).List(metav1.ListOptions{LabelSelector: "rc-static=true"})
       if err != nil {
         fmt.Println(err)
         return
       }
       rcFound := false
       for _, rcItem := range rcList.Items {
         if rcItem.Name == testResourceName && rcItem.ObjectMeta.Labels["rc"] != "patched" {
           rcFound = true
           break
         }
       }
       if rcFound != true {
         fmt.Println("[status] failed to find ReplicationController in list")
         return
       }

       err = ClientSet.CoreV1().ReplicationController(testDefaultNS).Delete(testResourceName, &metav1.DeleteOptions{})
       if err != nil {
         fmt.Println(err)
         return
       }

       // write test here
       fmt.Println("[status] complete")

     }
   #+end_src

   #+RESULTS:
   #+begin_src go
   #+end_src

* Verify Increase it Coverage with APISnoop                          :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%'; 
#+end_src

  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number 
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Final notes :export:
If a test with these calls gets merged, **Conformance coverage will go up by 2 points**

-----  
/sig testing
 
/sig architecture  

/area conformance  

* Open Tasks
  Set any open tasks here, using org-todo
** DONE Live Your Best Life
* Footnotes                                                     :neverexport:
  :PROPERTIES:
  :CUSTOM_ID: footnotes
  :END:
