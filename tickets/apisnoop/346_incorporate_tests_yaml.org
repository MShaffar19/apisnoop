# -*- ii: apisnoop; -*-
#+TITLE: Incorporate tests.yaml

* Purpose
  My current thought is:

    use the new test/conformance/testdata/conformance.yaml to track when a test was added to conformance
    use the 1.9-1.18 release tags of swagger.json to map when the endpoints were added to stable
    use only master/current/latest release-blocking prow-job audit.log (to see what endpoints a given conformance test hits)
    not show any endpoints that are deprecated
    note endpoints that are currently considered very low priority OR not part of conformance as lighter color (or remove them completely)
    The coverage info for 1.9 bar is based on the endpoints those tests hit in the current/latest audit.log

Same for 1.10-1.18
* Strategy
- Import yaml as a sql table for postgres
- Build out view that shows when a test was added and the endpoints it hits.
- Build out view that shows endpoints per release, low-priority endpoints, new endpoints, new tests, and new coverage.
- share table of these findings
- design infographic for best display of this
- transpose data into sharable infographic
* Process
** Import yaml as a sql table for postgres
   We first need to turn yaml into json and then we can do a similar process to our load_swagger function, though this will be simpler as we are only wanting to load one file and we want whatever is latest on master.  In other words, we don't need to check for the right bucket and job.
*** Create table
    #+begin_src sql-mode
      CREATE TABLE test_info(
        testname text,
        codename text,
        release text,
        description text,
        file text
      );
    #+end_src

    #+RESULTS:
    #+begin_SRC example
    CREATE TABLE
    #+end_SRC

*** Write the Sql Function   
   #+NAME: Import tests
   #+BEGIN_SRC sql-mode
     set role dba;
     DROP FUNCTION IF EXISTS load_tests;
     CREATE OR REPLACE FUNCTION load_tests()
     RETURNS text AS $$
     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   WITH jsonb_array AS (
                   SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                   INSERT INTO test_info(testname, codename, release, description, file)
                      SELECT
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      (test_data->>'release') as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     plpy.execute(sql)
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC

      #+RESULTS: Import tests
      #+begin_SRC example
      SET
      #+end_SRC

      
      #+begin_src sql-mode
      select * from load_tests();
      #+end_src

      #+RESULTS:
      #+begin_SRC example
       load_tests 
      ------------

      (1 row)

      #+end_SRC

#+begin_src sql-mode
select file, release from test_info limit 20;
#+end_src

#+RESULTS:
#+begin_SRC example
                 file                 | release 
--------------------------------------+---------
 test/e2e/common/lifecycle_hook.go    | v1.9
 test/e2e/common/lifecycle_hook.go    | v1.9
 test/e2e/common/lifecycle_hook.go    | v1.9
 test/e2e/common/lifecycle_hook.go    | v1.9
 test/e2e/common/runtime.go           | v1.15
 test/e2e/common/runtime.go           | v1.15
 test/e2e/common/runtime.go           | v1.15
 test/e2e/common/runtime.go           | v1.15
 test/e2e/common/runtime.go           | v1.13
 test/e2e/common/docker_containers.go | v1.9
 test/e2e/common/docker_containers.go | v1.9
 test/e2e/common/docker_containers.go | v1.9
 test/e2e/common/docker_containers.go | v1.9
 test/e2e/common/init_container.go    | v1.12
 test/e2e/common/init_container.go    | v1.12
 test/e2e/common/init_container.go    | v1.12
 test/e2e/common/init_container.go    | v1.12
 test/e2e/common/kubelet.go           | v1.13
 test/e2e/common/kubelet.go           | v1.13
 test/e2e/common/kubelet.go           | v1.13
(20 rows)

#+end_SRC
*** Create sample view to combine tests with endpoints
    the test_info codename matches our useragent test string, though the useragent teststring comes with a bit of extra padding (wich we should santizine in that view as a nice TODO)
   So we can easily combine the test, its release, and the endpoints it hits like so: 
#+begin_src sql-mode
  select 
    testname,
    release,
    array_length(operation_ids, 1) as endpoints_hit
  FROM test_info
  LEFT JOIN tests ON(TRIM(test) = codename)
  limit 10;
#+end_src   

#+RESULTS:
#+begin_SRC example
                                        testname                                         | release | endpoints_hit 
-----------------------------------------------------------------------------------------+---------+---------------
 Pod Lifecycle, post start exec hook                                                     | v1.9    |            14
 Pod Lifecycle, post start http hook                                                     | v1.9    |            11
 Pod Lifecycle, prestop exec hook                                                        | v1.9    |            11
 Pod Lifecycle, prestop http hook                                                        | v1.9    |            11
 Container Runtime, TerminationMessage, from log output of succeeding container          | v1.15   |             9
 Container Runtime, TerminationMessage, from file of succeeding container                | v1.15   |             9
 Container Runtime, TerminationMessage, from container's log output of failing container | v1.15   |             9
 Container Runtime, TerminationMessagePath, non-root user and non-default path           | v1.15   |             9
 Container Runtime, Restart Policy, Pod Phases                                           | v1.13   |            12
 Docker containers, with arguments                                                       | v1.9    |            16
(10 rows)

#+end_SRC
   
** Import swaggers for releases 1.9 through 1.18
   We need to get the commit for each tagged release and then load the swagger from that commit.
   Kubernetes is helpfully consistent with its tagging, which means we can create an easy url template
   to get the swagger for 1.9 it'd be:
   : https://raw.githubusercontent.com/kubernetes/kubernetes/v1.9.0/api/openapi-spec/swagger.json
   and 1.12 would be:
   : https://raw.githubusercontent.com/kubernetes/kubernetes/v1.12.0/api/openapi-spec/swagger.json
   
   Alternatively, we could base it on each versions release branch, which is structued as so:
   : https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.9/api/openapi-spec/swagger.json
   in this case, v1.9 is up to like 1.9.4....so it's a question of what we consider "canonical" for our release dates...but the process of adding the swagger would be the same no matter what type of url we decide on.
   
   I am realizing, though, that there's a bit of a change to our main keys...we do not have a bucket or job for these releases, which means a l ot of the metadata we don't care about either.  I am unsure if I should just try to update our bucket_job_swagger table, or make a new one whose focus is on the release  and date instead of bucket and job.  
   
   None of the fields in our bjs table are required, so I can just insert with most of it null, then build out views from there...but it will be a good thing to ponder in the future.  There is a smell that this could all be redesigned to not be so heavy....we just have the latest run and then the rest is pulled from github.  
   
*** Adjust bucket_job_swagger to have a release and date column
   #+NAME: Create OPENAPI_SPEC Table 
   #+begin_src sql-mode
     ALTER TABLE bucket_job_swagger
       ADD COLUMN release text,
       ADD COLUMN release_date timestamp
       ;
   #+end_src

   #+RESULTS: Create OPENAPI_SPEC Table
   #+begin_SRC example
   ALTER TABLE
   #+end_SRC
   
   #+begin_src sql-mode
   \d+ bucket_job_swagger;
   #+end_src

   #+RESULTS:
   #+begin_SRC example
                                                                                     Table "public.bucket_job_swagger"
        Column      |            Type             | Collation | Nullable |      Default      | Storage  | Stats target |                                  Description                                   
   -----------------+-----------------------------+-----------+----------+-------------------+----------+--------------+--------------------------------------------------------------------------------
    ingested_at     | timestamp without time zone |           |          | CURRENT_TIMESTAMP | plain    |              | timestamp for when data added to table
    bucket          | text                        |           | not null |                   | extended |              | storage bucket for audit event test run and swagger
    job             | text                        |           | not null |                   | extended |              | specific job # of audit event test run
    commit_hash     | text                        |           |          |                   | extended |              | git commit hash for this particular test run
    passed          | text                        |           |          |                   | extended |              | whether test run passed
    job_result      | text                        |           |          |                   | extended |              | whether test run was successful.
    pod             | text                        |           |          |                   | extended |              | The pod this test was run on
    infra_commit    | text                        |           |          |                   | extended |              | 
    job_version     | text                        |           |          |                   | extended |              | version of k8s on which this job was run
    job_timestamp   | timestamp without time zone |           |          |                   | plain    |              | timestamp when job was run.  Will be different from ingested_at.
    node_os_image   | text                        |           |          |                   | extended |              | id for which master os image was used for test run
    master_os_image | text                        |           |          |                   | extended |              | 
    swagger         | jsonb                       |           |          |                   | extended |              | raw json of the open api spec for k8s as of the commit hash for this test run.
    release         | text                        |           |          |                   | extended |              | 
    release_date    | timestamp without time zone |           |          |                   | plain    |              | 
   Indexes:
       "bucket_job_swagger_pkey" PRIMARY KEY, btree (bucket, job)
       "idx_swagger_jsonb_ops" gin (swagger)
       "idx_swagger_jsonb_path_ops" gin (swagger jsonb_path_ops)
   Access method: heap

   #+end_SRC
*** Add Past Swaggers Function
   #+NAME: Add swagger from url 
    #+BEGIN_SRC sql-mode
     set role dba;
     DROP FUNCTION IF EXISTS load_past_swaggers;
     CREATE OR REPLACE FUNCTION load_past_swaggers(
       release text default null,
       release_date text default null
     )
       RETURNS text AS $$
       from string import Template
       import json
       from urllib.request import urlopen, urlretrieve

       K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
       OPEN_API_PATH = "/api/openapi-spec/swagger.json"

       release_url = K8S_REPO_URL + release + OPEN_API_PATH
       swagger = json.loads(urlopen(release_url).read().decode('utf-8')) # may change this to ascii

       sql = Template("""
                        INSERT INTO bucket_job_swagger(bucket, job, release, release_date, swagger)
                        SELECT
                        'release-${release}' as bucket,
                        '${release_date}' as job,
                        '${release}' as release,
                        (to_timestamp(${release_date})) as release_date,
                        '${swagger}' as swagger
                        """).substitute(release = release.replace('v',''),
                                        release_date = release_date,
                                        swagger = json.dumps(swagger).replace("'","''"))
       plpy.execute(sql)
       $$ LANGUAGE plpython3u;
       reset role;
       #+END_SRC
       
       #+begin_src sql-mode
         select * from load_past_swaggers('v1.9.0', '2017-12-15');
       #+end_src
*** Delete Auditlogger data
       To ease this a bit more, i'm going to turn off audit_logger and delete all the live stuff from our db.
       #+begin_src sql-mode
delete from  audit_event where bucket = 'apisnoop';
       #+end_src

       #+RESULTS:
       #+begin_SRC example
       DELETE 224991
       #+end_SRC
       
*** Refresh and check       
       #+begin_src sql-mode
       REFRESH MATERIALIZED VIEW api_operation_material;
       REFRESH MATERIALIZED VIEW api_operation_parameter_material;
       REFRESH MATERIALIZED VIEW endpoint_coverage_material;
       #+end_src

       #+RESULTS:
       #+begin_SRC example
       REFRESH MATERIALIZED VIEW
       #+end_SRC

      So we should now have endpoint coverage that shows many endpoints twice, once for 1.9 and once for our most recent bucket, and all 1.9 should show as 'untested'...since we have no audit_event data for them 
      
      For example: 
      #+begin_src sql-mode 
        SELECT distinct
          bucket,
          operation_id,
          tested
          FROM
              endpoint_coverage
         WHERE operation_id like '%Portforward'
         ORDER BY
           operation_id
               ;
      #+end_src

      #+RESULTS:
      #+begin_SRC example
                bucket           |               operation_id                | tested 
      ---------------------------+-------------------------------------------+--------
       ci-kubernetes-e2e-gci-gce | connectCoreV1GetNamespacedPodPortforward  | t
       past                      | connectCoreV1GetNamespacedPodPortforward  | f
       ci-kubernetes-e2e-gci-gce | connectCoreV1PostNamespacedPodPortforward | f
       past                      | connectCoreV1PostNamespacedPodPortforward | f
      (4 rows)

      #+end_SRC
      
We need latest data to see what endpoints are hit by tests, and we need test_info to know when that test was released.  From this, I think we can have a view that shows endpoint, test, and test_release, and endpoint_release.
From this view, we can create a window function that shows # of new endpoints and new tests per release.
** Build view of conformance endpoints and their release date
** Build view of stable endoints, release date, first tested date, and first tested by
** Build view of release, stable endpoint count, stable conformance tested count, new tests count
* Conclusion

# Local Variables:
# ii: enabled
# End:



