# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining StatefulSet endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind,
      "group"
      -- FROM untested_stable_core_endpoints
      FROM untested_stable_endpoints
      where path not like '%volume%'
      and kind like 'StatefulSet'
      and "group" like 'apps'
      -- and operation_id ilike '%%'
     ORDER BY kind,operation_id desc
     -- LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_src sql-mode
                 operation_id                 |    kind     | group 
 ---------------------------------------------+-------------+-------
  replaceAppsV1NamespacedStatefulSetStatus    | StatefulSet | apps
  readAppsV1NamespacedStatefulSetStatus       | StatefulSet | apps
  patchAppsV1NamespacedStatefulSetStatus      | StatefulSet | apps
  patchAppsV1NamespacedStatefulSet            | StatefulSet | apps
  listAppsV1StatefulSetForAllNamespaces       | StatefulSet | apps
  deleteAppsV1CollectionNamespacedStatefulSet | StatefulSet | apps
 (6 rows)

 #+end_src

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/statefulset.go][client-go - StatefulSet]] 

* The mock test                                                      :export:
** Test outline
1. Create a StatefulSet with a static label

2. Patch the StatefulSet with a new Label and updated data

3. Get the StatefulSet to ensure it's patched

4. Read the StatefulSet's status

5. Replace the StatefulSet's status ReadyReplicas to 0

6. Read the StatefulSet's status to check if ReadyReplicas is 0

7. List all StatefulSets in all Namespaces find the StatefulSet(1) ensure that the StatefulSet is found and is patched

8. Delete Namespaced StatefulSet(1) via a Collection with a LabelSelector

9. Get the StatefulSet to check that it's deleted

** Test the functionality in Go
   #+begin_src go
     package main

     import (
       "encoding/json"
       "fmt"
       "flag"
       "os"
       v1 "k8s.io/api/core/v1"
       appsv1 "k8s.io/api/apps/v1"
       "k8s.io/client-go/dynamic"
       "k8s.io/apimachinery/pkg/runtime/schema"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/client-go/kubernetes"
       "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
       watch "k8s.io/apimachinery/pkg/watch"
       unstructuredv1 "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
       "k8s.io/apimachinery/pkg/runtime"
     )

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
         fmt.Println(err)
         return
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)
       DynamicClientSet, _ := dynamic.NewForConfig(config)

       // TEST BEGINS HERE

       resourceGroup := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "statefulset"}
       testNamespaceName := "default"
       testStatefulSetName := "stateful-test"
       testStatefulSetImageInitial := "nginx"
       testStatefulSetImagePatch := "alpine"
       testStatefulSetImageUpdate := "httpd"
       testStatefulSetReplicasInitial := int32(1)
       testStatefulSetReplicasPatch := int32(2)
       testStatefulSetReplicasUpdate := int32(1)
       testStatefulSetLabelSelectors := metav1.LabelSelector{
         MatchLabels: map[string]string{"app": "test-statefulset"},
       }
       testStatefulSet := appsv1.StatefulSet{
         ObjectMeta: metav1.ObjectMeta{
           Name: testStatefulSetName,
           Labels: map[string]string{
             "test-statefulset-static": "true",
           },
         },
         Spec: appsv1.StatefulSetSpec{
           Selector: &testStatefulSetLabelSelectors,
           Replicas: &testStatefulSetReplicasInitial,
           Template: v1.PodTemplateSpec{
             ObjectMeta: metav1.ObjectMeta{
               Labels: testStatefulSetLabelSelectors.MatchLabels,
             },
             Spec: v1.PodSpec{
               Containers: []v1.Container{
                 {
                   Name: testStatefulSetName,
                   Image: testStatefulSetImageInitial,
                 },
               },
             },
           },
         },
       }
       fmt.Println("creating a StatefulSet")
       _, err = ClientSet.AppsV1().StatefulSets(testNamespaceName).Create(&testStatefulSet)
       if err != nil {
         fmt.Println(err, "failed to create the StatefulSet")
         return
       }

       fmt.Println("setting up a watch")
       statefulsetWatch, err := ClientSet.AppsV1().StatefulSets(testNamespaceName).Watch(metav1.ListOptions{LabelSelector: "test-statefulset-static=true"})
       if err != nil {
         fmt.Println(err)
         return
       }
       statefulsetWatchChan := statefulsetWatch.ResultChan()
       fmt.Println("watching for StatefulSet to be ready")
       for event := range statefulsetWatchChan {
         statefulsetEvent, ok := event.Object.(*appsv1.StatefulSet)
         if ok != true {
           fmt.Println("Unable to fix type")
           return
         }
         if statefulsetEvent.Status.Replicas == testStatefulSetReplicasInitial {
           break
         }
       }

       defer func() {
         fmt.Println("delete the StatefulSet via a Collection with a LabelSelector")
         err = ClientSet.AppsV1().StatefulSets(testNamespaceName).DeleteCollection(&metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: "test-statefulset-static=true"})
         if err != nil {
           fmt.Println(err)
           return
         }
         fmt.Println("watching for StatefulSet to be not Ready")
         for event := range statefulsetWatchChan {
           if event.Type == watch.Deleted {
             break
           }
         }
       }()

       fmt.Println("patching the StatefulSet with a new Label and updated data")
       statefulsetPatch, err := json.Marshal(map[string]interface{}{
         "metadata": map[string]interface{}{
           "labels": map[string]string{
             "test-resource": "patched",
           },
         },
         "spec": map[string]interface{}{
           "template": map[string]interface{}{
             "spec": map[string]interface{}{
               "containers": []map[string]interface{}{
                 {
                   "name": testStatefulSetName,
                   "image": testStatefulSetImagePatch,
                 },
               },
             },
           },
         },
       })
       if err != nil {
         fmt.Println(err, "failed to marshal StatefulSet Patch")
         return
       }
       fmt.Println("patching the StatefulSet")
       _, err = ClientSet.AppsV1().StatefulSets(testNamespaceName).Patch(testStatefulSetName, types.StrategicMergePatchType, []byte(statefulsetPatch), "status")
       if err != nil {
         fmt.Println(err, "failed to patch the StatefulSet")
         return
       }
       fmt.Println("fetching the StatefulSet and ensure it's patched")
       statefulset, err := ClientSet.AppsV1().StatefulSets(testNamespaceName).Get(testStatefulSetName, metav1.GetOptions{})
       if err != nil {
         fmt.Println(err, "failed to fetch the StatefulSet")
         return
       }
       if statefulset.ObjectMeta.Labels["test-statefulset-static"] != "true" || statefulset.Spec.Template.Spec.Containers[0].Image != testStatefulSetImage2 {
         fmt.Println("patching of StatefulSet failed")
         return
       }
       fmt.Println("fetching the StatefulSet status")
       statefulsetStatusUnstructured, err := DynamicClientSet.Resource(resourceGroup).Namespace(testNamespaceName).Get(testStatefulSetName, metav1.GetOptions{}, "status")
       if err != nil {
         fmt.Println(err)
         return
       }
       statefulSetFetch := appsv1.StatefulSet{}
       err = runtime.DefaultUnstructuredConverter.FromUnstructured(deploymentGetUnstructured.Object, &statefulSetFetch)
       if err != nil {
           fmt.Println(err, "failed to convert the unstructured response to a StatefulSet")
           return
       }

       // replace the StatefulSet's status Ready condition to False
       statefulsetStatusUpdated := statefulsetStatus
       statefulsetStatusUpdated.Spec.Template.Spec.Containers[0].Image = testStatefulSetImageUpdate
       _, err = ClientSet.AppsV1().StatefulSets(testNamespaceName).UpdateStatus(&statefulsetStatusUpdated)
       if err != nil {
         fmt.Println(err)
         return
       }
       fmt.Println("updated StatefulSetStatus")
       // list all StatefulSets and get their status to ensure it's Ready condition is False
       statefulsetsList, err := ClientSet.AppsV1().StatefulSets("").List(metav1.ListOptions{LabelSelector: "test-statefulset-static=true"})
       if err != nil {
         fmt.Println(err)
         return
       }
       for _, statefulset := range statefulsetsList {
         if statefulset.Spec.Template.Spec.Container[0].Image != testStatefulSetImageUpdate {
           fmt.Println("StatefulSet container image doesn't match updated value")
           return
         }
       }

       // TEST ENDS HERE

       // write test here
       fmt.Println("[status] complete")

     }
   #+end_src

   #+RESULTS:
   #+begin_src go
   created StatefulSet
   watching for StatefulSet to be ready
   StatefulSet is Ready
   the server could not find the requested resource
   delete the StatefulSet via a Collection with a LabelSelector
   watching for StatefulSet to be not Ready
   #+end_src

* Verifying increase it coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%'; 
#+end_src

#+RESULTS:
#+begin_src sql-mode
 useragent | operation_id | hit_by_ete | hit_by_new_test 
-----------+--------------+------------+-----------------
(0 rows)

#+end_src

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number 
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Final notes :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----  
/sig testing  

/sig architecture  

/area conformance  

* Options :neverexport:
** Delete all events after postgres initialization
   #+begin_src sql-mode :eval never-export :exports both :session none
   delete from audit_event where bucket = 'apisnoop' and job='live';
   #+end_src

   #+RESULTS:
   #+begin_src sql-mode
   DELETE 1577
   #+end_src

* Open Tasks
  Set any open tasks here, using org-todo
** DONE Live Your Best Life
* Footnotes                                                     :neverexport:
  :PROPERTIES:
  :CUSTOM_ID: footnotes
  :END:
