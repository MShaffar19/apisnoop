# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [2/5]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [X] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM untested_stable_core_endpoints
      -- FROM untested_stable_endpoints
      where path not like '%volume%'
      -- and kind like ''
      -- and operation_id ilike '%%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_SRC example
                 operation_id                |      kind
 --------------------------------------------+-----------------
  createCoreV1NamespacedPodBinding           | Binding
  createCoreV1NamespacedBinding              | Binding
  readCoreV1ComponentStatus                  | ComponentStatus
  listCoreV1ComponentStatus                  | ComponentStatus
  replaceCoreV1NamespacedEndpoints           | Endpoints
  patchCoreV1NamespacedEndpoints             | Endpoints
  listCoreV1EndpointsForAllNamespaces        | Endpoints
  deleteCoreV1CollectionNamespacedEndpoints  | Endpoints
  replaceCoreV1NamespacedEvent               | Event
  readCoreV1NamespacedEvent                  | Event
  patchCoreV1NamespacedEvent                 | Event
  listCoreV1NamespacedEvent                  | Event
  listCoreV1EventForAllNamespaces            | Event
  deleteCoreV1NamespacedEvent                | Event
  deleteCoreV1CollectionNamespacedEvent      | Event
  createCoreV1NamespacedEvent                | Event
  patchCoreV1NamespacedLimitRange            | LimitRange
  listCoreV1LimitRangeForAllNamespaces       | LimitRange
  deleteCoreV1CollectionNamespacedLimitRange | LimitRange
  replaceCoreV1NamespaceStatus               | Namespace
  replaceCoreV1NamespaceFinalize             | Namespace
  readCoreV1NamespaceStatus                  | Namespace
  patchCoreV1NamespaceStatus                 | Namespace
  patchCoreV1Namespace                       | Namespace
  listCoreV1Namespace                        | Namespace
 (25 rows)

 #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1. Create a RESOURCENAME with a static label

2. Patch the RESOURCENAME with a new label and updated data

3. Get the RESOURCENAME to ensure it's patched

4. List all RESOURCENAMEs in all Namespaces with a static label
   find the RESOURCENAME
   ensure that the RESOURCENAME is found and is patched

5. Delete Namespaced RESOURCENAME via a Collection with a LabelSelector

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
            package main

            import (
              // "encoding/json"
              "fmt"
              "context"
              "flag"
              "os"
              "context"
              v1 "k8s.io/api/core/v1"
              // "k8s.io/client-go/dynamic"
              // "k8s.io/apimachinery/pkg/runtime/schema"
              metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
              "k8s.io/client-go/kubernetes"
              // "k8s.io/apimachinery/pkg/types"
              "k8s.io/client-go/tools/clientcmd"
            )

            func main() {
              // uses the current context in kubeconfig
              kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
              flag.Parse()
              config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
              if err != nil {
                  fmt.Println(err, "Could not build config from flags")
                  return
              }
              // make our work easier to find in the audit_event queries
              config.UserAgent = "live-test-writing"
              // creates the clientset
              ClientSet, _ := kubernetes.NewForConfig(config)
              // DynamicClientSet, _ := dynamic.NewForConfig(config)
              // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

              // TEST BEGINS HERE
       /*
       Copyright The Kubernetes Authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
       ,*/

       // Code generated by client-gen. DO NOT EDIT.



       // ServiceAccountsGetter has a method to return a ServiceAccountInterface.
       // A group's client should implement this interface.
       type ServiceAccountsGetter interface {
         ServiceAccounts(namespace string) ServiceAccountInterface
       }

       // ServiceAccountInterface has methods to work with ServiceAccount resources.
       type ServiceAccountInterface interface {
         Create(ctx context.Context, serviceAccount *v1.ServiceAccount, opts metav1.CreateOptions) (*v1.ServiceAccount, error)
         Update(ctx context.Context, serviceAccount *v1.ServiceAccount, opts metav1.UpdateOptions) (*v1.ServiceAccount, error)
         Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
         DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error
         Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.ServiceAccount, error)
         List(ctx context.Context, opts metav1.ListOptions) (*v1.ServiceAccountList, error)
         Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
         Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.ServiceAccount, err error)
         CreateToken(ctx context.Context, serviceAccountName string, tokenRequest *authenticationv1.TokenRequest, opts metav1.CreateOptions) (*authenticationv1.TokenRequest, error)

         ServiceAccountExpansion
       }

       // serviceAccounts implements ServiceAccountInterface
       type serviceAccounts struct {
         client rest.Interface
         ns     string
       }

       // newServiceAccounts returns a ServiceAccounts
       func newServiceAccounts(c *CoreV1Client, namespace string) *serviceAccounts {
         return &serviceAccounts{
           client: c.RESTClient(),
           ns:     namespace,
         }
       }

       // Get takes name of the serviceAccount, and returns the corresponding serviceAccount object, and an error if there is any.
       func (c *serviceAccounts) Get(ctx context.Context, name string, options metav1.GetOptions) (result *v1.ServiceAccount, err error) {
         result = &v1.ServiceAccount{}
         err = c.client.Get().
           Namespace(c.ns).
           Resource("serviceaccounts").
           Name(name).
           VersionedParams(&options, scheme.ParameterCodec).
           Do(ctx).
           Into(result)
         return
       }

       // List takes label and field selectors, and returns the list of ServiceAccounts that match those selectors.
       func (c *serviceAccounts) List(ctx context.Context, opts metav1.ListOptions) (result *v1.ServiceAccountList, err error) {
         var timeout time.Duration
         if opts.TimeoutSeconds != nil {
           timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
         }
         result = &v1.ServiceAccountList{}
         err = c.client.Get().
           Namespace(c.ns).
           Resource("serviceaccounts").
           VersionedParams(&opts, scheme.ParameterCodec).
           Timeout(timeout).
           Do(ctx).
           Into(result)
         return
       }

       // Watch returns a watch.Interface that watches the requested serviceAccounts.
       func (c *serviceAccounts) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
         var timeout time.Duration
         if opts.TimeoutSeconds != nil {
           timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
         }
         opts.Watch = true
         return c.client.Get().
           Namespace(c.ns).
           Resource("serviceaccounts").
           VersionedParams(&opts, scheme.ParameterCodec).
           Timeout(timeout).
           Watch(ctx)
       }

       // Create takes the representation of a serviceAccount and creates it.  Returns the server's representation of the serviceAccount, and an error, if there is any.
       func (c *serviceAccounts) Create(ctx context.Context, serviceAccount *v1.ServiceAccount, opts metav1.CreateOptions) (result *v1.ServiceAccount, err error) {
         result = &v1.ServiceAccount{}
         err = c.client.Post().
           Namespace(c.ns).
           Resource("serviceaccounts").
           VersionedParams(&opts, scheme.ParameterCodec).
           Body(serviceAccount).
           Do(ctx).
           Into(result)
         return
       }

       // Update takes the representation of a serviceAccount and updates it. Returns the server's representation of the serviceAccount, and an error, if there is any.
       func (c *serviceAccounts) Update(ctx context.Context, serviceAccount *v1.ServiceAccount, opts metav1.UpdateOptions) (result *v1.ServiceAccount, err error) {
         result = &v1.ServiceAccount{}
         err = c.client.Put().
           Namespace(c.ns).
           Resource("serviceaccounts").
           Name(serviceAccount.Name).
           VersionedParams(&opts, scheme.ParameterCodec).
           Body(serviceAccount).
           Do(ctx).
           Into(result)
         return
       }

       // Delete takes name of the serviceAccount and deletes it. Returns an error if one occurs.
       func (c *serviceAccounts) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
         return c.client.Delete().
           Namespace(c.ns).
           Resource("serviceaccounts").
           Name(name).
           Body(&opts).
           Do(ctx).
           Error()
       }

       // DeleteCollection deletes a collection of objects.
       func (c *serviceAccounts) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
         var timeout time.Duration
         if listOpts.TimeoutSeconds != nil {
           timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
         }
         return c.client.Delete().
           Namespace(c.ns).
           Resource("serviceaccounts").
           VersionedParams(&listOpts, scheme.ParameterCodec).
           Timeout(timeout).
           Body(&opts).
           Do(ctx).
           Error()
       }

       // Patch applies the patch and returns the patched serviceAccount.
       func (c *serviceAccounts) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.ServiceAccount, err error) {
         result = &v1.ServiceAccount{}
         err = c.client.Patch(pt).
           Namespace(c.ns).
           Resource("serviceaccounts").
           Name(name).
           SubResource(subresources...).
           VersionedParams(&opts, scheme.ParameterCodec).
           Body(data).
           Do(ctx).
           Into(result)
         return
       }

       // CreateToken takes the representation of a tokenRequest and creates it.  Returns the server's representation of the tokenRequest, and an error, if there is any.
       func (c *serviceAccounts) CreateToken(ctx context.Context, serviceAccountName string, tokenRequest *authenticationv1.TokenRequest, opts metav1.CreateOptions) (result *authenticationv1.TokenRequest, err error) {
         result = &authenticationv1.TokenRequest{}
         err = c.client.Post().
           Namespace(c.ns).
           Resource("serviceaccounts").
           Name(serviceAccountName).
           SubResource("token").
           VersionedParams(&opts, scheme.ParameterCodec).
           Body(tokenRequest).
           Do(ctx).
           Into(result)
         return
       }



              // TEST ENDS HERE

              fmt.Println("[status] complete")

            }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   #+end_src



* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance
