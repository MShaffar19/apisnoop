# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [2/5]                                                :export:
- [ ] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [ ] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
       path,
      -- description,
      kind
     -- FROM untested_stable_core_endpoints
       FROM untested_stable_endpoints
      where path not like '%volume%'
      -- and kind like ''
       and operation_id ilike '%APIGroup%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
            operation_id           |                path                 | kind 
  ---------------------------------+-------------------------------------+------
   getStorageAPIGroup              | /apis/storage.k8s.io/               | 
   getSettingsAPIGroup             | /apis/settings.k8s.io/              | 
   getSchedulingAPIGroup           | /apis/scheduling.k8s.io/            | 
   getRbacAuthorizationAPIGroup    | /apis/rbac.authorization.k8s.io/    | 
   getPolicyAPIGroup               | /apis/policy/                       | 
   getNodeAPIGroup                 | /apis/node.k8s.io/                  | 
   getNetworkingAPIGroup           | /apis/networking.k8s.io/            | 
   getFlowcontrolApiserverAPIGroup | /apis/flowcontrol.apiserver.k8s.io/ | 
   getExtensionsAPIGroup           | /apis/extensions/                   | 
   getEventsAPIGroup               | /apis/events.k8s.io/                | 
   getDiscoveryAPIGroup            | /apis/discovery.k8s.io/             | 
   getCoordinationAPIGroup         | /apis/coordination.k8s.io/          | 
   getBatchAPIGroup                | /apis/batch/                        | 
   getAutoscalingAPIGroup          | /apis/autoscaling/                  | 
   getAuthorizationAPIGroup        | /apis/authorization.k8s.io/         | 
   getAuthenticationAPIGroup       | /apis/authentication.k8s.io/        | 
   getAppsAPIGroup                 | /apis/apps/                         | 
   getApiregistrationAPIGroup      | /apis/apiregistration.k8s.io/       | 
  (18 rows)

  #+end_SRC


* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1.

2. 

3. 

4. 

5. 

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
                              package main 

                              import (
                                // "encoding/json"
                                "fmt"
                                "context"
                                "flag"
                                "os"
                                //v1 "k8s.io/api/core/v1"
                                // "k8s.io/client-go/dynamic"
                                // "k8s.io/apimachinery/pkg/runtime/schema"
                                metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
                                   "k8s.io/client-go/kubernetes"
                                // "k8s.io/apimachinery/pkg/types"
                                "k8s.io/client-go/tools/clientcmd"
                                  "k8s.io/apiextensions-apiserver/test/integration/fixtures"      
                                 "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
                                v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"      
                    )

                              func main() {
                                // uses the current context in kubeconfig
                                kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
                                flag.Parse()
                                config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
                                if err != nil {
                                    fmt.Println(err, "Could not build config from flags")
                                    return
                                }
                                // make our work easier to find in the audit_event queries
                                config.UserAgent = "live-test-writing"
                                // creates the clientset
                                  ClientSet, _ := kubernetes.NewForConfig(config)
                                // DynamicClientSet, _ := dynamic.NewForConfig(config)
                                // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

                                // TEST BEGINS HERE
             //L58-72

          //config, err := framework.LoadConfig()

            // framework.ExpectNoError(err, "loading config")*
            //                    if err != nil {
             //                   fmt.Println("loading config", err)
              //                    return
                //                   }

          apiExtensionClient, err := clientset.NewForConfig(config)


                //	framework.ExpectNoError(err, "initializing apiExtensionClient")*
                                if err != nil {
                                  fmt.Println("initializing apiExtensionClient", err)
                                  return
                                   }

              randomDefinition := fixtures.NewRandomNameV1CustomResourceDefinition(v1.ClusterScoped)

              // Create CRD and waits for the resource to be recognized and available.
              randomDefinition, err = fixtures.CreateNewV1CustomResourceDefinitionWatchUnsafe(randomDefinition, apiExtensionClient)

               //	framework.ExpectNoError(err, "creating CustomResourceDefinition")*
                                if err != nil {
                                fmt.Println("creating CustomResourceDefinition", err)
                                  return
                                   }

              defer func() {
                err = fixtures.DeleteV1CustomResourceDefinition(randomDefinition, apiExtensionClient)

               //	framework.ExpectNoError(err, "deleting CustomResourceDefinition")
                                if err != nil {
                                fmt.Println("deleting CustomResourceDefinition", err)
                                  return
                                   }
              }()

                  //L196-201
                                fmt.Println("fetching the /apis discovery document")
                                apiGroupList := &metav1.APIGroupList{}
                                err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis").Do(context.TODO()).Into(apiGroupList)

                                //framework.ExpectNoError(err, "fetching /apis")
                                if err != nil {
                                  fmt.Println("fetching /apis", err)
                                  return
                                }

                  //L203-211
                                // ginkgo.By("finding the apiextensions.k8s.io API group in the /apis discovery document")
                                fmt.Println("finding the apiextensions.k8s.io API group in the /apis discovery document")
                                var group *metav1.APIGroup
                                for _, g := range apiGroupList.Groups {
                                fmt.Println("...",g.Name)
                                if g.Name == v1.GroupName {
                                    group = &g
                                fmt.Println("CONNECTION...",v1.GroupName)
				                         fmt.Printf("group: %T\n",group)
				                         fmt.Printf("group: %+v\n",group)
				                         fmt.Printf("g: %+v\n",g)
                                    break
                                  } 
                                }

                                // framework.ExpectNotEqual(group, nil, "apiextensions.k8s.io API group not found in /apis discovery document")

                                if group != nil {
                                  fmt.Println("apiextensions.k8s.io API group not found in /apis discovery document", err)
                                  return
                                }


     os.Exit(0)
                  //L213-222 Same as block 231 


                               //ginkgo.By("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                                fmt.Println("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                                 var version *metav1.GroupVersionForDiscovery
                                 for _, v := range group.Versions {
                                 if v.Version == v1.SchemeGroupVersion.Version {
                                  version = &v
                                  break
                                }
                              }

                              // framework.ExpectNotEqual(version, nil, "apiextensions.k8s.io/v1 API group version not found in /apis discovery document")

                               if version != nil {
                                  fmt.Println("apiextensions.k8s.io/v1 API group version not found in /apis discovery document", err)
                                  return
                                }




                  //L225-229
                               //ginkgo.By("fetching the /apis/apiextensions.k8s.io discovery document")
                               fmt.Println("fetching the /apis/apiextensions.k8s.io discovery document")
                               group = &metav1.APIGroup{}
                               err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis/apiextensions.k8s.io").Do(context.TODO()).Into(group)

                               //framework.ExpectNoError(err, "fetching /apis/apiextensions.k8s.io")

                                if err != nil {
                                   fmt.Println("fetching /apis/apiextensions.k8s.io", err)
                                  return
                                 }


                               //framework.ExpectEqual(group.Name, v1.GroupName, "verifying API group name in /apis/apiextensions.k8s.io discovery document")

                                if group.Name != v1.GroupName  {
                                  fmt.Println("verifying API Group name in /apis/apiextensions.k8s.io discovery document", err)
                                  return
                                 }

                  //L231-240 Same as block 213


                               //ginkgo.By("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                                fmt.Println("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                                // var version *metav1.GroupVersionForDiscovery
                                 for _, v := range group.Versions {
                                 if v.Version == v1.SchemeGroupVersion.Version {
                                  version = &v
                                  break
                                }
                              }

                              // framework.ExpectNotEqual(version, nil, "apiextensions.k8s.io/v1 API group version not found in /apis discovery document")

                               if version != nil {
                                  fmt.Println("apiextensions.k8s.io/v1 API group version not found in /apis discovery document", err)
                                  return
                                }




                  //243-247
                        //ginkgo.By("fetching the /apis/apiextensions.k8s.io/v1 discovery document")
                           fmt.Println("fetching the /apis/apiextensions.k8s.io/v1 discovery document")
                           apiResourceList := &metav1.APIResourceList{}
                           err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis/apiextensions.k8s.io/v1").Do(context.TODO()).Into(apiResourceList)

                           //framework.ExpectNoError(err, "fetching /apis/apiextensions.k8s.io/v1")

                                if err != nil {
                                  fmt.Println("fetching /apis/apiextensions.k8s.io/v1", err)
                                  return
                                 }

                           //framework.ExpectEqual(apiResourceList.GroupVersion, v1.SchemeGroupVersion.String(), "verifying API group/version in /apis/apiextensions.k8s.io/v1 discovery document")

                                if err != nil {
                                  fmt.Println("verifying API group/version in /apis/apiextensions.k8s.io discovery document", err)
                                  return
                                 }


                  //L249-258
                          // ginkgo.By("finding customresourcedefinitions resources in the /apis/apiextensions.k8s.io/v1 discovery document")
                           fmt.Println("finding customresourcedefinitions resources in the /apis/apiextensions.k8s.io/v1 discovery document")
                            var crdResource *metav1.APIResource
                           for i := range apiResourceList.APIResources {
                             if apiResourceList.APIResources[i].Name == "customresourcedefinitions" {
                               crdResource = &apiResourceList.APIResources[i]
                             }
                           }

                           //framework.ExpectNotEqual(crdResource, nil, "customresourcedefinitions resource not found in /apis/apiextensions.k8s.io/v1 discovery document")

                                if crdResource != nil {
                    fmt.Println("customresourcedefinitions resource not found in  /apis/apiextensions.k8s.io discovery document", err)
                                  return
                                 }


                    // TEST ENDS HERE

                          fmt.Println("[status] complete")
                      }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   fetching the /apis discovery document
   finding the apiextensions.k8s.io API group in the /apis discovery document
   ... apiregistration.k8s.io
   ... extensions
   ... apps
   ... events.k8s.io
   ... authentication.k8s.io
   ... authorization.k8s.io
   ... autoscaling
   ... batch
   ... certificates.k8s.io
   ... networking.k8s.io
   ... policy
   ... rbac.authorization.k8s.io
   ... storage.k8s.io
   ... admissionregistration.k8s.io
   ... apiextensions.k8s.io
   CONNECTION... apiextensions.k8s.io
   group: *v1.APIGroup
   group: &APIGroup{Name:apiextensions.k8s.io,Versions:[]GroupVersionForDiscovery{GroupVersionForDiscovery{GroupVersion:apiextensions.k8s.io/v1,Version:v1,},GroupVersionForDiscovery{GroupVersion:apiextensions.k8s.io/v1beta1,Version:v1beta1,},},PreferredVersion:GroupVersionForDiscovery{GroupVersion:apiextensions.k8s.io/v1,Version:v1,},ServerAddressByClientCIDRs:[]ServerAddressByClientCIDR{},}
   g: {TypeMeta:{Kind: APIVersion:} Name:apiextensions.k8s.io Versions:[{GroupVersion:apiextensions.k8s.io/v1 Version:v1} {GroupVersion:apiextensions.k8s.io/v1beta1 Version:v1beta1}] PreferredVersion:{GroupVersion:apiextensions.k8s.io/v1 Version:v1} ServerAddressByClientCIDRs:[]}
   apiextensions.k8s.io API group not found in /apis discovery document <nil>
   #+end_src

 




* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance



