# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [2/5]                                                :export:
- [ ] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [ ] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM untested_stable_core_endpoints
      -- FROM untested_stable_endpoints
      where path not like '%volume%'
      -- and kind like ''
      -- and operation_id ilike '%%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_SRC example
                 operation_id                |      kind
 --------------------------------------------+-----------------
  createCoreV1NamespacedPodBinding           | Binding
  createCoreV1NamespacedBinding              | Binding
  readCoreV1ComponentStatus                  | ComponentStatus
  listCoreV1ComponentStatus                  | ComponentStatus
  replaceCoreV1NamespacedEndpoints           | Endpoints
  patchCoreV1NamespacedEndpoints             | Endpoints
  listCoreV1EndpointsForAllNamespaces        | Endpoints
  deleteCoreV1CollectionNamespacedEndpoints  | Endpoints
  replaceCoreV1NamespacedEvent               | Event
  readCoreV1NamespacedEvent                  | Event
  patchCoreV1NamespacedEvent                 | Event
  listCoreV1NamespacedEvent                  | Event
  listCoreV1EventForAllNamespaces            | Event
  deleteCoreV1NamespacedEvent                | Event
  deleteCoreV1CollectionNamespacedEvent      | Event
  createCoreV1NamespacedEvent                | Event
  patchCoreV1NamespacedLimitRange            | LimitRange
  listCoreV1LimitRangeForAllNamespaces       | LimitRange
  deleteCoreV1CollectionNamespacedLimitRange | LimitRange
  replaceCoreV1NamespaceStatus               | Namespace
  replaceCoreV1NamespaceFinalize             | Namespace
  readCoreV1NamespaceStatus                  | Namespace
  patchCoreV1NamespaceStatus                 | Namespace
  patchCoreV1Namespace                       | Namespace
  listCoreV1Namespace                        | Namespace
 (25 rows)

 #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1.

2. 

3. 

4. 

5. 

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
                 package main 

                 import (
                   // "encoding/json"
                   "fmt"
                   "context"
                   "flag"
                   "os"
                   v1 "k8s.io/api/core/v1"
                   // "k8s.io/client-go/dynamic"
                   // "k8s.io/apimachinery/pkg/runtime/schema"
                   metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
                   "k8s.io/client-go/kubernetes"
                   // "k8s.io/apimachinery/pkg/types"
                   "k8s.io/client-go/tools/clientcmd"
                 )

                 func main() {
                   // uses the current context in kubeconfig
                   kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
                   flag.Parse()
                   config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
                   if err != nil {
                       fmt.Println(err, "Could not build config from flags")
                       return
                   }
                   // make our work easier to find in the audit_event queries
                   config.UserAgent = "live-test-writing"
                   // creates the clientset
                   ClientSet, _ := kubernetes.NewForConfig(config)
                   // DynamicClientSet, _ := dynamic.NewForConfig(config)
                   // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

                   // TEST BEGINS HERE


     //L196-201
                   fmt.Println("fetching the /apis discovery document")
                   apiGroupList := &metav1.APIGroupList{}
                   err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis").Do(context.TODO()).Into(apiGroupList)

                   //framework.ExpectNoError(err, "fetching /apis")
                   if err != nil {
                     fmt.Println("fetching /apis", err)
                     return
                   }

     //L203-211
                   // ginkgo.By("finding the apiextensions.k8s.io API group in the /apis discovery document")
                   fmt.Println("finding the apiextensions.k8s.io API group in the /apis discovery document")
                   var group *metav1.APIGroup
                   for _, g := range apiGroupList.Groups {
                     if g.Name == v1.GroupName {
                       group = &g
                       break
                     }
                   }

                   // framework.ExpectNotEqual(group, nil, "apiextensions.k8s.io API group not found in /apis discovery document")

                   if group != nil {
                     fmt.Println("apiextensions.k8s.io API group not found in /apis discovery document", err)
                     return
                   }


     //L213-222 Same as block 231 


                  //ginkgo.By("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                   fmt.Println("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                    var version *metav1.GroupVersionForDiscovery
                    for _, v := range group.Versions {
                    if v.Version == v1.SchemeGroupVersion.Version {
                     version = &v
                     break
                   }
                 }

                 // framework.ExpectNotEqual(version, nil, "apiextensions.k8s.io/v1 API group version not found in /apis discovery document")

                  if version != nil {
                     fmt.Println("apiextensions.k8s.io/v1 API group version not found in /apis discovery document", err)
                     return
                   }




     //L225-229
                  //ginkgo.By("fetching the /apis/apiextensions.k8s.io discovery document")
                  fmt.Println("fetching the /apis/apiextensions.k8s.io discovery document")
                  group = &metav1.APIGroup{}
                  err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis/apiextensions.k8s.io").Do(context.TODO()).Into(group)

                  //framework.ExpectNoError(err, "fetching /apis/apiextensions.k8s.io")

                   if err != nil {
                      fmt.Println("fetching /apis/apiextensions.k8s.io", err)
                     return
                    }


                  //framework.ExpectEqual(group.Name, v1.GroupName, "verifying API group name in /apis/apiextensions.k8s.io discovery document")

                   if group.Name != v1.GroupName  {
                     fmt.Println("verifying API Group name in /apis/apiextensions.k8s.io discovery document", err)
                     return
                    }

     //L231-240 Same as block 213


                  //ginkgo.By("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                   fmt.Println("finding the apiextensions.k8s.io/v1 API group/version in the /apis discovery document")
                   // var version *metav1.GroupVersionForDiscovery
                    for _, v := range group.Versions {
                    if v.Version == v1.SchemeGroupVersion.Version {
                     version = &v
                     break
                   }
                 }

                 // framework.ExpectNotEqual(version, nil, "apiextensions.k8s.io/v1 API group version not found in /apis discovery document")

                  if version != nil {
                     fmt.Println("apiextensions.k8s.io/v1 API group version not found in /apis discovery document", err)
                     return
                   }




     //243-247
           //ginkgo.By("fetching the /apis/apiextensions.k8s.io/v1 discovery document")
              fmt.Println("fetching the /apis/apiextensions.k8s.io/v1 discovery document")
              apiResourceList := &metav1.APIResourceList{}
              err = ClientSet.Discovery().RESTClient().Get().AbsPath("/apis/apiextensions.k8s.io/v1").Do(context.TODO()).Into(apiResourceList)

              //framework.ExpectNoError(err, "fetching /apis/apiextensions.k8s.io/v1")

                   if err != nil {
                     fmt.Println("fetching /apis/apiextensions.k8s.io/v1", err)
                     return
                    }

              //framework.ExpectEqual(apiResourceList.GroupVersion, v1.SchemeGroupVersion.String(), "verifying API group/version in /apis/apiextensions.k8s.io/v1 discovery document")

                   if err != nil {
                     fmt.Println("verifying API group/version in /apis/apiextensions.k8s.io discovery document", err)
                     return
                    }


     //L249-258
             // ginkgo.By("finding customresourcedefinitions resources in the /apis/apiextensions.k8s.io/v1 discovery document")
              fmt.Println("finding customresourcedefinitions resources in the /apis/apiextensions.k8s.io/v1 discovery document")
               var crdResource *metav1.APIResource
              for i := range apiResourceList.APIResources {
                if apiResourceList.APIResources[i].Name == "customresourcedefinitions" {
                  crdResource = &apiResourceList.APIResources[i]
                }
              }

              //framework.ExpectNotEqual(crdResource, nil, "customresourcedefinitions resource not found in /apis/apiextensions.k8s.io/v1 discovery document")

                   if crdResource != nil {
       fmt.Println("customresourcedefinitions resource not found in  /apis/apiextensions.k8s.io discovery document", err)
                     return
                    }


       // TEST ENDS HERE

             fmt.Println("[status] complete")
         }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   #+end_src

 




* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance
