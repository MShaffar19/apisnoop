# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [2/5]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [X] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM untested_stable_core_endpoints
      -- FROM untested_stable_endpoints
      where path not like '%volume%'
      -- and kind like ''
      -- and operation_id ilike '%%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_SRC example
                 operation_id                |      kind
 --------------------------------------------+-----------------
  createCoreV1NamespacedPodBinding           | Binding
  createCoreV1NamespacedBinding              | Binding
  readCoreV1ComponentStatus                  | ComponentStatus
  listCoreV1ComponentStatus                  | ComponentStatus
  replaceCoreV1NamespacedEndpoints           | Endpoints
  patchCoreV1NamespacedEndpoints             | Endpoints
  listCoreV1EndpointsForAllNamespaces        | Endpoints
  deleteCoreV1CollectionNamespacedEndpoints  | Endpoints
  replaceCoreV1NamespacedEvent               | Event
  readCoreV1NamespacedEvent                  | Event
  patchCoreV1NamespacedEvent                 | Event
  listCoreV1NamespacedEvent                  | Event
  listCoreV1EventForAllNamespaces            | Event
  deleteCoreV1NamespacedEvent                | Event
  deleteCoreV1CollectionNamespacedEvent      | Event
  createCoreV1NamespacedEvent                | Event
  patchCoreV1NamespacedLimitRange            | LimitRange
  listCoreV1LimitRangeForAllNamespaces       | LimitRange
  deleteCoreV1CollectionNamespacedLimitRange | LimitRange
  replaceCoreV1NamespaceStatus               | Namespace
  replaceCoreV1NamespaceFinalize             | Namespace
  readCoreV1NamespaceStatus                  | Namespace
  patchCoreV1NamespaceStatus                 | Namespace
  patchCoreV1Namespace                       | Namespace
  listCoreV1Namespace                        | Namespace
 (25 rows)

 #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1. Create a RESOURCENAME with a static label

2. Patch the RESOURCENAME with a new label and updated data

3. Get the RESOURCENAME to ensure it's patched

4. List all RESOURCENAMEs in all Namespaces with a static label
   find the RESOURCENAME
   ensure that the RESOURCENAME is found and is patched

5. Delete Namespaced RESOURCENAME via a Collection with a LabelSelector

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
                             package main

                             import (
                               "encoding/json"
                               "fmt"
                               "context"
                               "flag"
                               "os"
                               v1 "k8s.io/api/core/v1"
                               "k8s.io/client-go/dynamic"
                               "k8s.io/apimachinery/pkg/runtime/schema"
                               metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
                               "k8s.io/client-go/kubernetes"
                               "k8s.io/apimachinery/pkg/types"
                               "k8s.io/client-go/tools/clientcmd"
                               "k8s.io/apimachinery/pkg/util/intstr"
                               watch "k8s.io/apimachinery/pkg/watch"
                             )

                             func main() {
                               // uses the current context in kubeconfig
                               kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
                               flag.Parse()
                               config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
                               if err != nil {
                                   fmt.Println(err, "Could not build config from flags")
                                   return
                               }
                               // make our work easier to find in the audit_event queries
                               config.UserAgent = "live-test-writing"
                               // creates the clientset
                               ClientSet, _ := kubernetes.NewForConfig(config)
                               DynamicClientSet, _ := dynamic.NewForConfig(config)
                               svcResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "services"}

                               // TEST BEGINS HERE

                               testServiceName := "test-service"
                               testNamespaceName := "default"

                               fmt.Println("creating a Service")
                               testService := v1.Service{
                                 ObjectMeta: metav1.ObjectMeta{
                                   Name: testServiceName,
                                   Labels: map[string]string{"test-service-static": "true"},
                                 },
                                 Spec: v1.ServiceSpec{
                                     Type: "ClusterIP",
                                     Ports: []v1.ServicePort{{
                                          Name: "http",
                                          Protocol: v1.ProtocolTCP,
                                          Port: int32(80),
                                          TargetPort: intstr.FromInt(80),
                                   }},
                                 },
                               }
                               _, err = ClientSet.CoreV1().Services(testNamespaceName).Create(context.TODO(), &testService, metav1.CreateOptions{})
                               if err != nil {
                                   fmt.Println(err, "failed to create Service")
                                   return
                               }

                               fmt.Println("watching for the Service to be added")
                               svcWatchTimeoutSeconds := int64(180)
                               svcWatch, err := ClientSet.CoreV1().Services(testNamespaceName).Watch(context.TODO(), metav1.ListOptions{LabelSelector: "test-service-static=true", TimeoutSeconds: &svcWatchTimeoutSeconds})
                               if err != nil {
                                   fmt.Println(err, "failed to create service")
                                   return
                               }

                      svcWatchChan := svcWatch.ResultChan()

                     for event := range svcWatchChan {
                         if event.Type == watch.Added {
                              break
                         }
                     }

           // fmt.Println(testService)
            fmt.Println("patching the ServiceStatus")
            serviceStatusPatch, err := json.Marshal(map[string]interface{}{
                "metadata": map[string]interface{}{
                    "labels": map[string]string{"test-service": "patched"},
                },
                 "spec": map[string]interface{}{
                     "ports": []map[string]interface{}{{
                         "name": "http8080",
                         "port": int32(8080),
                         "targetPort": int(8080),
                     "selector": []map[string]interface{}{{
                     "type": "LoadBalancer",
                    }},
               }},
                },
            })
            if err != nil {
                fmt.Println(err)
                return
            }
           svcStatus, err := DynamicClientSet.Resource(svcResource).Namespace(testNamespaceName).Patch(context.TODO(), testServiceName, types.StrategicMergePatchType, []byte(serviceStatusPatch), metav1.PatchOptions{}, "status")
            if err != nil {
              fmt.Println(err)
              return
            }

            for event := range svcWatchChan {
              if event.Type == watch.Modified {
                break
              }
          }


           svcStatus, err = DynamicClientSet.Resource(svcResource).Namespace(testNamespaceName).Get(context.TODO(), testServiceName, metav1.GetOptions{}, "status")
            if err != nil {
              fmt.Println(err)
              return
            }

     var svcStatusGet v1.Service
       svcStatusUjson, err := json.Marshal(svcStatus)
       if err != nil {
           fmt.Println(err, "Failed to marshal json of replicationcontroller label patch")
           return
       }

       json.Unmarshal(svcStatusUjson, &svcStatusGet)
     //   fmt.Println(svcStatusGet)
       if ! (svcStatusGet.ObjectMeta.Labels["test-service"] == "patched" ) {
           fmt.Println("failed to patch the Service")
       }

       fmt.Println("updating the ServiceStatus")
       svcStatusGet.Spec.Ports[0].Name = "http8081"
       svcStatusGet.Spec.Ports[0].Port = int32(8081)
       svcStatusGet.ObjectMeta.Labels["test-service"] = "updated"
       _, err = ClientSet.CoreV1().Services(testNamespaceName).Update(context.TODO(), &svcStatusGet, metav1.UpdateOptions{})
       if err != nil {
           fmt.Println(err)
           return
       }

       for event := range svcWatchChan {
           if event.Type == watch.Modified {
               break
           }
       }

       fmt.Println("finding Service in list")
       svcs, err := ClientSet.CoreV1().Services("").List(context.TODO(), metav1.ListOptions{LabelSelector: "test-service-static=true"})
       if err != nil {
           fmt.Println(err)
           return
       }
      // fmt.Println(svcs)
       foundSvc := false
       for _, svcItem := range svcs.Items {
           if svcItem.ObjectMeta.Name == testServiceName &&
              svcItem.ObjectMeta.Namespace == testNamespaceName &&
              svcItem.ObjectMeta.Labels["test-service"] == "updated" &&
              svcItem.Spec.Ports[0].Name == "http8081" &&
              svcItem.Spec.Ports[0].Port == int32(8081) {
               foundSvc = true
               break
           }
       }
       if foundSvc != true {
           fmt.Println("unable to find Service in list of Services")
           return
       }

                fmt.Println("deleting the service")
                             err = ClientSet.CoreV1().Services(testNamespaceName).Delete(context.TODO(), testServiceName, metav1.DeleteOptions{})
                               if err != nil {
                                  fmt.Println(err, "failed to delete the Service")
                                   return
                               }

                               // TEST ENDS HERE

                               fmt.Println("[status] complete")

                             }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   creating a Service
   watching for the Service to be added
   patching the ServiceStatus
   updating the ServiceStatus
   finding Service in list
   deleting the service
   [status] complete
   #+end_src











* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

  #+RESULTS:
  #+begin_SRC example
       useragent
  -------------------
   live-test-writing
  (1 row)

  #+end_SRC

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

#+RESULTS:
#+begin_SRC example
     useragent     |            operation_id            | hit_by_ete | hit_by_new_test
-------------------+------------------------------------+------------+-----------------
 live-test-writing | createCoreV1NamespacedService      | t          |             124
 live-test-writing | deleteCoreV1NamespacedService      | t          |              30
 live-test-writing | listCoreV1NamespacedService        | t          |             141
 live-test-writing | listCoreV1ServiceForAllNamespaces  | t          |               4
 live-test-writing | patchCoreV1NamespacedServiceStatus | f          |              64
 live-test-writing | readCoreV1NamespacedServiceStatus  | f          |              64
 live-test-writing | replaceCoreV1NamespacedService     | t          |               4
(7 rows)

#+end_SRC

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance
