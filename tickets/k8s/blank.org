# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [2/5]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/][MyEndpoint.org]]
- [X] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM untested_stable_core_endpoints
      -- FROM untested_stable_endpoints
      where path not like '%volume%'
      -- and kind like ''
      -- and operation_id ilike '%%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_SRC example
                 operation_id                |      kind
 --------------------------------------------+-----------------
  createCoreV1NamespacedPodBinding           | Binding
  createCoreV1NamespacedBinding              | Binding
  readCoreV1ComponentStatus                  | ComponentStatus
  listCoreV1ComponentStatus                  | ComponentStatus
  replaceCoreV1NamespacedEndpoints           | Endpoints
  patchCoreV1NamespacedEndpoints             | Endpoints
  listCoreV1EndpointsForAllNamespaces        | Endpoints
  deleteCoreV1CollectionNamespacedEndpoints  | Endpoints
  replaceCoreV1NamespacedEvent               | Event
  readCoreV1NamespacedEvent                  | Event
  patchCoreV1NamespacedEvent                 | Event
  listCoreV1NamespacedEvent                  | Event
  listCoreV1EventForAllNamespaces            | Event
  deleteCoreV1NamespacedEvent                | Event
  deleteCoreV1CollectionNamespacedEvent      | Event
  createCoreV1NamespacedEvent                | Event
  patchCoreV1NamespacedLimitRange            | LimitRange
  listCoreV1LimitRangeForAllNamespaces       | LimitRange
  deleteCoreV1CollectionNamespacedLimitRange | LimitRange
  replaceCoreV1NamespaceStatus               | Namespace
  replaceCoreV1NamespaceFinalize             | Namespace
  readCoreV1NamespaceStatus                  | Namespace
  patchCoreV1NamespaceStatus                 | Namespace
  patchCoreV1Namespace                       | Namespace
  listCoreV1Namespace                        | Namespace
 (25 rows)

 #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline
1. Create a RESOURCENAME with a static label

2. Patch the RESOURCENAME with a new label and updated data

3. Get the RESOURCENAME to ensure it's patched

4. List all RESOURCENAMEs in all Namespaces with a static label
   find the RESOURCENAME
   ensure that the RESOURCENAME is found and is patched

5. Delete Namespaced RESOURCENAME via a Collection with a LabelSelector

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
                        package main

                        import (
                          "encoding/json"
                          "fmt"
                          "context"
                          "flag"
                          "os"
                          v1 "k8s.io/api/core/v1"
                          "k8s.io/client-go/dynamic"
                          "k8s.io/apimachinery/pkg/runtime/schema"
                          metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
                          "k8s.io/client-go/kubernetes"
                          "k8s.io/apimachinery/pkg/types"
                          "k8s.io/client-go/tools/clientcmd"
                          "k8s.io/apimachinery/pkg/util/intstr"
                          watch "k8s.io/apimachinery/pkg/watch"
                        )

                        func main() {
                          // uses the current context in kubeconfig
                          kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
                          flag.Parse()
                          config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
                          if err != nil {
                              fmt.Println(err, "Could not build config from flags")
                              return
                          }
                          // make our work easier to find in the audit_event queries
                          config.UserAgent = "live-test-writing"
                          // creates the clientset
                          ClientSet, _ := kubernetes.NewForConfig(config)
                          DynamicClientSet, _ := dynamic.NewForConfig(config)
	                        svcResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "services"}

                          // TEST BEGINS HERE

                          testServiceName := "test-service"
                          testNamespaceName := "default"

                          fmt.Println("creating a Service")
                          testService := v1.Service{
                            ObjectMeta: metav1.ObjectMeta{
                              Name: testServiceName,
                              Labels: map[string]string{"test-service-static": "true"},
                            },
                            Spec: v1.ServiceSpec{
                                Type: "ClusterIP",
                                Ports: []v1.ServicePort{{
                                     Name: "http",
                                     Protocol: v1.ProtocolTCP,
                                     Port: int32(80),
                                     TargetPort: intstr.FromInt(80),
                              }},
                            },
                          }
                          _, err = ClientSet.CoreV1().Services(testNamespaceName).Create(context.TODO(), &testService, metav1.CreateOptions{})
                          if err != nil {
                              fmt.Println(err, "failed to create Service")
                              return
                          }

                          fmt.Println("watching for the Service to be added")
                          svcWatchTimeoutSeconds := int64(180)
                          svcWatch, err := ClientSet.CoreV1().Services(testNamespaceName).Watch(context.TODO(), metav1.ListOptions{LabelSelector: "test-service-static=true", TimeoutSeconds: &svcWatchTimeoutSeconds})
                          if err != nil {
                              fmt.Println(err, "failed to create service")
                              return
                          }

                 svcWatchChan := svcWatch.ResultChan()

                for event := range svcWatchChan {
                    if event.Type == watch.Added {
                         break
                    }
                }

       fmt.Println("patching the ServiceStatus")
       serviceStatusPatch, err := json.Marshal(map[string]interface{}{
           "metadata": map[string]interface{}{
               "labels": map[string]string{"test-service": "patched"},
           },
            "spec": map[string]interface{}{
                "ports": []map[string]interface{}{{
                    "name": "http8080",
                    "port": int32(8080),
                    "targetPort": int(8080),
                "selector": []map[string]interface{}{{
                "type": "LoadBalancer",
               }},
          }},
           },
       })

       if err != nil {
           fmt.Println(err)
           return
       }

      svcStatus, err := DynamicClientSet.Resource(svcResource).Namespace(testNamespaceName).Patch(context.TODO(), testServiceName, types.StrategicMergePatchType, []byte(serviceStatusPatch), metav1.PatchOptions{}, "status")
       if err != nil {
         fmt.Println(err)
         return
       }

       for event := range svcWatchChan {
         if event.Type == watch.Modified {
           break
         }
     }


      svcStatus, err = DynamicClientSet.Resource(svcResource).Namespace(testNamespaceName).Get(context.TODO(), testServiceName, metav1.GetOptions{}, "status")
       if err != nil {
         fmt.Println(err)
         return
       }

var svcStatusGet v1.Service
  svcStatusUjson, err := json.Marshal(svcStatus)
  if err != nil {
      fmt.Println(err, "Failed to marshal json of replicationcontroller label patch")
      return
  }

  json.Unmarshal(svcStatusUjson, &svcStatusGet)
   fmt.Println(svcStatusGet)
  if ! (svcStatusGet.ObjectMeta.Labels["test-service"] == "patched" ) {
      fmt.Println("failed to patch the Service")
  }


 //          fmt.Println("deleting the service")
  //                       err = ClientSet.CoreV1().Services(testNamespaceName).Delete(context.TODO(), testServiceName, metav1.DeleteOptions{})
    //                      if err != nil {
      //                       fmt.Println(err, "failed to delete the Service")
        //                      return
          //                }

                          // TEST ENDS HERE

                          fmt.Println("[status] complete")

                        }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   creating a Service
   watching for the Service to be added
   patching the ServiceStatus
   {{Service v1} {test-service  default /api/v1/namespaces/default/services/test-service/status 075cd084-bbdf-4b5a-8f5a-263ce1789b50 305530 0 2020-09-15 09:56:10 +1200 NZST <nil> <nil> map[test-service:patched test-service-static:true] map[] [] []  [{live-test-writing Update v1 2020-09-15 09:56:10 +1200 NZST FieldsV1 &FieldsV1{Raw:*[123 34 102 58 109 101 116 97 100 97 116 97 34 58 123 34 102 58 108 97 98 101 108 115 34 58 123 34 46 34 58 123 125 44 34 102 58 116 101 115 116 45 115 101 114 118 105 99 101 34 58 123 125 44 34 102 58 116 101 115 116 45 115 101 114 118 105 99 101 45 115 116 97 116 105 99 34 58 123 125 125 125 44 34 102 58 115 112 101 99 34 58 123 34 102 58 112 111 114 116 115 34 58 123 34 46 34 58 123 125 44 34 107 58 123 92 34 112 111 114 116 92 34 58 56 48 44 92 34 112 114 111 116 111 99 111 108 92 34 58 92 34 84 67 80 92 34 125 34 58 123 34 46 34 58 123 125 44 34 102 58 110 97 109 101 34 58 123 125 44 34 102 58 112 111 114 116 34 58 123 125 44 34 102 58 112 114 111 116 111 99 111 108 34 58 123 125 44 34 102 58 116 97 114 103 101 116 80 111 114 116 34 58 123 125 125 44 34 107 58 123 92 34 112 111 114 116 92 34 58 56 48 56 48 44 92 34 112 114 111 116 111 99 111 108 92 34 58 92 34 84 67 80 92 34 125 34 58 123 34 46 34 58 123 125 44 34 102 58 110 97 109 101 34 58 123 125 44 34 102 58 112 111 114 116 34 58 123 125 44 34 102 58 112 114 111 116 111 99 111 108 34 58 123 125 44 34 102 58 116 97 114 103 101 116 80 111 114 116 34 58 123 125 125 125 44 34 102 58 115 101 115 115 105 111 110 65 102 102 105 110 105 116 121 34 58 123 125 44 34 102 58 116 121 112 101 34 58 123 125 125 125],}}]} {[{http TCP <nil> 80 {0 80 } 0}] map[] 10.103.71.204 ClusterIP [] None  []   0 false nil <nil> []} {{[]}}}
   [status] complete
   #+end_src







* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             438 |          183 |          183 |                0
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by N points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance
