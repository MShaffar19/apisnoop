# -*- ii: apisnoop; -*-
#+TITLE: Write createCoreV1NameSpacedServiceAccountToken Mock Test 
#+AUTHOR: Stephen Heywood
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export

* TODO Progress [1/6]                                                :export:
- [X] APISnoop org-flow : [[https://github.com/cncf/apisnoop/blob/master/tickets/k8s/createCoreV1NameSpacedServiceAccountTokenTest.org][createCoreV1NameSpacedServiceAccountTokenTest.org]]
- [ ] test approval issue : [[https://github.com/kubernetes/kubernetes/issues/][kubernetes/kubernetes#]]
- [ ] test pr : kuberenetes/kubernetes#
- [ ] two weeks soak start date : testgrid-link
- [ ] two weeks soak end date :
- [ ] test promotion pr : kubernetes/kubernetes#?
* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining RESOURCENAME endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      path,
      -- description,
      category,
      kind
      FROM untested_stable_core_endpoints
      -- FROM untested_stable_endpoints
      where path not like '%volume%'
      and operation_id ilike 'create%Token'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

  #+RESULTS: untested_stable_core_endpoints
  #+begin_SRC example
                 operation_id                |                            path                             | category |     kind     
  -------------------------------------------+-------------------------------------------------------------+----------+--------------
   createCoreV1NamespacedServiceAccountToken | /api/v1/namespaces/{namespace}/serviceaccounts/{name}/token | core     | TokenRequest
  (1 row)

  #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/RESOURCENAME.go][client-go - RESOURCENAME]]

* The mock test                                                      :export:
** Test outline

1. 

2. 

3. 

4. 

** Test the functionality in Go
   #+NAME: Mock Test In Go
   #+begin_src go
     package main

     import (
       "context"
       "flag"
       "fmt"
       authenticationv1 "k8s.io/api/authentication/v1"
       v1 "k8s.io/api/core/v1"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/client-go/kubernetes"
       "os"
       // "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
     )

     // helper function that mirrors framework.ExpectNoError
     func ExpectNoError(err error, msg string) {
       if err != nil {
         errMsg := msg + fmt.Sprintf(" %v\n", err)
         os.Stderr.WriteString(errMsg)
         os.Exit(1)
       }
     }

     // helper function to inspect various interfaces
     func inspect(level int, name string, i interface{}) {
       fmt.Printf("Inspecting: %s\n", name)
       fmt.Printf("Inspect level: %d   Type: %T\n", level, i)
       switch level {
         case 1 :
           fmt.Printf("%+v\n\n", i)
         case 2 :
           fmt.Printf("%#v\n\n", i)
         default:
           fmt.Printf("%v\n\n", i)
       }
     }

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
         fmt.Println(err, "Could not build config from flags")
         return
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)
       // DynamicClientSet, _ := dynamic.NewForConfig(config)
       // podResource := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}

       // TEST BEGINS HERE

       fmt.Println("[status] begin")

       testPodName := "test-pod"
       testPodImage := "nginx"
       testNamespaceName := "default"

       fmt.Println("creating a Pod")
       testPod := v1.Pod{
         ObjectMeta: metav1.ObjectMeta{
           Name:   testPodName,
           Labels: map[string]string{"test-pod-static": "true"},
         },
         Spec: v1.PodSpec{
           Containers: []v1.Container{{
             Name:  testPodName,
             Image: testPodImage,
           }},
         },
       }
       _, err = ClientSet.CoreV1().Pods(testNamespaceName).Create(context.TODO(), &testPod, metav1.CreateOptions{})
       ExpectNoError(err, "failed to create Pod")

       fmt.Println("listing Pods")
       pods, err := ClientSet.CoreV1().Pods("").List(context.TODO(), metav1.ListOptions{LabelSelector: "test-pod-static=true"})
       ExpectNoError(err, "failed to list Pods:")

       podCount := len(pods.Items)
       if podCount == 0 {
         fmt.Println("there are no Pods found")
         return
       }
       fmt.Println(podCount, "Pod(s) found")
       inspect(1, "podCount", podCount)
       inspect(1, "pods.Items[0].UID", pods.Items[0].UID)

       // setup a token request 
       // ref: https://github.com/kubernetes/kubernetes/blob/master/test/integration/auth/svcaccttoken_test.go#L212
       treq := &authenticationv1.TokenRequest{
         Spec: authenticationv1.TokenRequestSpec{
           Audiences: []string{"api"},
           BoundObjectRef: &authenticationv1.BoundObjectReference{
             Kind:       "Pod",
             APIVersion: "v1",
             Name:       pods.Items[0].Name,
           },
         },
       }

       fmt.Println("set treq.Spec.BoundObjectRef.UID the same as the pod.UID")
       // ref: https://github.com/kubernetes/kubernetes/blob/master/test/integration/auth/svcaccttoken_test.go#L236
       treq.Spec.BoundObjectRef.UID = pods.Items[0].UID

       fmt.Println("Check treq.Spec.BoundObjectRefer")
       inspect(1, "treq.Spec.BoundObjectRef", treq.Spec.BoundObjectRef)

       fmt.Println("Check treq")
       inspect(1, "treq", treq)

       fmt.Println("create a Service Account for testing/understand token API")
       sa, err := ClientSet.CoreV1().ServiceAccounts("default").Create(context.TODO(), &v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: "exploring"}}, metav1.CreateOptions{})
       ExpectNoError(err, "Error: ")

       fmt.Println("Check 'sa' in detail")
       inspect(2, "sa", sa)
       inspect(1, "sa.Name", sa.Name)

       fmt.Println("Try to create a token...")
	     // ref: https://github.com/kubernetes/kubernetes/blob/master/test/integration/auth/svcaccttoken_test.go#L237
       resp, err := ClientSet.CoreV1().ServiceAccounts(sa.Namespace).CreateToken(context.TODO(), sa.Name, treq, metav1.CreateOptions{})
       // ExpectNoError(err, "Error: ")

       // err is not nil... looking for answers below
       inspect(2, "resp", resp)
       inspect(1, "err", err)

       // TEST ENDS HERE

       fmt.Println("[status] complete")
     }
   #+end_src

   #+RESULTS: Mock Test In Go
   #+begin_src go
   [status] begin
   creating a Pod
   listing Pods
   1 Pod(s) found
   Inspecting: podCount
   Inspect level: 1   Type: int
   1

   Inspecting: pods.Items[0].UID
   Inspect level: 1   Type: types.UID
   419b199d-727b-4f2c-ba13-125a5dbdebdf

   set treq.Spec.BoundObjectRef.UID the same as the pod.UID
   Check treq.Spec.BoundObjectRefer
   Inspecting: treq.Spec.BoundObjectRef
   Inspect level: 1   Type: *v1.BoundObjectReference
   &BoundObjectReference{Kind:Pod,APIVersion:v1,Name:test-pod,UID:419b199d-727b-4f2c-ba13-125a5dbdebdf,}

   Check treq
   Inspecting: treq
   Inspect level: 1   Type: *v1.TokenRequest
   &TokenRequest{ObjectMeta:{      0 0001-01-01 00:00:00 +0000 UTC <nil> <nil> map[] map[] [] []  []},Spec:TokenRequestSpec{Audiences:[api],BoundObjectRef:&BoundObjectReference{Kind:Pod,APIVersion:v1,Name:test-pod,UID:419b199d-727b-4f2c-ba13-125a5dbdebdf,},ExpirationSeconds:nil,},Status:TokenRequestStatus{Token:,ExpirationTimestamp:0001-01-01 00:00:00 +0000 UTC,},}

   create a Service Account for testing/understand token API
   Check 'sa' in detail
   Inspecting: sa
   Inspect level: 2   Type: *v1.ServiceAccount
   &v1.ServiceAccount{TypeMeta:v1.TypeMeta{Kind:"", APIVersion:""}, ObjectMeta:v1.ObjectMeta{Name:"exploring", GenerateName:"", Namespace:"default", SelfLink:"/api/v1/namespaces/default/serviceaccounts/exploring", UID:"9592e101-e44b-4f90-9b3f-004fedc83640", ResourceVersion:"29937", Generation:0, CreationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:63729842836, loc:(*time.Location)(0x1dc3860)}}, DeletionTimestamp:(*v1.Time)(nil), DeletionGracePeriodSeconds:(*int64)(nil), Labels:map[string]string(nil), Annotations:map[string]string(nil), OwnerReferences:[]v1.OwnerReference(nil), Finalizers:[]string(nil), ClusterName:"", ManagedFields:[]v1.ManagedFieldsEntry(nil)}, Secrets:[]v1.ObjectReference(nil), ImagePullSecrets:[]v1.LocalObjectReference(nil), AutomountServiceAccountToken:(*bool)(nil)}

   Inspecting: sa.Name
   Inspect level: 1   Type: string
   exploring

   Try to create a token...
   Inspecting: resp
   Inspect level: 2   Type: *v1.TokenRequest
   &v1.TokenRequest{TypeMeta:v1.TypeMeta{Kind:"", APIVersion:""}, ObjectMeta:v1.ObjectMeta{Name:"", GenerateName:"", Namespace:"", SelfLink:"", UID:"", ResourceVersion:"", Generation:0, CreationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}, DeletionTimestamp:(*v1.Time)(nil), DeletionGracePeriodSeconds:(*int64)(nil), Labels:map[string]string(nil), Annotations:map[string]string(nil), OwnerReferences:[]v1.OwnerReference(nil), Finalizers:[]string(nil), ClusterName:"", ManagedFields:[]v1.ManagedFieldsEntry(nil)}, Spec:v1.TokenRequestSpec{Audiences:[]string(nil), ExpirationSeconds:(*int64)(nil), BoundObjectRef:(*v1.BoundObjectReference)(nil)}, Status:v1.TokenRequestStatus{Token:"", ExpirationTimestamp:v1.Time{Time:time.Time{wall:0x0, ext:0, loc:(*time.Location)(nil)}}}}

   Inspecting: err
   Inspect level: 1   Type: *errors.StatusError
   the server could not find the requested resource

   [status] complete
   #+end_src

* Verifying increase in coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

  #+RESULTS:
  #+begin_SRC example
       useragent     
  -------------------
   live-test-writing
  (1 row)

  #+end_SRC

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%';
#+end_src

#+RESULTS:
#+begin_SRC example
     useragent     |               operation_id                | hit_by_ete | hit_by_new_test 
-------------------+-------------------------------------------+------------+-----------------
 live-test-writing | createCoreV1NamespacedPod                 | t          |               1
 live-test-writing | createCoreV1NamespacedServiceAccount      | t          |               1
 live-test-writing | createCoreV1NamespacedServiceAccountToken | f          |               1
 live-test-writing | listCoreV1PodForAllNamespaces             | t          |               1
(4 rows)

#+end_SRC

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number 
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             485 |          232 |          233 |                1
  (1 row)

  #+end_SRC

* Convert to Ginkgo Test
** Ginkgo Test
  :PROPERTIES:
  :ID:       gt001z4ch1sc00l
  :END:
* Final notes                                                        :export:
If a test with these calls gets merged, **test coverage will go up by 1 points**

This test is also created with the goal of conformance promotion.

-----
/sig testing

/sig architecture

/area conformance
