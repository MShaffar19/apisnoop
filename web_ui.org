#+NAME: APISnoop WebUI
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+PROPERTY: :dir ~/Projects/ii/apisnoop_webui

* Introduction
  This project is a proof of concept for making the web interface of modular and dynamic, by turning it into a React app.  Our current site can be found here:[[https://apisnoop.ii.coop][apisnoop.ii.coop]].  For the first go of this, we want our app to look nearly identical, with the same functionality:
- visual display
- Dropdown to choose between csv's
- Ability to download the audit-log or csv.
** Why Do this?
   The current site is entirely hard-coded html. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new static link.  Not only is this time-consuming, it's error-prone. It's also really hard to maintain.

The site also bears the mark of different hands with different ideas moving quickly to get something 'working' but not pretty.  So the site is using multiple CSS frameworks plus custom CSS and multiple javascript helper utilities.  This also makes the site hard to reason about or design, as you don't know what things you can change and what things are required for the framework.

The current site was the most basic proof of concept. We want to build a whole bunch of things on top of this, including github authorization and site-visitor customizatioin, and the ability to really customize the view you are seeing.  So I want to start again with a foundation to the site that is easier to reason about, easier to maintain, and easier to extend.

* Architecture
The site will be made to have a distinct front-end and backend, with the front-end able to be ported over to any other backend.
The front-end will consist of multiple components that wait to be told what data to display, instead of being written as part of the component.  In this way, if we want to make changes to our 'SIG Tag Bubble', we can just find the component named that and make changes there, instead of trying to find/replace the code within the file.
** FRONTEND
The frontend will be made with React, Redux, maybe Saga, and Tachyons.
*** Why React?
    [[https://reactjs.org/][React]] is the most well-known and supported front-end framework among my dev friends in Wellington, and is widely used and respected globally.  It was created originally by Facebook and then made open-source.  So it has a tremendous amount of support around it and good video tutorials for learning it.  I find it to be a bulky and kinda clumsy framework (which is why the first version of this used my personal fave Choo instead), but felt it was good to pick one that more people knew (and could help with).

*** Why Redux?
   [[https://redux.js.org/][Redux]]  provides one global 'state' for the app, and makes React actually usable.  It will help us push the data appropriately to the right parts and keep things clean and efficient.

*** Why Saga?
   [[https://redux-saga.js.org/][Saga]] helps us with api calls and redux.  Redux likes pure clean objects sent to the store right away.  API calls don't work like that, and so Saga does the call and then sends the results to Redux.  It's working as a side effect.

*** Why Tachyons?
    Tachyons is a css framework for writing functional CSS.  It's a much different approach to CSS, but it's one that matches a unix philosophy and is super easy to spin things up and maintain them.  AS we make changes, we don't have to worry that some class hidden deep in some css file causes our whole site to look weird.  Instead, every class has a single purpose, and you add multiple classes to a site to add-upon and combine each of these classes functions (like piping commands together on the command line).  This makes all our components //reusable// too, as we only need to copy over the code and not any stylesheet attached to the code.
** BACKEND
   For the backend we will be using Feathers //for right now//.  We may find that we want something completely different, or that we want our webui to be able to live in multiple places.  Our goal is for the two to be entirely separate, so either can change if needed.
*** Why Feathers?
    [[https://feathersjs.com/][Feathers]] is a well-designed and well-documented api layer written in Node.  It has good support among my Wellington dev friends, and so I have better help if I encounter any sorta problem.  It also is just really pleasant to use so far, with a good model for how to create different services.  It also has an existing React connector.

* Process
** Tutorials
   I am going through some simple tutorials for connecting react to redux to feathers.  It's a slightly longer process, but it's going to set me up better for maintaining apisnoop.  My assumption is that this is not a one-and-done thing.  We will be continually adding features to apisnoop and these features will become increasingly more complex. In addition, we'll be needing to adapt apisnoop for different scenarios. So I want to understand the stack for our webapp entirely.

I am coming in with good html and css knowledge for building personal projects.  What we are building is a production level app.  No matter how simple we make it, we will be pinging different sites, manipulating the data within those sites, and then displaying visualizations of our manipulations.  There isn't really a way to do this casually.  Especially if we want it to be stury and testable.  So I am biting off the sizable task of 'build a full-stack production-ready app by myself'.  I want to have all the tools I can to do this.

So I am going to make a v. simple fullstack app and then add in our own customizations until we get to the point where I can hear a task and know exactly how to realize it in this code.
* Backend
** Setup
  We can speed up this process by [[https://www.npmjs.com/package/@feathersjs/feathers][installing the feathers module through npm]], then using their ~feathers generate app~.  This will generate a full backend server for us, using their design patterns.
  ===
  ;;within our apisnoop_webui directory...

  npm install -g @feathersjs/cli
  mkdir backend
  cd backend
  feathers generate app
  ===

This will bring you through some prompts, which is why i'm not making it runnable code here.
*** Mongodb
    you'll need a working version of mongodb and to have the server up and running, as outlined here: https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/
** Create sample service.
   We want just something basic to make sure we can grab it later with react/redux.  So we'll make one called /cats that has different cats and their CATchphrases.

   We can use feathers for this too, from within the backend directory: ~feathers generate service~
   This will lead you through some prompts to decide what sorta service you want.
*** Change mongoose.js
    this is just a part of our tutorial, but you need to add mongoose's new url parser to get it to load correctly.  it's cos of an update i guess.
    #+NAME: Mongoose.js
    #+BEGIN_SRC js :tangle ~/Projects/ii/apisnoop_webui/backend/src/mongoose.js
      const mongoose = require('mongoose');

      module.exports = function (app) {
        mongoose.connect(app.get('mongodb'), { useNewUrlParser: true });
        mongoose.Promise = global.Promise;

        app.set('mongooseClient', mongoose);
      };
    #+END_SRC
**
** Config
   This folder holds the settings for the entire backend.  When you add a new service, it's configurable values get added into here too.

   You can also set separate production and dev configs, which is useful for changing the host name or other settings as needed!
*** Default.json
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/config/default.json
    :END:

    #+NAME: default.json
    #+BEGIN_SRC json
      {
        "host": "localhost",
        "port": 3030,
        "public": "../public/",
        "paginate": {
          "default": 50,
          "max": 50
        },
        "nedb": "../data",
        "mongodb": "mongodb://localhost:27017/backend"
      }
    #+END_SRC
*** Production.json
** Services
*** Contact
    This is a dummy service meant to follow a tutorial.  It'll be erased later, but the process is good for discovery.

   When you create a new service with feathers it makes a bunch of files automatically for you: config files, test files, models for the service and so on.  Many of these work by deefault, but you can also adjust them as needed.
**** Config
** Models
   The models are made automatically when you generate a new service too, and are sort of service specific configurations.  These can also be edited as needed.
*** Contact Model
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/src/models/contact.model.js
    :END:

This is the beginning model, that was made automatically.
    #+BEGIN_SRC js :tangle no
      // contact-model.js - A mongoose model
      //
      // See http://mongoosejs.com/docs/models.html
      // for more of what you can do here.
      module.exports = function (app) {
        const mongooseClient = app.get('mongooseClient');
        const { Schema } = mongooseClient;
        const contact = new Schema({
          text: { type: String, required: true }
        }, {
          timestamps: true
        });

        return mongooseClient.model('contact', contact);
      };
    #+END_SRC
Then we essentially alter the schema, so it has the right columns and data for our sample.
    #+BEGIN_SRC js
      // backend/src/models/contact.model.js zach!

      require('mongoose-type-email');

      module.exports = function (app) {
        const mongooseClient = app.get('mongooseClient');
        const contact = new mongooseClient.Schema({
          name : {
            first: {
              type: String,
              required: [true, 'First Name is required']
            },
            last: {
              type: String,
              required: false
            }
          },
          email : {
            type: mongooseClient.SchemaTypes.Email,
            required: [true, 'Email is required']
          },
          phone : {
            type: String,
            required: [true, 'Phone is required'],
            validate: {
              validator: function(v) {
                return /^\+(?:[0-9] ?){6,14}[0-9]$/.test(v);
              },
              message: '{VALUE} is not a valid international phone number!'
            }
          },
          createdAt: { type: Date, 'default': Date.now },
          updatedAt: { type: Date, 'default': Date.now }
        });

        return mongooseClient.model('contact', contact);
      };
    #+END_SRC
** Test
Also created by feathers by default (I love feathers).  Every new service you add gets a new test.
*** Services
**** Contact
     :PROPERTIES:
     :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/test/services/contact.test.js
     :END:

     By default our test looks like this:
     #+NAME: default test
     #+BEGIN_SRC js :tangle no
       const assert = require('assert');
       const app = require('../../src/app');

       describe('\'contact\' service', () => {
         it('registered the service', () => {
           const service = app.service('contacts');

           assert.ok(service, 'Registered the service');
         });
       });
     #+END_SRC

     Our change is minimal, ~~app.service('contacts')~ becomes ~~app.service('contact')~~
     and we make 'Registered the service' lowercase.
     #+NAME: contact.test.js
     #+BEGIN_SRC js
       const assert = require('assert');
       const app = require('../../src/app');

       describe('\'contact\' service', () => {
         it('registered the service', () => {
           const service = app.service('contact');

           assert.ok(service, 'registered the service');
         });
       });
     #+END_SRC
*** Testing everything
    :PROPERTIES:
    :header-args: :dir ~/Projects/ii/apisnoop_webui/backend :results output verbatim drawer
    :END:

    With yr tests configured you can run them all in the terminal.
    #+NAME: test everything
    #+BEGIN_SRC shell
      yarn test
    #+END_SRC

    #+RESULTS: test everything
    :RESULTS:
    :END:



* Client
  :PROPERTIES:
  :header-args: :dir ~/Projects/ii/apisnoop_webui/client
  :END:
  The client will be all the files that bundle up into a bundle.js file that is called on our index.html page.
** Creation
*** initial react app
    We are going to use the default app style (because we want this to be familiar to others), and luckily there's an npm module to create react apps for us to do just that!
    #+NAME: Create React App
    #+BEGIN_SRC sh :dir ~/Projects/ii/apisnoop_webui :results output
      npx create-react-app client
    #+END_SRC
    #+RESULTS: Create React App
*** dependencies
   We want to add some adaptors for react to use redux //and// feathers //and// tachyons
   #+NAME: install dependencies
   #+BEGIN_SRC sh :results output verbatim drawer
     npm install --save \
         @feathersjs/client \
         feathers-localstorage \
         feathers-redux \
         react-dom \
         react-redux \
         react-router \
         react-router-redux \
         react-router-dom \
         redux \
         redux-thunk \
         redux-devtools-extension \
         redux-saga \
         superagent
   #+END_SRC

   #+RESULTS: install dependencies
   :RESULTS:
   + react-dom@16.5.2
   + react-router@4.3.1
   + feathers-localstorage@3.0.0
   + react-redux@5.0.7
   + redux@4.0.0
   + superagent@4.0.0-beta.5
   + redux-saga@0.16.0
   + react-router-redux@4.0.8
   + @feathersjs/client@3.7.3
   added 11 packages from 11 contributors, updated 5 packages and audited 14613 packages in 12.257s
   found 0 vulnerabilities

   :END:
*** file structure
    Within our client we want to manage our various components, the actions they can call upon, and the reducers that turn all these actions into a single state of the app. These dont' come with the basic react app, so we'll create them.
    We also want to delete any of the default react icons or CSS stuff and move our App.js into a component (cos that's what it is.
    #+BEGIN_SRC sh :results output
      cd src
      rm App.css index.css logo.svg
      mkdir components actions reducers sagas
      mv App.js components
      cd ..
      tree -I 'node_modules'
    #+END_SRC
    #+RESULTS:
    #+begin_example
    .
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   ├── index.html
    │   └── manifest.json
    ├── src
    │   ├── App.test.js
    │   ├── actions
    │   ├── components
    │   │   └── App.js
    │   ├── index.js
    │   ├── reducers
    │   ├── registerServiceWorker.js
    │   └── sagas
    └── yarn.lock

    5 directories, 11 files
    #+end_example
** Tachyons
   We want to bring tachyons right into our app, installing it through node.  This way we have full access to the css library without relying on outside links and this library is as up-to-date as possible(or rather, v. easy to stay up to date.)  I am following the guide for react that tachyons listed[[https://github.com/tachyons-css/tachyons-and-react][ on their github page.]]
*** Install Tachyons and Sheetify
    I wont' be using sheetify right now, but the goal is to use it upon a refactor (when we've moved away from webpack to browseriy)
    #+NAME: Install Tachyons
    #+BEGIN_SRC shell :dir ~/Projects/ii/apisnoop_webui/client :results output verbatim drawer
      npm install --save tachyons tachyons-cli sheetify
    #+END_SRC

    #+RESULTS: Install Tachyons
    :RESULTS:
    + tachyons-cli@1.3.2
    + tachyons@4.11.1
    + sheetify@7.3.3
    added 31 packages from 18 contributors, updated 2 packages, moved 3 packages and audited 20856 packages in 29.843s
    found 1 low severity vulnerability
      run `npm audit fix` to fix them, or `npm audit` for details
    :END:
*** Find Home for CSS
    #+NAME: Find Home for CSS
    #+BEGIN_SRC shell :dir ~/Projects/ii/apisnoop_webui/client/src :results output verbatim drawer
      mkdir css
      echo '@import "tachyons"' > css/app.css
      tree css
    #+END_SRC

    #+RESULTS: Find Home for CSS
    :RESULTS:
    css
    └── app.css

    0 directories, 1 file
    :END:
*** Add CSS scripts
I'll add a couple additions to our package.json (this is best outlined in the github link)

** index.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/index.js
   :END:
   This is the starting point for the full app, in which we initialize React, connect it to redux, start up our store, connect to feathers and all that good stuff.
*** Requirements
    index is really here to spin up react and redux and guide us to the beginning components and store where the real stuff happens. BrowserRouter is brought in so that clicking on different navlinks in our App component will work like url's on a standard webpage.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import React from 'react'
      import ReactDOM from 'react-dom'
      import { BrowserRouter } from 'react-router-dom'
      import './index.css'

      import {Provider} from 'react-redux'

      import App from './components/App'
      import store from './store'
    #+END_SRC
*** Mount to Dom
    Once we have the router setup, we need to mount everything to our index.html file (in our public folder).  This is how javascript can magically render itself as html to whoever's looking at it.
    #+NAME: ReactDOM render
    #+BEGIN_SRC js
      ReactDOM.render(
          <Provider store={store}>
          <BrowserRouter>
          <App />
          </BrowserRouter>
          </ Provider>,
        document.getElementById('root')
      )
    #+END_SRC
** Component
*** App
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/App.js
    :END:
**** Introduction
      The starting place for our whole front-end.  Right now it is light, and based on the sitepoint tutorial.

     The app component is often seen as the 'layout template' for the entire single page app (as said by Wes Bos) and so it is meant to handle the navigation and the routes that determine which components we show.

  The entire app will actually take place on the index.html page, but will render different views dynamically.  These views can be shared by their URL's, so it's like we have a deep webpage of thangs--but really it's a continually transforming bit of javascript code.

  our original app component looked like this.
      #+NAME: Original App Component
      #+BEGIN_SRC js :tangle no
        import React, { Component } from 'react'

        class App extends Component {
          render(){
            return (
                <div>
                <h1>APISNOOP/Contact Manager</h1>
                <h2>ignore these words for now, they are just proof that this works.</h2>
                </div>
            )
          }
        }

        export default App
      #+END_SRC

  Let's deep dive into how it'll look now, as this is a structure that we'll see in a bunch of React apps.

**** Requirements

We'll start with the classic requirement: react and the Component class.
  #+NAME: Import React
  #+BEGIN_SRC js
    import React, { Component } from 'react'
  #+END_SRC

Next, we'll bring in react's smart navigation.  These are what make the app appear to be multiple pages.

#+NAME: import routing and navigation
#+BEGIN_SRC js
  import { NavLink, Route } from 'react-router-dom'
#+END_SRC

Lastly, we bring in our different pages, which we can navigate between using a nice lil' tab and navlinks..

#+NAME: import components
#+BEGIN_SRC js
  import Header from './Header'
  import ContactListPage from '../pages/contact-list-page'
  import ContactFormPage from '../pages/contact-form-page'
#+END_SRC

**** The overall Layout
     The general shape of this template is here:
     #+NAME: App Layout
     #+BEGIN_SRC js
       class App extends Component {
         render(){
           return (
             <div id='app'>
               <Header />
               <<Nav Links>>
               <<Routes>>
             </div>
           )
         }
       }

       export default App
     #+END_SRC



**** the Navlinks
     the navlinks will be visual components that act like standard links;  exact to acts like href.
     #+NAME: Nav Links
     #+BEGIN_SRC js :tangle no
       <div id='nav'>
        <NavLink exact to='/'>Contacts List</NavLink>
        <NavLink exact to='/contacts/new'>Add a Contact</NavLink>
       </div>
     #+END_SRC
**** the Routes
     The routes listen to the paths chosen by nav and routes to the correct component.  So the components don't show unless the url path matches their route.
     #+NAME: Routes
     #+BEGIN_SRC js :tangle no
         <Route exact path='/' component={ContactListPage} />
         <Route path='/contacts/new' component={ContactFormPage} />
         <Route path='/contacts/edit/:_id' component={ContactFormPage} />
     #+END_SRC

*** Contact Form
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/contact-form.js
    :END:
    part of our tutorial.  this is going to be a 'smart' component, meaning it has it's own state that is aware of and tracking.
    #+NAME: contact-form
    #+BEGIN_SRC js
      import React, { Component } from 'react'

      class ContactForm extends Component {
        render(){
          return (
              <div>
                <p>under construction...</p>
              </div>
          )
        }
      }

      export default ContactForm
    #+END_SRC
*** Contact List
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/contact-list.js
    :END:

    part of our tutorial.  It is purely presentational, and so does not need to be a full stateful component.
    #+NAME: contact-form
    #+BEGIN_SRC js
      import React from 'react'

      export default function ContactList () {
        return (
            <div>
              <p>No Contacts here</p>
            </div>
        )
      }
    #+END_SRC
*** Header
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/Header.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <header className='flex-row items-center justify-start bg-moon-gray black shadow-4'>
            <h1 className='pa2'>APISnoop</h1>
          </header>
      )
    #+END_SRC
** Pages
   This is a format i haven't seen before, but present in Wes Bos' tutorial, but seems useful for routing.  Our top level containers, or components, are under our Pages directory.
*** Contact List Page
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/pages/contact-list-page.js
    :END:

Slightly different from contact-list, in that it is now a class extending our react component.  I'm curious how we imported react in our contact-list component but didn't actually use it. I believe it's because we are calling it within this render function here.

    #+NAME: contact-list-page
    #+BEGIN_SRC js
      import React, { Component } from 'react'
      import ContactList from '../components/contact-list'

      class ContactListPage extends Component {
        render(){
          return(
              <div>
                <h1>List of Contacts</h1>
                <ContactList />
              </div>
          )
        }
      }

      export default ContactListPage
    #+END_SRC
*** Contact Form Page
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/pages/contact-form-page.js
    :END:
    Similar to the list.  Simple for now.
    #+BEGIN_SRC js
      import React, { Component } from 'react'

      import ContactForm from '../components/contact-form'

      class ContactFormPage extends Component {
        render() {
          return (
              <div>
                <ContactForm />
              </div>
          )
        }
      }

      export default ContactFormPage
    #+END_SRC

** Store
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/store.js
   :END:
   :LOGBOOK:
   - Note taken on [2018-09-26 Wed 16:35] \\
     I want to be using Saga, ultimately, but I think I'm shooting too far iwth it.  First goal is to just get react talking to feathers.
   :END:
 This will store the global state of the app as store.js.  We are using redux for this, which is a wonderful purely functional way of maintaining state.  Because of how it operates, though, it doesn't work well, directly, for API calls and so we will create sagas that handle those calls for us.  So the saga will call our feathers api and give its result to redux as input and redux will reduce this and output our state.
*** Requirements
      #+NAME: requirements
      #+BEGIN_SRC js
        import { createStore, applyMiddleware } from 'redux'
        import { composeWithDevTools } from 'redux-devtools-extension'

        import thunk from 'redux-thunk'
        import promiseMiddleware from 'redux-promise-middleware'

        import rootReducer from './reducers/index.js'
      #+END_SRC
*** Create Store
    For simplicity's sake at the beginning, we want to try to use redux-feathers as a simple way to bring our server services into our app.

    As we want to use feathers and external servers, we need to have some middleware put into place to wrap up our actions so they can be received by redux properly.  This is the purpose of ~thunk~ and ~promiseMiddleware~.  You can find a further explanation here:[[https://github.com/feathers-plus/feathers-redux][ feathers-redux github page]]

    #+NAME: Create Store
    #+BEGIN_SRC js

      var store = createStore(
        rootReducer,
        composeWithDevTools(applyMiddleware(thunk, promiseMiddleware))
      )
    #+END_SRC
*** export store
    bring it all together so we can access the store and history in our above index.js
    #+NAME: export store
    #+BEGIN_SRC js
   export default store
    #+END_SRC
** Actions
*** actionCreators
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/actions/actionCreators.js
   :END:
    This delivers the content do our reducers.  Actions are just objects with information.
    At the beginning we want to just make sure this all works.  We have an api called /cats so let's work with that!
    #+NAME: action
    #+BEGIN_SRC js
      export function actionCats () {
        return {
          type: 'CATS_REQUESTED'
        }
      }

      export function funZachAction () {
        return {
          type: 'TEST'
        }
      }
    #+END_SRC

** Reducers
   In our cats one we have a test just to make sure these reducers are working.  I can properly send out dispatches for both of these, so the reducer is correctly attached to our client.
*** cats
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/cats.js
   :END:
   #+NAME: cats
   #+BEGIN_SRC js
     function cats (state=[], action) {
       switch(action.type) {
         case 'CATS_SUCCEEDED':
           return action.cats
         case 'TEST':
           return 'test is success'
         default:
           return state
       }
     }
     export default cats
   #+END_SRC
*** index
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/index.js
   :END:
   This one will gather all our other reducers into a single rootReducer, this is the one that gets added to our store in [[*index.js][client/index.js]]
**** requirements
     Right now we are doing feathers-redux, if that goes away, they can go away here too.
    #+NAME: requirements
    #+BEGIN_SRC js
      import { combineReducers } from 'redux'
      import { routerReducer } from 'react-router-redux'

      import reduxifyServices from 'feathers-redux'
      import feathers from '@feathersjs/client'
      import superagent from 'superagent'

      import cats from './cats'
    #+END_SRC
**** Create application
     Our goal is to use feathers-redux (more info here:[[https://github.com/feathers-plus/feathers-redux][feathers-redux github]] )
     We'll connect this to our feathers backend which is located at localhost:3030, using the feathers client adaptor.  This can be configured so it works with authentication, with the hooks on each thing (modifying data as it flows through the service), and we'll bring in superagent so the api calls work correctly with redux.
     #+NAME: create application
     #+BEGIN_SRC js
       const host = 'http://localhost:3030'
       export const feathersClient = feathers()
         .configure(feathers.rest(host).superagent(superagent))
         .configure(feathers.authentication({ store: window.localstorage }))
     #+END_SRC
**** setup feathers services as reducers
   each service in the server can be rendered as an object for state here.
   #+NAME: feathers services
   #+BEGIN_SRC js
     const services = reduxifyServices(feathersClient, ['cats'])
   #+END_SRC

**** Combine reducers and export
     #+NAME: the reducer
     #+BEGIN_SRC js
       const rootReducer = combineReducers({
         cats,
         routing: routerReducer,
         fcat: services.cats.reducer
       })

       export default rootReducer
     #+END_SRC
** Services
   This will handle our api calls, we reference it back in our [[*Sagas][Sagas]]
*** API
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/services/api.js
   :END:
    #+NAME: API
    #+BEGIN_SRC js
      export function getCats (app) {
  console.log('cats requested!')
        const cats = app.service('cats')
        return cats.get().then((cat, err) => cat.cat)
      }
    #+END_SRC
*** App
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/App.js
    :END:
    There isn't much here since it's really just a wrapper for our main component.  But it sets up that component nicely.
* TASKS

** DONE Get working React App on top of Feathers, no matter what it looks like.
   CLOSED: [2018-09-26 Wed 23:42]
   This should show up a webpage when we spin up a server using feathers.

** TODO figure out why there's padding added by default to our app, even though no padding appears when you inspect element.
** TODO Follow sitepoint tutorial to get backend and frontend working
** DONE Understand what function* does and yield* does
   CLOSED: [2018-09-26 Wed 17:32]
   It has to do with asynchronous calls in the new es6, specifically with Saga.  So it's a special type of syntax for what saga does, which is take complex chained functions and put them in a nice pipe syntax.  It's not a full js thing, just a saga thing.
** DONE Figure out the issue with Browser history.
   CLOSED: [2018-09-26 Wed 17:33]
   it was an issue between react v.3 and react v.4.  I'm implementing things ina  different way now.
* Footnotes
** Resources
*** Youtube Tutorial
    I followed [[https://www.youtube.com/watch?v=etq_vv_RVcU&index=2&list=PLN3n1USn4xlnulnnBGD2RMid_p7xVj9xU][This Tutorial]] for a lot of the setup and found it quite useful, but actually it's mad outdated and might be a set back.  It helped me get a better sense of Sagas but react and redux have changed too much since this tutorial.
*** Sitepoint tutorial
   [[https://www.sitepoint.com/crud-app-react-redux-feathersjs/][sitepoint tutorial]]
    this one is far newer, and scanning it after doing all my research it is using mostly up-to-date code samples.  I think it'd be best to follow this going forward.
** Outdated or Experimental
   :PROPERTIES:
   :header-args: :tangle no
   :END:
*** Sagas
**** sagas.js
     :PROPERTIES:
     :header-args: :noweb yes :tangle no
     :END:
***** requirements
    #+NAME: requirements
    #+BEGIN_SRC js
      import { call, put, takeEvery } from 'redux-saga/effects'

      import { getCats } from '../services/api'
    #+END_SRC

    #+RESULTS: requirements

***** root function
      This'll be the thing exported out that we call upon when we do sagaMiddleware.run(mySaga, app) in our store.js
      We'll define our different sagas that we run...these take actions and make api calls with them.  Since they are asynchronous, we are using the * sign with the function. (this is outta my element, so I'm following a tutorial and need to better understand this syntax.)

      #+NAME: root function
      #+BEGIN_SRC js
        <<cats saga>>
        <<fetch cats>>
        export default function* root(feathersApp) {
          yield call(catsSaga, feathersApp)
        }
      #+END_SRC

***** cats saga
   Here is an example saga.  We'll get more complex later, but this shows the general format.  You take everyinstance of an action, send it to a function we define, and connect it with our feathers backend.

   #+NAME: cats saga
   #+BEGIN_SRC js :tangle no
     function* catsSaga (feathersApp) {
       yield* takeEvery('CATS_REQUESTED', fetchCats, feathersApp)
     }
   #+END_SRC

***** fetch cats
      This function calls our getCats function (which we'll define in our services/api) to  our backend and with its yield, sends out a call.
   #+NAME: fetch cats
   #+BEGIN_SRC js :tangle no
     function* fetchCats (feathersApp) {
   console.log('fetch cats reached')
       try {
         const cats = yield call(getCats, feathersApp)
         yield put({type: 'CATS_SUCCEEDED', cats})
       } catch (e) {
         yield put({type: 'FETCH_CATS_FAILED', message: e.message})
       }
     }
   #+END_SRC

 So all in all, we have a general flow for handling asynchronous calls to an api.  Within our app we'll send out an action like 'CATS_REQUESTED'.  Redux isn't ready to handle this yet, since it also just wants cats, ince and simple,  so it can add them to the state and let us display it.  We don't know when the api will respond to our cats request, and so we are in the asynchronous land.

 And so to help, we have a saga setup that is listening to all our 'CATS_REQUESTED' actions.  When one comes in, it runs its fetchCats function, which pings our api.  We assume success here (though can build it out so say what happens when there's a failure), and success means we are delivered some nice json.  We can take that object, then, and send //that// to redux.

 We do this by announcing we have something to give redux with our action 'CATS_SUCCEEDED', which redux will be setup to listen for, and will take the cats we deliver and add it to state.
*** Store
**** store requirements with saga.
I'd like to use these, or something like it, but it's requiring a bit too much rabbit-holing and I just wanna deliver a small improvement.  So we'll return to Sagas v. Epics v. Callbags later.
      #+NAME: requirements with Saga
      #+BEGIN_SRC js :tangle no
        import { createStore, applyMiddleware } from 'redux'
        import { composeWithDevTools } from 'redux-devtools-extension'

        import createSagaMiddleware from 'redux-saga'
        import mySaga from './sagas/sagas'

        import rootReducer from './reducers/index.js'

        import superagent from 'superagent'
        import feathers from '@feathersjs/client'

      #+END_SRC
**** Create Saga Middleware
     #+NAME: create saga middleware
     #+BEGIN_SRC js
       const sagaMiddleware = createSagaMiddleware()
     #+END_SRC
**** Apply Saga Middleware
     #+NAME: apply saga middleware
     #+BEGIN_SRC js
       sagaMiddleware.run(mySaga, app)

     #+END_SRC
*** Components
**** App
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React from 'react'
        import { HashRouter, Route } from 'react-router-dom'

        import { bindActionCreators } from 'redux'

        import { connect } from 'react-redux'

        import * as actionCreators from '../actions/actionCreators'
        import Main from './Main'
      #+END_SRC
***** MapStateToProps
      This lets us bring the app's state as properties to the component, in other words as things the html elements know how to display without having to know anything about the data itself.
      #+NAME: MapStateToProps
      #+BEGIN_SRC js
        function mapStateToProps (state) {
          return {
            cats: state.cats
          }
        }
      #+END_SRC

***** MapDispatchToProps
      This lets us call out actions easily (with less this.state.actions.dispatch.action nonsense)
      #+NAME: MapDispatchToProps
      #+BEGIN_SRC js
        function mapDispatchToProps (dispatch) {
          return bindActionCreators(actionCreators, dispatch)
        }
      #+END_SRC

***** The App Component
      #+NAME: App
      #+BEGIN_SRC js
        class App extends React.Component {
          componentDidMount () {
            this.props.funZachAction()
            this.props.dispatch(services.cats.get())
            this.props.actionCats()
          }
          render(){
            return (
            <HashRouter>
              <div>
                <Route exact path='/' component={Main} />
              </div>
            </HashRouter>
            )
          }
        }
        export default connect(mapStateToProps, mapDispatchToProps)(App)
      #+END_SRC

**** Main
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatList from './CatList'
      #+END_SRC

***** The Main Class
      #+NAME: Main
      #+BEGIN_SRC js
        class Main extends Component {
          render(){
            return(
              <div>
                <h1>This is the Main Component</h1>
              </div>
            )
          }
        }
        export default Main
      #+END_SRC

**** Home
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatList from './CatList'
      #+END_SRC
***** The Home Class
      #+NAME: Home
      #+BEGIN_SRC js
        class Home extends Component {
          render(){
            return(
              <div>
                <CatList {...this.props}/>
              </div>
            )
          }
        }

        export default Home
      #+END_SRC
**** CatList
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatCard from './CatCard'
      #+END_SRC

***** The CatList Class
      #+NAME: Cat
      #+BEGIN_SRC js
        class CatList extends Component {
          constructor(props){
            super(props)

            this.props.actionCats()
          }

          render(){
            return(
                <ul>
                {this.props.cats.map((cat, i) => <CatCard {...this.props} key={i} cat={cat} />)}
              </ul>
            )
          }
        }

        export default CatList
      #+END_SRC

**** CatCard
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
      #+END_SRC

***** The CatCard Class
      #+NAME: CatCard
      #+BEGIN_SRC js
        class CatCard extends Component {
          render(){
            const { cat } = this.props
            return (
                <li>
                  <h2>{cat.name}</h2>
                  <em>{cat.catchphrase}</em>
                </li>
            )
          }
        }

          export default CatCard
      #+END_SRC
