#+NAME: APISnoop WebUI
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+PROPERTY: :dir ~/Projects/ii/apisnoop_webui

* Introduction
  This project is a proof of concept for making the web interface of modular and dynamic, by turning it into a React app.  Our current site can be found here:[[https://apisnoop.ii.coop][apisnoop.ii.coop]].  For the first go of this, we want our app to look nearly identical, with the same functionality:
- visual display
- Dropdown to choose between csv's
- Ability to download the audit-log or csv.
** Why Do this?
   The current site is entirely hard-coded html. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new static link.  Not only is this time-consuming, it's error-prone. It's also really hard to maintain.

The site also bears the mark of different hands with different ideas moving quickly to get something 'working' but not pretty.  So the site is using multiple CSS frameworks plus custom CSS and multiple javascript helper utilities.  This also makes the site hard to reason about or design, as you don't know what things you can change and what things are required for the framework.

The current site was the most basic proof of concept. We want to build a whole bunch of things on top of this, including github authorization and site-visitor customizatioin, and the ability to really customize the view you are seeing.  So I want to start again with a foundation to the site that is easier to reason about, easier to maintain, and easier to extend.

* Architecture
The site will be made to have a distinct front-end and backend, with the front-end able to be ported over to any other backend.
The front-end will consist of multiple components that wait to be told what data to display, instead of being written as part of the component.  In this way, if we want to make changes to our 'SIG Tag Bubble', we can just find the component named that and make changes there, instead of trying to find/replace the code within the file.
** FRONTEND
The frontend will be made with React, Redux, and Tachyons.
*** Why React?
    [[https://reactjs.org/][React]] is the most well-known and supported front-end framework among my dev friends in Wellington, and is widely used and respected globally.  It was created originally by Facebook and then made open-source.  So it has a tremendous amount of support around it and good video tutorials for learning it.  I find it to be a bulky and kinda clumsy framework (which is why the first version of this used my personal fave Choo instead), but felt it was good to pick one that more people knew (and could help with).

*** Why Redux?
   [[https://redux.js.org/][Redux]]  provides one global 'state' for the app, and makes React actually usable.  It will help us push the data appropriately to the right parts and keep things clean and efficient.

*** Why Tachyons?
    Tachyons is a css framework for writing functional CSS.  It's a much different approach to CSS, but it's one that matches a unix philosophy and is super easy to spin things up and maintain them.  AS we make changes, we don't have to worry that some class hidden deep in some css file causes our whole site to look weird.  Instead, every class has a single purpose, and you add multiple classes to a site to add-upon and combine each of these classes functions (like piping commands together on the command line).  This makes all our components //reusable// too, as we only need to copy over the code and not any stylesheet attached to the code.
** BACKEND
   For the backend we will be using Feathers //for right now//.  We may find that we want something completely different, or that we want our webui to be able to live in multiple places.  Our goal is for the two to be entirely separate, so either can change if needed.
*** Why Feathers?
    [[https://feathersjs.com/][Feathers]] is a well-designed and well-documented api layer written in Node.  It has good support among my Wellington dev friends, and so I have better help if I encounter any sorta problem.  It also is just really pleasant to use so far, with a good model for how to create different services.  It also has an existing React connector.

* Backend
** Setup
  We can speed up this process by [[https://www.npmjs.com/package/@feathersjs/feathers][installing the feathers module through npm]], then using their ~feathers generate app~.  This will generate a full backend server for us, using their design patterns.
  ===
  ;;within our apisnoop_webui directory...

  npm install -g @feathersjs/cli
  mkdir backend
  cd backend
  feathers generate app
  ===

This will bring you through some prompts, which is why i'm not making it runnable code here.
** Create sample service.
   We want just something basic to make sure we can grab it later with react/redux.  So we'll make one called /cats that has different cats and their CATchphrases.

   We can use feathers for this too, from within the backend directory: ~feathers generate service~
   This will lead you through some prompts to decide what sorta service you want.
* Client
  :PROPERTIES:
  :header-args: :dir ~/Projects/ii/apisnoop_webui/client
  :END:
The client will be all the files that bundle up into a bundle.js file that is called on our index.html page.
** Creation
*** initial react app
    We are going to use the default app style (because we want this to be familiar to others), and luckily there's an npm module to create react apps for us to do just that!
    #+NAME: Create React App
    #+BEGIN_SRC sh :dir ~/Projects/ii/apisnoop_webui :results output
      npx create-react-app client
    #+END_SRC
    #+RESULTS: Create React App
*** dependencies
   We want to add some adaptors for react to use redux //and// feathers //and// tachyons
   #+NAME: install dependencies
   #+BEGIN_SRC sh :results output verbatim drawer
     npm install --save \
         @feathersjs/client \
         feathers-localstorage \
         react-dom \
         react-redux \
         react-router \
         react-router-redux \
         react-router-dom \
         redux \
         redux-saga \
         superagent
   #+END_SRC

   #+RESULTS: install dependencies
   :RESULTS:
   + react-dom@16.5.2
   + react-router@4.3.1
   + feathers-localstorage@3.0.0
   + react-redux@5.0.7
   + redux@4.0.0
   + superagent@4.0.0-beta.5
   + redux-saga@0.16.0
   + react-router-redux@4.0.8
   + @feathersjs/client@3.7.3
   added 11 packages from 11 contributors, updated 5 packages and audited 14613 packages in 12.257s
   found 0 vulnerabilities

   :END:
*** file structure
    Within our client we want to manage our various components, the actions they can call upon, and the reducers that turn all these actions into a single state of the app. These dont' come with the basic react app, so we'll create them.
    We also want to delete any of the default react icons or CSS stuff and move our App.js into a component (cos that's what it is.
    #+BEGIN_SRC sh :results output
      cd src
      rm App.css index.css logo.svg
      mkdir components actions reducers sagas
      mv App.js components
      cd ..
      tree -I 'node_modules'
    #+END_SRC
    #+RESULTS:
    #+begin_example
    .
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   ├── index.html
    │   └── manifest.json
    ├── src
    │   ├── App.test.js
    │   ├── actions
    │   ├── components
    │   │   └── App.js
    │   ├── index.js
    │   ├── reducers
    │   ├── registerServiceWorker.js
    │   └── sagas
    └── yarn.lock

    5 directories, 11 files
    #+end_example
** index.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/index.js
   :END:
   This is the starting point for the full app, in which we initialize React, connect it to redux, start up our store, connect to feathers and all that good stuff.
*** Requirements
    index is really here to spin up react and redux and guide us to the beginning components and store where the real stuff happens.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import React from 'react'
      import {render} from 'react-dom'
      import {Provider} from 'react-redux'

      import App from './components/App'
      import store from './store'
    #+END_SRC
*** Mount to Dom
    Once we have the router setup, we need to mount everything to our index.html file (in our public folder).  This is how javascript can magically render itself as html to whoever's looking at it.
    #+NAME: ReactDOM render
    #+BEGIN_SRC js
      document.addEventListener('DOMContentLoaded', () => {
        render(
            <Provider store={store}>
              <App />
            </ Provider>,
          document.getElementById('root')
        )
      })
    #+END_SRC
** Store
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/store.js
   :END:
 This will store the global state of the app as store.js.  We are using redux for this, which is a wonderful purely functional way of maintaining state.  Because of how it operates, though, it doesn't work well, directly, for API calls and so we will create sagas that handle those calls for us.  So the saga will call our feathers api and give its result to redux as input and redux will reduce this and output our state.
*** Requirements
    #+NAME: requirements
    #+BEGIN_SRC js
      import { createStore, applyMiddleware } from 'redux'
//      import { syncHistoryWithStore } from 'react-router-redux'
//      import { browserHistory } from 'react-router'

      import createSagaMiddleware from 'redux-saga'
      import mySaga from './sagas/sagas'

      import rootReducer from './reducers/index.js'

      import superagent from 'superagent'
      import feathers from '@feathersjs/client'

    #+END_SRC
*** Create Store
    #+NAME: Create Store
    #+BEGIN_SRC js
      const defaultStore = {}

//      const sagaMiddleware = createSagaMiddleware()

      var store = createStore(rootReducer,
                              window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
                             )
      //      const store = createStore(rootReducer, defaultStore, applyMiddleware(sagaMiddleware), window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())
    #+END_SRC
*** Create application
    We'll connect this to our feathers backend which is located at localhost:3030, using the feathers client adaptor.  This can be configured so it works with authentication, with the hooks on each thing (modifying data as it flows through the service), and we'll bring in superagent so the api calls work correctly with redux.
    #+NAME: create application
    #+BEGIN_SRC js :tangle no
      const host = 'http://localhost:3030'
      export const app = feathers()
        .configure(feathers.rest(host).superagent(superagent))
        .configure(feathers.authentication({ store: window.localstorage }))
    #+END_SRC
*** Apply Saga Middleware
    #+NAME: apply saga middleware
    #+BEGIN_SRC js :tangle no
      sagaMiddleware.run(mySaga, app)

    #+END_SRC
*** Make app history sync with browser history
    this is where we again make our app act like it's pure html in the browser, syncing the store's history with the browser's.
    Not sure if this works anymore, with react v.4.0, and so not tangling it.  It'll be good to look into it though.
    #+NAME: history
    #+BEGIN_SRC js :tangle no
    export const history = syncHistoryWithStore(store)
    #+END_SRC
*** export store
    bring it all together so we can access the store and history in our above index.js
    #+NAME: export store
    #+BEGIN_SRC js
   export default store
    #+END_SRC
** Actions
*** actionCreators
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/actions/actionCreators.js
   :END:
    This delivers the content do our reducers.  Actions are just objects with information.
    At the beginning we want to just make sure this all works.  We have an api called /cats so let's work with that!
    #+NAME: action
    #+BEGIN_SRC js
      export function actionCats () {
        return {
          type: 'CATS_REQUESTED'
        }
      }
    #+END_SRC
** Sagas
*** sagas.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/sagas/sagas.js
   :END:
**** requirements
   #+NAME: requirements
   #+BEGIN_SRC js
     import { takeEvery } from 'redux-saga'
     import { fork, call, put } from 'redux-saga/effects'
//     import { browserHistory } from 'react-router'

     import { getCats } from '../services/api'
   #+END_SRC
**** root function
     This'll be the thing exported out that we call upon when we do sagaMiddleware.run(mySaga, app) in our store.js
     We'll define our different sagas that we run...these take actions and make api calls with them.  Since they are asynchronous, we are using the * sign with the function. (this is outta my element, so I'm following a tutorial and need to better understand this syntax.)

     #+NAME: root function
     #+BEGIN_SRC js
       <<cats saga>>
       <<fetch cats>>
       export default function* root(feathersApp) {
         yield [
           fork(catsSaga, feathersApp)
         ]
       }
     #+END_SRC

**** cats saga
  Here is an example saga.  We'll get more complex later, but this shows the general format.  You take everyinstance of an action, send it to a function we define, and connect it with our feathers backend.

  #+NAME: cats saga
  #+BEGIN_SRC js :tangle no
    function* catsSaga (feathersApp) {
      yield* takeEvery('CATS_REQUESTED', fetchCats, feathersApp)
    }
  #+END_SRC

**** fetch cats
     This function calls our getCats function (which we'll define in our services/api) to  our backend and with its yield, sends out a call.
  #+NAME: fetch cats
  #+BEGIN_SRC js :tangle no
    function* fetchCats (feathersApp) {
      const cats = yield call(getCats, feathersApp)
      yield put({type: 'CATS_SUCCEEEDED', cats})
    }
  #+END_SRC

So all in all, we have a general flow for handling asynchronous calls to an api.  Within our app we'll send out an action like 'CATS_REQUESTED'.  Redux isn't ready to handle this yet, since it also just wants cats, ince and simple,  so it can add them to the state and let us display it.  We don't know when the api will respond to our cats request, and so we are in the asynchronous land.

And so to help, we have a saga setup that is listening to all our 'CATS_REQUESTED' actions.  When one comes in, it runs its fetchCats function, which pings our api.  We assume success here (though can build it out so say what happens when there's a failure), and success means we are delivered some nice json.  We can take that object, then, and send //that// to redux.

We do this by announcing we have something to give redux with our action 'CATS_SUCCEEDED', which redux will be setup to listen for, and will take the cats we deliver and add it to state.
** Reducers
*** cats
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/cats.js
   :END:
   #+NAME: cats
   #+BEGIN_SRC js
     function cats (state=[], action) {
       switch(action.type) {
         case 'CATS_SUCCEEDED':
           return action.cats
         default:
           return state
       }
     }
     export default cats
   #+END_SRC
*** index
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/index.js
   :END:
   This one will gather all our other reducers into a single rootReducer, this is the one that gets added to our store in [[*index.js][client/index.js]]

   #+NAME: requirements
   #+BEGIN_SRC js
     import { combineReducers } from 'redux'
     import { routerReducer } from 'react-router-redux'

     import cats from './cats'

   #+END_SRC

   #+NAME: the reducer
   #+BEGIN_SRC js
     const rootReducer = combineReducers({
       cats,
       routing: routerReducer
     })

     export default rootReducer
   #+END_SRC
** Services
   This will handle our api calls, we reference it back in our [[*Sagas][Sagas]]
*** API
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/services/api.js
   :END:
    #+NAME: API
    #+BEGIN_SRC js
      export function getCats (app) {
        const cats = app.service('cats')
        return cats.get().then((cat, err) => cat.cat)
      }
    #+END_SRC
** Components
*** App
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/App.js
    :END:
    There isn't much here since it's really just a wrapper for our main component.  But it sets up that component nicely.
**** Requirements
     #+NAME: Requirements
     #+BEGIN_SRC js
       import React from 'react'
       import { HashRouter, Route } from 'react-router-dom'

       import { bindActionCreators } from 'redux'

       import { connect } from 'react-redux'

       import * as actionCreators from '../actions/actionCreators'
       import Main from './Main'
     #+END_SRC
**** MapStateToProps
     This lets us bring the app's state as properties to the component, in other words as things the html elements know how to display without having to know anything about the data itself.
     #+NAME: MapStateToProps
     #+BEGIN_SRC js
       function mapStateToProps (state) {
         return {
           cats: state.cats
         }
       }
     #+END_SRC

**** MapDispatchToProps
     This lets us call out actions easily (with less this.state.actions.dispatch.action nonsense)
     #+NAME: MapDispatchToProps
     #+BEGIN_SRC js
       function mapDispatchToProps (dispatch) {
         return bindActionCreators(actionCreators, dispatch)
       }
     #+END_SRC

**** The App Component
     #+NAME: App
     #+BEGIN_SRC js
       class App extends React.Component {
         render(){
           return (
           <HashRouter>
             <div>
               <Route exact path='/' component={Main} />
             </div>
           </HashRouter>
           )
         }
       }
       export default connect(mapStateToProps, mapDispatchToProps)(App)
     #+END_SRC
*** Main
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/Main.js
    :END:
**** Requirements
     #+NAME: Requirements
     #+BEGIN_SRC js
       import React, { Component } from 'react'
       import CatList from './CatList'
     #+END_SRC

**** The Main Class
     #+NAME: Main
     #+BEGIN_SRC js
       class Main extends Component {
         render(){
           return(
             <div>
               <h1>This is the Main Component</h1>
             </div>
           )
         }
       }
       export default Main
     #+END_SRC

*** Home
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/Home.js
    :END:
**** Requirements
     #+NAME: Requirements
     #+BEGIN_SRC js
       import React, { Component } from 'react'
       import CatList from './CatList'
     #+END_SRC
**** The Home Class
     #+NAME: Home
     #+BEGIN_SRC js
       class Home extends Component {
         render(){
           return(
             <div>
               <CatList {...this.props}/>
             </div>
           )
         }
       }

       export default Home
     #+END_SRC
*** CatList
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/CatList.js
    :END:
**** Requirements
     #+NAME: Requirements
     #+BEGIN_SRC js
       import React, { Component } from 'react'
       import CatCard from './CatCard'
     #+END_SRC

**** The CatList Class
     #+NAME: Cat
     #+BEGIN_SRC js
       class CatList extends Component {
         constructor(props){
           super(props)

           this.props.actionCats()
         }

         render(){
           return(
               <ul>
               {this.props.cats.map((cat, i) => <CatCard {...this.props} key={i} cat={cat} />)}
             </ul>
           )
         }
       }

       export default CatList
     #+END_SRC

*** CatCard
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/CatCard.js
    :END:
**** Requirements
     #+NAME: Requirements
     #+BEGIN_SRC js
       import React, { Component } from 'react'
     #+END_SRC

**** The CatCard Class
     #+NAME: CatCard
     #+BEGIN_SRC js
       class CatCard extends Component {
         render(){
           const { cat } = this.props
           return (
               <li>
                 <h2>{cat.name}</h2>
                 <em>{cat.catchphrase}</em>
               </li>
           )
         }
       }

         export default CatCard
     #+END_SRC



* TASKS
** TODO Get working React App on top of Feathers, no matter what it looks like.
   This should show up a webpage when we spin up a server using feathers.
** TODO Understand what function* does and yield* does
   It has to do with asynchronous calls in the new es6, but i'm not quite sure what yet.
** TODO Figure out the issue with Browser history.
* Footnotes
** Resources
*** Youtube Tutorial
    I followed [[https://www.youtube.com/watch?v=etq_vv_RVcU&index=2&list=PLN3n1USn4xlnulnnBGD2RMid_p7xVj9xU][This Tutorial]] for a lot of the setup and found it quite useful.
** Outdated
*** Router
    We only have a single page now, but may not forever, so I'm setting up routes from the start.  The Provider makes sure all routes have access to our app store.  The Router says, "Make sure you keep your history wherever you go for the ease of backbuttons and whatnot.  When the app is loaded in general, load the App component.  Then, check where they want to go. If they wanna be on the actual index page, then show them our Home component."
    #+NAME: Router
    #+BEGIN_SRC js

      const router = (
          <Provider store={store}>
          <BrowserRouter>
           <Route exact path="/" component={ App } />
          </BrowserRouter>
          </Provider>
      )

    #+END_SRC
