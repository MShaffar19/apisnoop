#+NAME: APISnoop WebUI
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+PROPERTY: :dir ~/Projects/ii/apisnoop_webui
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)

* Introduction
  This project is a proof of concept for making the web interface of modular and dynamic, by turning it into a React app.  Our current site can be found here:[[https://apisnoop.ii.coop][apisnoop.ii.coop]].  For the first go of this, we want our app to look nearly identical, with the same functionality:
- visual display
- Dropdown to choose between csv's
- Ability to download the audit-log or csv.
** Why Do this?
   The current site is entirely hard-coded html. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new static link.  Not only is this time-consuming, it's error-prone. It's also really hard to maintain.

The site also bears the mark of different hands with different ideas moving quickly to get something 'working' but not pretty.  So the site is using multiple CSS frameworks plus custom CSS and multiple javascript helper utilities.  This also makes the site hard to reason about or design, as you don't know what things you can change and what things are required for the framework.

The current site was the most basic proof of concept. We want to build a whole bunch of things on top of this, including github authorization and site-visitor customizatioin, and the ability to really customize the view you are seeing.  So I want to start again with a foundation to the site that is easier to reason about, easier to maintain, and easier to extend.

* Architecture
The site will be made to have a distinct front-end and backend, with the front-end able to be ported over to any other backend.
The front-end will consist of multiple components that wait to be told what data to display, instead of being written as part of the component.  In this way, if we want to make changes to our 'SIG Tag Bubble', we can just find the component named that and make changes there, instead of trying to find/replace the code within the file.
** FRONTEND
The frontend will be made with React, Redux, maybe Saga, and Tachyons, and Axios
*** Why React?
    [[https://reactjs.org/][React]] is the most well-known and supported front-end framework among my dev friends in Wellington, and is widely used and respected globally.  It was created originally by Facebook and then made open-source.  So it has a tremendous amount of support around it and good video tutorials for learning it.  I find it to be a bulky and kinda clumsy framework (which is why the first version of this used my personal fave Choo instead), but felt it was good to pick one that more people knew (and could help with).

*** Why Redux?
   [[https://redux.js.org/][Redux]]  provides one global 'state' for the app, and makes React actually usable.  It will help us push the data appropriately to the right parts and keep things clean and efficient.

*** AXIOS
   [[https://www.npmjs.com/package/axios][Axios]] is a simple tool for handling http requests across different servers.  We'll need this for the client to be portable, and able to call to multiple API's (our backend plus github for example).
*** Why Saga?
   [[https://redux-saga.js.org/][Saga]] helps us with api calls and redux.  Redux likes pure clean objects sent to the store right away.  API calls don't work like that, and so Saga does the call and then sends the results to Redux.  It's working as a side effect.

*** Why Tachyons?
    Tachyons is a css framework for writing functional CSS.  It's a much different approach to CSS, but it's one that matches a unix philosophy and is super easy to spin things up and maintain them.  AS we make changes, we don't have to worry that some class hidden deep in some css file causes our whole site to look weird.  Instead, every class has a single purpose, and you add multiple classes to a site to add-upon and combine each of these classes functions (like piping commands together on the command line).  This makes all our components //reusable// too, as we only need to copy over the code and not any stylesheet attached to the code.
** BACKEND
   For the backend we will be using Feathers //for right now//.  We may find that we want something completely different, or that we want our webui to be able to live in multiple places.  Our goal is for the two to be entirely separate, so either can change if needed.
*** Why Feathers?
    [[https://feathersjs.com/][Feathers]] is a well-designed and well-documented api layer written in Node.  It has good support among my Wellington dev friends, and so I have better help if I encounter any sorta problem.  It also is just really pleasant to use so far, with a good model for how to create different services.  It also has an existing React connector.

* Process
** Tutorials
   I am going through some simple tutorials for connecting react to redux to feathers.  It's a slightly longer process, but it's going to set me up better for maintaining apisnoop.  My assumption is that this is not a one-and-done thing.  We will be continually adding features to apisnoop and these features will become increasingly more complex. In addition, we'll be needing to adapt apisnoop for different scenarios. So I want to understand the stack for our webapp entirely.

I am coming in with good html and css knowledge for building personal projects.  What we are building is a production level app.  No matter how simple we make it, we will be pinging different sites, manipulating the data within those sites, and then displaying visualizations of our manipulations.  There isn't really a way to do this casually.  Especially if we want it to be stury and testable.  So I am biting off the sizable task of 'build a full-stack production-ready app by myself'.  I want to have all the tools I can to do this.

So I am going to make a v. simple fullstack app and then add in our own customizations until we get to the point where I can hear a task and know exactly how to realize it in this code.
** Priorities
   Ordered by priority.
*** IN-PROGRESS Fully Understand the Tech Stack in which our modular apisnoop is built
*** TODO Integrate our existing D3 visualization into that stack.
*** TODO integrate Katherine's Code into this stack.
*** TODO Add user agent filtering to our sunburst.

* Backend
** Setup
  We can speed up this process by [[https://www.npmjs.com/package/@feathersjs/feathers][installing the feathers module through npm]], then using their ~feathers generate app~.  This will generate a full backend server for us, using their design patterns.
  ===
  ;;within our apisnoop_webui directory...

  npm install -g @feathersjs/cli
  mkdir backend
  cd backend
  feathers generate app
  ===

This will bring you through some prompts, which is why i'm not making it runnable code here.
*** Mongodb
    you'll need a working version of mongodb and to have the server up and running, as outlined here: https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/
** Create sample service.
   We want just something basic to make sure we can grab it later with react/redux.  So we'll make one called /cats that has different cats and their CATchphrases.

   We can use feathers for this too, from within the backend directory: ~feathers generate service~
   This will lead you through some prompts to decide what sorta service you want.
*** Change mongoose.js
    this is just a part of our tutorial, but you need to add mongoose's new url parser to get it to load correctly.  it's cos of an update i guess.
    #+NAME: Mongoose.js
    #+BEGIN_SRC js :tangle ~/Projects/ii/apisnoop_webui/backend/src/mongoose.js
      const mongoose = require('mongoose');

      module.exports = function (app) {
        mongoose.connect(app.get('mongodb'), { useNewUrlParser: true });
        mongoose.Promise = global.Promise;

        app.set('mongooseClient', mongoose);
      };
    #+END_SRC
** Config
   This folder holds the settings for the entire backend.  When you add a new service, it's configurable values get added into here too.

   You can also set separate production and dev configs, which is useful for changing the host name or other settings as needed!
*** Default.json
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/config/default.json
    :END:

    #+NAME: default.json
    #+BEGIN_SRC json
      {
        "host": "localhost",
        "port": 3030,
        "public": "../public/",
        "paginate": {
          "default": 50,
          "max": 50
        },
        "nedb": "../data",
        "mongodb": "mongodb://localhost:27017/backend"
      }
    #+END_SRC
*** Production.json
** Services
*** Contact
    This is a dummy service meant to follow a tutorial.  It'll be erased later, but the process is good for discovery.

   When you create a new service with feathers it makes a bunch of files automatically for you: config files, test files, models for the service and so on.  Many of these work by deefault, but you can also adjust them as needed.
**** Config
** Models
   The models are made automatically when you generate a new service too, and are sort of service specific configurations.  These can also be edited as needed.
*** Contact Model
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/src/models/contact.model.js
    :END:

This is the beginning model, that was made automatically.
    #+BEGIN_SRC js :tangle no
      // contact-model.js - A mongoose model
      //
      // See http://mongoosejs.com/docs/models.html
      // for more of what you can do here.
      module.exports = function (app) {
        const mongooseClient = app.get('mongooseClient');
        const { Schema } = mongooseClient;
        const contact = new Schema({
          text: { type: String, required: true }
        }, {
          timestamps: true
        });

        return mongooseClient.model('contact', contact);
      };
    #+END_SRC
Then we essentially alter the schema, so it has the right columns and data for our sample.
    #+BEGIN_SRC js
      // backend/src/models/contact.model.js zach!

      require('mongoose-type-email');

      module.exports = function (app) {
        const mongooseClient = app.get('mongooseClient');
        const contact = new mongooseClient.Schema({
          name : {
            first: {
              type: String,
              required: [true, 'First Name is required']
            },
            last: {
              type: String,
              required: false
            }
          },
          email : {
            type: mongooseClient.SchemaTypes.Email,
            required: [true, 'Email is required']
          },
          phone : {
            type: String,
            required: [true, 'Phone is required'],
            validate: {
              validator: function(v) {
                return /^\+(?:[0-9] ?){6,14}[0-9]$/.test(v);
              },
              message: '{VALUE} is not a valid international phone number!'
            }
          },
          createdAt: { type: Date, 'default': Date.now },
          updatedAt: { type: Date, 'default': Date.now }
        });

        return mongooseClient.model('contact', contact);
      };
    #+END_SRC
** Test
Also created by feathers by default (I love feathers).  Every new service you add gets a new test.
*** Services
**** Contact
     :PROPERTIES:
     :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/backend/test/services/contact.test.js
     :END:

     By default our test looks like this:
     #+NAME: default test
     #+BEGIN_SRC js :tangle no
       const assert = require('assert');
       const app = require('../../src/app');

       describe('\'contact\' service', () => {
         it('registered the service', () => {
           const service = app.service('contacts');

           assert.ok(service, 'Registered the service');
         });
       });
     #+END_SRC

     Our change is minimal, ~~app.service('contacts')~ becomes ~~app.service('contact')~~
     and we make 'Registered the service' lowercase.
     #+NAME: contact.test.js
     #+BEGIN_SRC js
       const assert = require('assert');
       const app = require('../../src/app');

       describe('\'contact\' service', () => {
         it('registered the service', () => {
           const service = app.service('contact');

           assert.ok(service, 'registered the service');
         });
       });
     #+END_SRC
*** Testing everything
    :PROPERTIES:
    :header-args: :dir ~/Projects/ii/apisnoop_webui/backend :results output verbatim drawer
    :END:

    With yr tests configured you can run them all in the terminal.
    #+NAME: test everything
    #+BEGIN_SRC shell
      yarn test
    #+END_SRC

    #+RESULTS: test everything
    :RESULTS:
    :END:

* Client
  :PROPERTIES:
  :header-args: :dir ~/Projects/ii/apisnoop_webui/client
  :END:
  The client will be all the files that bundle up into a bundle.js file that is called on our index.html page.
** Creation
*** initial react app
    We are going to use the default app style (because we want this to be familiar to others), and luckily there's an npm module to create react apps for us to do just that!
    #+NAME: Create React App
    #+BEGIN_SRC sh :dir ~/Projects/ii/apisnoop_webui :results output
      npx create-react-app client
    #+END_SRC
    #+RESULTS: Create React App
*** dependencies
   We want to add some adaptors for react to use redux //and// feathers //and// tachyons
   #+NAME: install dependencies
   #+BEGIN_SRC sh :results output verbatim drawer
     npm install --save \
         @feathersjs/client \
         feathers-localstorage \
         feathers-redux \
         react-dom \
         react-redux \
         react-router \
         react-router-redux \
         react-router-dom \
         redux \
         redux-thunk \
         redux-devtools-extension \
         redux-saga \
         superagent
   #+END_SRC

   #+RESULTS: install dependencies
   :RESULTS:
   + react-dom@16.5.2
   + react-router@4.3.1
   + feathers-localstorage@3.0.0
   + react-redux@5.0.7
   + redux@4.0.0
   + superagent@4.0.0-beta.5
   + redux-saga@0.16.0
   + react-router-redux@4.0.8
   + @feathersjs/client@3.7.3
   added 11 packages from 11 contributors, updated 5 packages and audited 14613 packages in 12.257s
   found 0 vulnerabilities

   :END:
*** file structure
    Within our client we want to manage our various components, the actions they can call upon, and the reducers that turn all these actions into a single state of the app. These dont' come with the basic react app, so we'll create them.
    We also want to delete any of the default react icons or CSS stuff and move our App.js into a component (cos that's what it is.
    #+BEGIN_SRC sh :results output
      cd src
      rm App.css index.css logo.svg
      mkdir components actions reducers sagas
      mv App.js components
      cd ..
      tree -I 'node_modules'
    #+END_SRC
    #+RESULTS:
    #+begin_example
    .
    ├── README.md
    ├── package-lock.json
    ├── package.json
    ├── public
    │   ├── favicon.ico
    │   ├── index.html
    │   └── manifest.json
    ├── src
    │   ├── App.test.js
    │   ├── actions
    │   ├── components
    │   │   └── App.js
    │   ├── index.js
    │   ├── reducers
    │   ├── registerServiceWorker.js
    │   └── sagas
    └── yarn.lock

    5 directories, 11 files
    #+end_example
** Adding Tachyons
   We want to bring tachyons right into our app, installing it through node.  This way we have full access to the css library without relying on outside links and this library is as up-to-date as possible(or rather, v. easy to stay up to date.)  I am following the guide for react that tachyons listed[[https://github.com/tachyons-css/tachyons-and-react][ on their github page.]]
*** Install Tachyons and Sheetify
    I wont' be using sheetify right now, but the goal is to use it upon a refactor (when we've moved away from webpack to browseriy)
    #+NAME: Install Tachyons
    #+BEGIN_SRC shell :dir ~/Projects/ii/apisnoop_webui/client :results output verbatim drawer
      npm install --save tachyons tachyons-cli sheetify
    #+END_SRC

    #+RESULTS: Install Tachyons
    :RESULTS:
    + tachyons-cli@1.3.2
    + tachyons@4.11.1
    + sheetify@7.3.3
    added 31 packages from 18 contributors, updated 2 packages, moved 3 packages and audited 20856 packages in 29.843s
    found 1 low severity vulnerability
      run `npm audit fix` to fix them, or `npm audit` for details
    :END:
*** Find Home for CSS
    #+NAME: Find Home for CSS
    #+BEGIN_SRC shell :dir ~/Projects/ii/apisnoop_webui/client/src :results output verbatim drawer
      mkdir css
      echo '@import "tachyons"' > css/app.css
      tree css
    #+END_SRC

    #+RESULTS: Find Home for CSS
    :RESULTS:
    css
    └── app.css

    0 directories, 1 file
    :END:
*** Add CSS scripts
I'll add a couple additions to our package.json (this is best outlined in the github link)

** index.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/index.js
   :END:
   This is the starting point for the full app, in which we initialize React, connect it to redux, start up our store, connect to feathers and all that good stuff.
*** Requirements
    index is really here to spin up react and redux and guide us to the beginning components and store where the real stuff happens. BrowserRouter is brought in so that clicking on different navlinks in our App component will work like url's on a standard webpage.


    #+NAME: Requirements for just React
    #+BEGIN_SRC js
      import React from 'react'
      import ReactDOM from 'react-dom'
      import { BrowserRouter } from 'react-router-dom'
      import './index.css'

      import {Provider} from 'react-redux'

      import App from './components/App'
    #+END_SRC



WITH redux, we bring in a store that holds the global state of the app as one big object to parse over.  So we bring that in now too
    #+NAME: import store
    #+BEGIN_SRC js
      import store from './store'
    #+END_SRC
*** React Only index page
    Once we have the router setup, we need to mount everything to our index.html file (in our public folder).  This is how javascript can magically render itself as html to whoever's looking at it.

    However, there is no data yet, it needs to be provided by the store.  Meaning, we need to wrap everything inside a Provider tag, and that provider tag to bring along the store.

So this is what it looks like before:
    #+NAME: ReactDOM render
    #+BEGIN_SRC js :tangle no
      ReactDOM.render(
          <BrowserRouter>
          <App />
          </BrowserRouter>,
        document.getElementById('root')
      )
    #+END_SRC
*** React and Redux index
    big difference is the provider tag which brings in the store we are importing from store.js
    #+NAME: React and Redux index
    #+BEGIN_SRC js
      ReactDOM.render(
          <BrowserRouter>
          <Provider store={store}>
            <App />
          </Provider>
          </BrowserRouter>,
        document.getElementById('root')
      )
    #+END_SRC

** Components
*** App
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/App.js
    :END:
**** Introduction
      The starting place for our whole front-end.  Right now it is light, and based on the sitepoint tutorial.

     The app component is often seen as the 'layout template' for the entire single page app (as said by Wes Bos) and so it is meant to handle the navigation and the routes that determine which components we show.

  The entire app will actually take place on the index.html page, but will render different views dynamically.  These views can be shared by their URL's, so it's like we have a deep webpage of thangs--but really it's a continually transforming bit of javascript code.

  our original app component looked like this.
      #+NAME: Original App Component
      #+BEGIN_SRC js :tangle no
        import React, { Component } from 'react'

        class App extends Component {
          render(){
            return (
                <div>
                <h1>APISNOOP/Contact Manager</h1>
                <h2>ignore these words for now, they are just proof that this works.</h2>
                </div>
            )
          }
        }

        export default App
      #+END_SRC

  Let's deep dive into how it'll look now, as this is a structure that we'll see in a bunch of React apps.

**** Requirements

We'll start with the classic requirement: react and the Component class.
  #+NAME: Import React
  #+BEGIN_SRC js
    import React, { Component } from 'react'
  #+END_SRC

Next, we'll bring in react's smart navigation.  These are what make the app appear to be multiple pages.

#+NAME: import routing and navigation
#+BEGIN_SRC js
  import { NavLink, Route } from 'react-router-dom'
#+END_SRC

Lastly, we bring in our different pages, which we can navigate between using a nice lil' tab and navlinks..

#+NAME: import components
#+BEGIN_SRC js
  import Header from './Header'
  import ContactListPage from '../pages/contact-list-page'
  import ContactFormPage from '../pages/contact-form-page'
#+END_SRC

**** The overall Layout
     The general shape of this template is here:
     #+NAME: App Layout
     #+BEGIN_SRC js
       class App extends Component {
         render(){
           return (
             <div id='app'>
               <Header />
               <<Nav Links>>
               <<Routes>>
             </div>
           )
         }
       }

       export default App
     #+END_SRC



**** the Navlinks
     the navlinks will be visual components that act like standard links;  exact to acts like href.
     #+NAME: Nav Links
     #+BEGIN_SRC js :tangle no
       <div id='nav'>
        <NavLink exact to='/'>Contacts List</NavLink>
        <NavLink exact to='/contacts/new'>Add a Contact</NavLink>
       </div>
     #+END_SRC
**** the Routes
     The routes listen to the paths chosen by nav and routes to the correct component.  So the components don't show unless the url path matches their route.
     #+NAME: Routes
     #+BEGIN_SRC js :tangle no
         <Route exact path='/' component={ContactListPage} />
         <Route path='/contacts/new' component={ContactFormPage} />
         <Route path='/contacts/edit/:_id' component={ContactFormPage} />
     #+END_SRC

*** Contact Form
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/contact-form.js
    :END:

    We're going to add form validation for this, to make sure it can fit in our backend database correctly.

**** Requirements
     We're using React for the component, and redux-form for the form submission and validation.

       #+NAME: Requirements
       #+BEGIN_SRC js
         import React, { Component } from 'react'
         import { Field, reduxForm } from 'redux-form'
         import classnames from 'classnames'
       #+END_SRC
**** Basic Layout
     Forms are tricky with client-side apps, as forms like to ping a server and live somewhere there.  In a traditional model, you'd have the form do a post request to the server and redirect to a success page.  But here, we are wanting to post to another area in this client-side app, and so within the browser and not the server. Which is to say that we need to set this up with a couple wrappers so this works properly.

This is essentially some React Redux weirdness conventions.  It is possible that there are now better ways to do this then I am aware, and when I learn of them I'll come back to update this.  But for now, here is a sturdy way in which to handle forms with react and redux.

     The layout will create a new react Component for our form, and this component will have an included Function for what each form field should look like.

Then, in the main component page, we'll create each field using the redux-form Field component, and say that it renders itself using that field function we described up above.  In other words we say, "Give us a field component that will bundle up the data nice to work with redux but for styling, have it look like this subcomponent we described elsewhere."  So we are not defining what Field does, it comes pre-made from redux-form, and it does some good data cleanup and manipulation automatically so that this page works well with redux.  The actual presentation of the component is handled in our renderField function/sub-component.

Lastly, we export it wrapped up in reduxForm, similar to how we connected the component to our redux state in the contact-list.  This means we have all the properties and power of redux form whenever this component is called.

And so, the whole thing is structured like so.

       #+NAME: contact-form layout
       #+BEGIN_SRC js
         class ContactForm extends Component {
         <<renderField sub-component>>
           render(){
             <<setup Props>>
             return (
             <<ContactForm Component>>
             )
           }
         }
        <<Export with reduxForm>>
       #+END_SRC

**** the renderField sub-component
     React Components let you declare component specific functions that you call like so ~this.functionName~.  You don't need to declare them as a variable like usual.

So we are saying our contactForm has a function within it called renderField.  It takes a number of arguments, kept up nice in an object.  Then, we render a component with different wildcards represented by those arguments.  So we can put the basic structure in, and let each one be different based on the props that our contactFrom passes to it (its label, its type, etc.)

       #+NAME: renderField sub-component
       #+BEGIN_SRC js :tangle no
         renderField = ({ input , label, type, meta: {touched, error} }) => (
             <div className={classnames('mt3', {error:touched && error})}>
             <label className='db fw6 1h-copy f6' for={label}>
               {label}
             </label>
             <input className='pa2 input-reset ba bg-transparent
                               hover-bg-black hover-white w-100'
                    {...input}
                    type={type}
                    placeholder={label}>
             </input>
             {touched && error && <span className='error'>{error.message}</span>}
             </div>

         )
       #+END_SRC

The {...input} section is kinda neat.  It's a destructured object, and so {input} is equal to {input: input}.  This goes one more and does it as a spread operator.  So now it's saying {input: whatever the current input is plus what you about to put in}.  This is what lets us enter text, and the component records each letter as you type it in as the input.  Without this if I were to type 'hello', then the component would say the input was 'o', as it just kept the last letter we entered.  Now, the input is 'h'+'e'+'l'+'l'+'o'; so it works properly even in this new weird shadowDOM react world.

**** The Contact Form Component
     Now we can set up our main component.  First, we do some tricky laziness.  We define a bunch of variables, based on the variables brought in by this.props.
        #+NAME: setup Props
        #+BEGIN_SRC js :tangle no
          const {handleSubmit, submitting, loading  } = this.props
        #+END_SRC

     The whole point of this is now we can call handleSubmit with just 'handleSubmit' instead of 'this.props.handleSubmit'.  V fancy, v. lazy.

     Now, we set up the contactForm.  It has a nice basic structure, since we render the field component elsewhere.  As you can see it's a form that, onSubmit calls our handleSubmit function.  It's made up of four fields and a submit button.

These four fields have names that correspond to the data structure we wanna pass in our object.  This is set up just like our current contactStore object. HANDY!

        #+NAME: ContactForm Component
        #+BEGIN_SRC js :tangle no
          <main className='pa4 black-80'>
          <form className='measure center' onSubmit={handleSubmit} loading={loading}>
          <fieldset id='add_new_contact' className='ba b--transparent ph0 mh0'>
            <legend className='f4 fw6 ph0 mh0'>Add New Contact</legend>
            <Field name='name.first' type='text' component={this.renderField} label='First Name' />
            <Field name='name.last' type='text' component={this.renderField} label='Last Name' />
            <Field name='phone' type='text' component={this.renderField} label='Phone' />
            <Field name='email' type='text' component={this.renderField} label='email' />
          </fieldset>
          <div>
            <input className='b ph3 pv2 input-reset ba b--black
                              bg-transparent grow pointer f6 dib'
                  type='submit'
                  value='Add Contact'
                  disabled={submitting}>
            </input>
          </div>
          </form>
          </main>
        #+END_SRC

        #+RESULTS: ContactForm Component

**** Exporting it with Redux Form.
     The last bit is to just export this whole component, but connected to redux-form.  It's the same structure as connect in our contactList, but we say that we are adding to our 'form' store a new form called 'contact'.

        #+NAME: Export with reduxForm
        #+BEGIN_SRC js :tangle no
           export default reduxForm({form: 'contact'})(ContactForm)
        #+END_SRC





 We can define tiny components within components and pass along the proper fields to them as props.  So we are going to create a specific component for each of our fields, and set it to the variable 'renderField'.

 #+NAME: define form field component
 #+BEGIN_SRC js :tangle no
   renderField = ({ input, label, type, meta: {touched, error } }) => (
         <div class="measure">
       <label for={label} class="f6 b db mb2">{name}</label>
       <input id={name} class="input-reset ba b--black-20 pa2 mb2 db w-100" type={type} aria-describedby="name-desc" placeholder={label}>
         <small id=`${{name}}-desc` class="f6 black-60 db mb2">Helper text for the form control.</small>
         </div>
   )
 #+END_SRC
*** Contact List
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/contact-list.js
    :END:
    This list is purely presentational, and so does not need to be a full stateful component (meaning it doesn't need to have its own, component specific state that it manages, it just needs to present the application's state).  We pass it contacts from our ContactListPage, which it is getting from our global state.  So there's a pattern where this component doesn't care about what inside it, it just needs to have a space for the data we give it to land.

**** Simple Version
    #+NAME: contact-list
    #+BEGIN_SRC js :tangle no
      import React from 'react'

      export default function ContactList ({contacts}) {

  <<make a list of contacts>>

        return (
            <div>
              <ul>
                { list() }
              </ul>
            </div>
        )
      }
    #+END_SRC
**** Card Component Version
    #+NAME: contact-list
    #+BEGIN_SRC js
      import React from 'react'
      import ContactCard from './contact-card'

      export default function ContactList ({contacts}) {

        const cards = () => {
          return contacts.map(contact => {
            return (
                <ContactCard key={contact._id} contact={contact} />
            )
          })
        }
        return (
            <div>
              <div className ='flex-row flex-wrap'>
                { cards() }
              </div>
            </div>
        )
      }
    #+END_SRC

    #+RESULTS: contact-list

The contact form is rendering its list inside the <ul>  the list can also be a react component, and we can use the data that's passed along to make it meaningful.

Since we know the contacts are an array, we can map over the array.  And for each item in that we'll return a <li> item holding it's information.

#+NAME: make a list of contacts
#+BEGIN_SRC js :tangle no
  var list = () => {
    return contacts.map(contact => {
      return (
          <li key={contact._id}>{contact.name.first} {contact.name.last}</li>
      )
    })
  }

#+END_SRC
But we can also make an external component that is being return, instead of hardcoding the list item.  So we can make that as design complex as we want using tachyons. So for example, we'll make a contact card that is a box with big font for the name and a button to edit or delete.
*** Contact Card
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/contact-card.js
    :END:
    This is what goes in the contact list. Since we are using tachyons, we can literally just copy and paste their starting components from their webpage, and then customize this by adjusting the classnames only.  We don't need to worry about maintaining a stylesheet.  We'll use their[[http://tachyons.io/components/cards/basic-text-card/index.html][ card]] and [[http://tachyons.io/components/buttons/basic-rounded-extra-small/index.html#0][button]] as our starters.
    #+NAME: contact card
    #+BEGIN_SRC js
      import React from 'react'

      export default function ContactCard({contact, deleteContact}) {
        return (
            <article class="center mw5 mw6-ns hidden ba mv4">
            <h1 class="f4 bg-near-black white mv0 pv2 ph3">{contact.name.first} {contact.name.last}</h1>
            <div class="pa3 bt">
            <p class="f6 f5-ns lh-copy measure mv0">
              {contact.phone} ||| {contact.email}
            </p>
            <a class="f6 link dim br1 ba ph3 pv2 mb2 dib dark-green" href="#0">Edit</a>
            <a class="f6 link dim br1 ba ph3 pv2 mb2 dib dark-pink" href="#0">Delete</a>
            </div>
            </article>
        )
      }
    #+END_SRC
*** Header
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/Header.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <header className='flex-row items-center justify-start bg-moon-gray black shadow-4'>
            <h1 className='pa2'>APISnoop</h1>
          </header>
      )
    #+END_SRC
** Pages
   This is a format i haven't seen before, but present in Wes Bos' tutorial, but seems useful for routing.  Our top level containers, or components, are under our Pages directory.
*** Contact List Page
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/pages/contact-list-page.js
    :END:
**** React Only
 Slightly different from contact-list, in that it is now a class extending our react component.  I'm curious how we imported react in our contact-list component but didn't actually use it. I believe it's because we are calling it within this render function here.

In this state, it can render what we want, but it has nothing to show.  The contact list is empty.  It needs data that'll be provided by redux.

     #+NAME: contact-list-page, react only
     #+BEGIN_SRC js :tangle no
       import React, { Component } from 'react'
       import ContactList from '../components/contact-list'


       class ContactListPage extends Component {
         render(){
           return(
               <div>
                 <h1>List of Contacts</h1>
                 <ContactList />
               </div>
           )
         }
       }

       export default ContactListPage
     #+END_SRC
**** React-Redux
     We'll bring in a new module to connect react to redux called, naturally, 'connect'.  Then we'll bring in our fetchContacts action, which we've coded to grab our contact list and add it to our state.

     #+NAME: contact-list-page, reduxified
     #+BEGIN_SRC js
       import React, { Component } from 'react'
       import { connect } from 'react-redux'

       import ContactList from '../components/contact-list'
       import { fetchContacts } from '../actions/contact-actions'

       class ContactListPage extends Component {


       <<componentDidMount action>>

         render(){
           return(
               <div>
                 <h1>List of Contacts</h1>
               <ContactList contacts={this.props.contacts}/>
               </div>
           )
         }
       }

       <<map state to props>>
       <<export connected component>>
     #+END_SRC

   There's a new function in our class that is a common one for react components, and is related to the[[https://reactjs.org/docs/state-and-lifecycle.html][ React Lifecycle]].  We only want to concern ourselves with components when they actually on the page.  If they aren't needed yet, their various data and functions aren't needed either.  This'll help keep the resources we are asking from the browser relatively low.

And so with this contact list, for example, we only make a call to grab data from state when this component is displayed on the page, or said another way 'mounted to the DOM'.  the React Component class has these types of functions built in, that check what stage of the lifecycle of the component we in and calls that lifecycle's functions appropriately.

And so, when the component Did Mount, fetch our contacts from our store and add it to the application's state.

#+NAME: componentDidMount action
#+BEGIN_SRC js :tangle no
  componentDidMount() {
    this.props.fetchContacts()
  }
#+END_SRC

There's a strange thing to how we called fetchContacts, writing it as this.props... Why?

It's due to how react works with the browser, and the big illusion it's pulling. The component is all javascript code pretending to be html elements.  And like html elements it can have properties or props--like 'onclick' or 'title' or what-have-you.  But in React the props can be full javascript functions and the entirety of the state.  This is the power of Redux, it allows you to have fairly simple presentational components of redux, that suddenly are filled with complex info and interactions from the larger application.

To do this though, we need to map the state (or the parts of the state we care about) to the components properties, and connect the imported action as a prop to the component too.

We map state to props with a function:

#+NAME: map state to props
#+BEGIN_SRC js :tangle no
 function mapStateToProps (state) {
    return {
      contacts: state.contactStore.contacts
    }
  }
#+END_SRC

So this function is expecting state, and for state to have a contactstore object.  If that part is true, it'll map that object to the component's props under this.props.contacts.  To get the proper state to be mapped to, we 'connect' our component to redux's store, referencing this map function and our fetchContacts function....and then export the connected component.

#+NAME: export connected component
#+BEGIN_SRC js :tangle no
  export default connect(mapStateToProps, {fetchContacts})(ContactListPage)
#+END_SRC

Any component that needs to be aware of our app's state will be written in this way.

*** Contact Form Page
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/pages/contact-form-page.js
    :END:
**** Requirements
    With our contact form component made, we can add it into a contact page.  This page wants to also know what to do once the form is sent--what to do in case of success, and errors, and how to send out the form to the reducer.  So we will import the correct parts from react and redux to handle the redirects and forms, and bring in the submission actions we created in our contact-actions.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import React, { Component } from 'react'
      import { Redirect } from 'react-router'
      import { SubmissionError } from 'redux-form'
      import { connect } from 'react-redux'

      import { newContact, saveContact } from '../actions/contact-actions'
      import ContactForm from '../components/contact-form'
    #+END_SRC
**** Basic Layout
     We start up a new 'stateful' component, meaning it has a state specific to itself. The rest of the app doesn't need to know when the contact form wants to redirect.  Only the contact form really cares about that.  So we make it stateful.

Then, we run a function for once the component has mounted to the dom, render the component, and do our cool 'mapStateToProps' jam, so the application's state is available to this component as properties it can render.

    #+NAME: Basic Layout
    #+BEGIN_SRC js

      class ContactFormPage extends Component {

        state = {
          redirect: false
        }
        <<Component Did Mount>>
        <<Define Submit Function>>

        <<Render Component>>
      }
        <<Map State To Props>>

      export default connect(mapStateToProps,{newContact, saveContact})(ContactFormPage)
    #+END_SRC

**** Component Did Mount

     #+NAME: Component Did Mount
     #+BEGIN_SRC js :tangle no
       componentDidMount () {
         this.props.newContact()
       }
     #+END_SRC

**** Define Submit Function

     This calls our savecontact action and then waits for the response.   If it's a success, we'll redirect to our contacts page.  If it's an error, we'll explain why.
     #+NAME: Define Submit Function
     #+BEGIN_SRC js :tangle no
       submit = (contact) => {
         return this.props.saveContact(contact)
           .then(response => this.setState({ redirect:true }))
           .catch(err => {
             throw new SubmissionError(this.props.errors)
           })
       }
     #+END_SRC
     For the setState--since we have 'this' in front it means 'set //this// component's state.  not the global state.'

**** Render Component
     Here we manage the redirect.  It's saying 'if redirect is true, then redirect to our homepage, else show this component'.  It's doing this using a[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator][ Ternary Operator.]]
     #+NAME: Render Component
     #+BEGIN_SRC js :tangle no
       render() {
         return (
             <div>
             {
               this.state.redirect ?
                 <Redirect to='/' /> :
                 <ContactForm contact={this.props.contact} loading={this.props.loading} onSubmit={this.submit} />
             }
             </div>
         )
       }
     #+END_SRC
**** Map State to Props
     #+NAME: Map State To Props
     #+BEGIN_SRC js :tangle no
       function mapStateToProps (state) {
         return {
           contact: state.contactStore.contact,
           errors: state.contactStore.errors
         }
       }
     #+END_SRC

** Contact Data
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/contact-data.js
   :END:
   This is just creating a basic json object that we'll feed into redux and this will ulimately be added into our db on our backend.
   #+NAME: Contact Data
   #+BEGIN_SRC js
     export const contacts = [
       {
         _id: "1",
         name : {
           first: "John",
           last: "Doe"
         },
         phone: "555",
         email: "john@gmail.com"
       },
       {
         _id: "2",
         name : {
           first: "Bruce",
           last: "Wayne"
         },
         phone: "777",
         email: "bruce.wayne@gmail.com"
       }
     ]
   #+END_SRC

** Store
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/store.js
   :END:
   :LOGBOOK:
   - Note taken on [2018-09-26 Wed 16:35] \\
     I want to be using Saga, ultimately, but I think I'm shooting too far iwth it.  First goal is to just get react talking to feathers.
   :END:
 This will store the global state of the app as store.js.  We are using redux for this, which is a wonderful purely functional way of maintaining state.  Because of how it operates, though, it doesn't work well, directly, for API calls and so we will create sagas that handle those calls for us.  So the saga will call our feathers api and give its result to redux as input and redux will reduce this and output our state.
*** Requirements
      #+NAME: requirements
      #+BEGIN_SRC js
        import { createStore, applyMiddleware } from 'redux'
        import thunk from 'redux-thunk'
        import promise from 'redux-promise-middleware'
        import { composeWithDevTools } from 'redux-devtools-extension'
        import rootReducer from './reducers'
      #+END_SRC
*** Apply Middleware
    As we want to use feathers and external servers, we need to have some middleware put into place to wrap up our actions so they can be received by redux properly.  This is the purpose of ~thunk~ and ~promiseMiddleware~.  This keeps redux and react happy, able to render a webpage even before there's data, essentially.

    #+NAME: apply middleware
    #+BEGIN_SRC js
      const middleware = composeWithDevTools(applyMiddleware(promise(), thunk))
    #+END_SRC
*** Create and Export Store
    #+NAME: createStore
    #+BEGIN_SRC js
      export default createStore(rootReducer, middleware)
    #+END_SRC
** Actions
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/index.js
    :END:
    We'll use the index page of the actions to set up our axios client.  axios handles our fetch requests, since we'll be fetching from another server and not from a data file within this app.  Axios is an http request client that uses promises (a new javascript convention for handling asynchronous calls).[[https://www.npmjs.com/package/axios][ Axios page on NPM]]

    We'll want to configure a client app for axios, that sets the host we are trying to connect to and the type of information we are expecting to get.  Since we are working with a feathers api, then we know we just need to grab JSON.
    #+BEGIN_SRC js
      import axios from 'axios'

      export const client = axios.create({
        baseURL: "http://localhost:3030",
        headers: {
          "Content-Type": "application/json"
        }
      })
    #+END_SRC
   These work with redux to deliver our store an object that has a 'type' and a payload.  So the type tells our store reducers what to do with it, and the payload is the data that is being added to the global state.

*** Contact Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/contact-actions.js
    :END:
**** Requirements
    We are going to ping our feathers database to grab our contacts.  We've set up an axios client (in index.js) to handle these types of requests, so we'll bring it in, and use the client to grab data.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

      const url = '/contacts'

    #+END_SRC
**** Fetching Contacts
      The dispatch is being used so our redux stores can hear an action took place.  So we are sending out a broadcast(dispatch) that says 'FETCH CONTACTS HAPPENED!' and we're bringing with it a payload.  Redux will hear this action, and assign the payload to the correct part of the app's state.

      :PROPERTIES:
      :header-args: :noweb yes :tangle ./client/src/actions/contact-actions.js
      :END:
      #+NAME: contact-actions.js
      #+BEGIN_SRC js

        export function fetchContacts () {
          return dispatch => {
            dispatch({
              type: 'FETCH_CONTACTS',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC

  When this is pinged it'll create a few new type of actions:
    + 'FETCH_CONTACTS_PENDING'
    + 'FETCH_CONTACTS_FULFILLED'
    + 'FETCH_CONTACTS_REJECTED'

  This is done automatically, and so we don't need to create action creators for these various actions, we just need to tell our reducer to listen to the 'FETCH_CONTACTS_FULFILLED' action and handle the payload appropriately.

**** New Contact
     This action will end up being called when our contact form page mounts.  In other words, when someone clicks our 'add contact' list, we going to announce to the whole app 'New Contact coming!'
     #+NAME: newcontact
     #+BEGIN_SRC js

       export function newContact () {
         return dispatch => {
           dispatch({
           type: 'NEW_CONTACT'
           })
         }
       }
     #+END_SRC

**** Save Contact
     This will be called when we submit the form, and the data will be sent to our server and come back, hopefully, fulfilled.  It's similar to fetching contacts up above, in that we'll use axios and get 'SAVE_CONTACTS_PENDING' and '_FULFILLED' and '_REJECTED' to go along with this.
     #+NAME: Save Contact
     #+BEGIN_SRC js
       export function saveContact (contact) {
         return dispatch => {
           return dispatch({
             type: 'SAVE_CONTACT',
             payload: client.post(url, contact)
           })
         }
       }
     #+END_SRC

** reducers

   The general logic here is we make different files for the different concerns (like contacts, sigs, apps, and so on), and then these are all combined in our index.js to create a single reducer (which is then added as our app's state).

  It's called a reducer because we are using a reduce function on the array of properties in the various parts of the app, reducing it into a single global state.

*** Contact reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/contact-reducer.js
    :END:
**** Initial State
    We'll first create the initial state for our contact, so we don't get a null error before we have any data.  It'll either be an empty object, or an object filled with good things.  We've added some state to handle new contact entries, so we can store to state the new contact we're working with, and whether we are currently waiting on a response from our server (loading), or whether the data wasn't sent or saved properly (errors).

    #+NAME: default state
    #+BEGIN_SRC js
      const defaultState = {
        contacts: [],
        contact: {name:{}},
        loading: false,
        errors: {}

      }
    #+END_SRC
**** The Contact Reducer

    Then we create our reducer, which listens to different dispatches, takes the payload associated with that dispatch, and adds it to the contact state.  We do this using javascript switch statements[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch][ Mozilla Docs for Switch Statements]].  This lets us handle multiple types of dispatches all gathered around the concern of the app.  In this case, we are concerned wiht contacts, but this could also be Sigs, tests run, apps called, etc.

The basic syntax for switch is you set up a switch object based around some value, in our case what type of action is being sent us.  Then we handle the different 'cases' that could come up.  If none of them come up, we just return the default state.


    #+NAME: contact reducer
    #+BEGIN_SRC js
      export default (state = defaultState, action = {}) => {
        switch (action.type) {
          <<Case: Fetch Contacts>>
          <<Case: New Contact>>
          <<Case: Save Contact Pending>>
          <<Case: Save Contact Fulfilled>>
          <<Case: Save Contact Rejected>>
          default:
            return state;
          }
      }

    #+END_SRC

We use the spread operator for our state (...state) and what this does is takes the entire current state object for contact and adds that in and then to that we add our new action.payload.  This keeps the reducer immutable.  We do not adjust the state, we only replace it.

**** Fetching Contacts

This dispatch comes when a successful call to the server has been fulfilled.  We then take the payload of data given to us and add it to our contacts array.

#+NAME: Case: Fetch Contacts
#+BEGIN_SRC js :tangle no
  case 'FETCH_CONTACTS_FULFILLED': {
    return {
      ...state,
      contacts: action.payload.data.data || action.payload.data // in case pagination is disabled.
    }
  }
#+END_SRC

**** New Contact
     Called when the page loads.  We essentially update the state with an empty object for contact that now has a name value.  I don't think it really does anything more than this, since our newContact action delivers no payload.  This is something to explore a bit more later.

#+NAME: Case: New Contact
#+BEGIN_SRC js :tangle no
  case 'NEW_CONTACT': {
    return {
      ...state,
      contact: {name:{}}
    }
  }
#+END_SRC
**** Save Contact
     These instances come when someone tries to submit a new contact, and so we need to handle a few more cases than just fetch.

for pending, change loading to true.  This lets us set up an if/then for the component we display.
#+NAME: Case Save Contact Pending
#+BEGIN_SRC js :tangle no
  case 'SAVE_CONTACT_PENDING': {
    return {
      ...state,
      loading: true
    }
  }
#+END_SRC


IF it's fulfilled, then update  our contacts store with the new state of our server say we no longer loading.
#+NAME: Case: Save Contact Fulfilled
#+BEGIN_SRC js :tangle no
  case 'SAVE_CONTACT_FULFILLED': {
    return {
      ...state,
      contacts: [...state.contacts, action.payload.data],
      errors: {},
      loading: false
    }
  }
#+END_SRC

If it's rejected, then we want to display the error message for //why// it was rejected.  We want this to be readable english, as it'll be what's displayed in the component in case of errors.  Luckily, feathers error messages are nice and clear!
#+NAME: Case: Save Contact Rejected
#+BEGIN_SRC js :tangle no
  case 'SAVE_CONTACT_REJECTED': {
    const data = action.payload.response.data
    // convert feathers error formatting to match client-side error formatting
    const { "name.first": first, "name.last": last, phone, email } = data.errors
    const errors = { global: data.message, name: {first, last}, phone, email }
    return {
      ...state,
      errors: errors,
      loading: false
    }
  }
#+END_SRC
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/index.js
    :END:
    Here we combine all our different reducers into one big one.  This lets us think about the app in different, focused concerns that then get added to the larger application seamlessly.   For example, when we remove contacts, we simply delete a line in our index.js file since all the contacts concerns were handled only in their contact-reducer file and nowhere else.

    To handle the form validation and submission, we are going to use an existing redux module called 'redux-form'.  this helps us package up the form to send to our backend properly (as it's one of those surprisingly hard things to do in this type of world!)

    #+NAME: Requirements
    #+BEGIN_SRC js
      import { combineReducers } from 'redux'
      import { reducer as formReducer } from 'redux-form'

      import ContactReducer from './contact-reducer'
    #+END_SRC

    #+NAME: Reducers
    #+BEGIN_SRC js
      const reducers = {
        contactStore: ContactReducer,
        form: formReducer
      }

      const rootReducer = combineReducers(reducers)

      export default rootReducer
    #+END_SRC

** Services
   This will handle our api calls, we reference it back in our [[*Sagas][Sagas]]
*** API
   :PROPERTIES:
   :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/services/api.js
   :END:
    #+NAME: API
    #+BEGIN_SRC js
      export function getCats (app) {
  console.log('cats requested!')
        const cats = app.service('cats')
        return cats.get().then((cat, err) => cat.cat)
      }
    #+END_SRC
*** App
    :PROPERTIES:
    :header-args: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/components/App.js
    :END:
    There isn't much here since it's really just a wrapper for our main component.  But it sets up that component nicely.

* TASKS

** DONE Get working React App on top of Feathers, no matter what it looks like.
   CLOSED: [2018-09-26 Wed 23:42]
   This should show up a webpage when we spin up a server using feathers.

** TODO figure out why there's padding added by default to our app, even though no padding appears when you inspect element.
** TODO Follow sitepoint tutorial to get backend and frontend working
** DONE Understand what function* does and yield* does
   CLOSED: [2018-09-26 Wed 17:32]
   It has to do with asynchronous calls in the new es6, specifically with Saga.  So it's a special type of syntax for what saga does, which is take complex chained functions and put them in a nice pipe syntax.  It's not a full js thing, just a saga thing.
** DONE Figure out the issue with Browser history.
   CLOSED: [2018-09-26 Wed 17:33]
   it was an issue between react v.3 and react v.4.  I'm implementing things ina  different way now.
** TODO Figure out how to setup dev and prod configurations for axios
   we have it hardcoded to connect to localhost:3030.  What does it look like when we want to connect to some other known server?
** TODO lookup classnames to better understand how it works!
  https://www.npmjs.com/package/classnames
* Footnotes
** Resources
*** Youtube Tutorial
    I followed [[https://www.youtube.com/watch?v=etq_vv_RVcU&index=2&list=PLN3n1USn4xlnulnnBGD2RMid_p7xVj9xU][This Tutorial]] for a lot of the setup and found it quite useful, but actually it's mad outdated and might be a set back.  It helped me get a better sense of Sagas but react and redux have changed too much since this tutorial.
*** Sitepoint tutorial
   [[https://www.sitepoint.com/crud-app-react-redux-feathersjs/][sitepoint tutorial]]
    this one is far newer, and scanning it after doing all my research it is using mostly up-to-date code samples.  I think it'd be best to follow this going forward.
** Outdated or Experimental
   :PROPERTIES:
   :header-args: :tangle no
   :END:
*** Sagas
**** sagas.js
     :PROPERTIES:
     :header-args: :noweb yes :tangle no
     :END:
***** requirements
    #+NAME: requirements
    #+BEGIN_SRC js
      import { call, put, takeEvery } from 'redux-saga/effects'

      import { getCats } from '../services/api'
    #+END_SRC

    #+RESULTS: requirements

***** root function
      This'll be the thing exported out that we call upon when we do sagaMiddleware.run(mySaga, app) in our store.js
      We'll define our different sagas that we run...these take actions and make api calls with them.  Since they are asynchronous, we are using the * sign with the function. (this is outta my element, so I'm following a tutorial and need to better understand this syntax.)

      #+NAME: root function
      #+BEGIN_SRC js
        <<cats saga>>
        <<fetch cats>>
        export default function* root(feathersApp) {
          yield call(catsSaga, feathersApp)
        }
      #+END_SRC

***** cats saga
   Here is an example saga.  We'll get more complex later, but this shows the general format.  You take everyinstance of an action, send it to a function we define, and connect it with our feathers backend.

   #+NAME: cats saga
   #+BEGIN_SRC js :tangle no
     function* catsSaga (feathersApp) {
       yield* takeEvery('CATS_REQUESTED', fetchCats, feathersApp)
     }
   #+END_SRC

***** fetch cats
      This function calls our getCats function (which we'll define in our services/api) to  our backend and with its yield, sends out a call.
   #+NAME: fetch cats
   #+BEGIN_SRC js :tangle no
     function* fetchCats (feathersApp) {
   console.log('fetch cats reached')
       try {
         const cats = yield call(getCats, feathersApp)
         yield put({type: 'CATS_SUCCEEDED', cats})
       } catch (e) {
         yield put({type: 'FETCH_CATS_FAILED', message: e.message})
       }
     }
   #+END_SRC

 So all in all, we have a general flow for handling asynchronous calls to an api.  Within our app we'll send out an action like 'CATS_REQUESTED'.  Redux isn't ready to handle this yet, since it also just wants cats, ince and simple,  so it can add them to the state and let us display it.  We don't know when the api will respond to our cats request, and so we are in the asynchronous land.

 And so to help, we have a saga setup that is listening to all our 'CATS_REQUESTED' actions.  When one comes in, it runs its fetchCats function, which pings our api.  We assume success here (though can build it out so say what happens when there's a failure), and success means we are delivered some nice json.  We can take that object, then, and send //that// to redux.

 We do this by announcing we have something to give redux with our action 'CATS_SUCCEEDED', which redux will be setup to listen for, and will take the cats we deliver and add it to state.
*** Store
**** store requirements with saga.
I'd like to use these, or something like it, but it's requiring a bit too much rabbit-holing and I just wanna deliver a small improvement.  So we'll return to Sagas v. Epics v. Callbags later.
      #+NAME: requirements with Saga
      #+BEGIN_SRC js :tangle no
        import { createStore, applyMiddleware } from 'redux'
        import { composeWithDevTools } from 'redux-devtools-extension'

        import createSagaMiddleware from 'redux-saga'
        import mySaga from './sagas/sagas'

        import rootReducer from './reducers/index.js'

        import superagent from 'superagent'
        import feathers from '@feathersjs/client'

      #+END_SRC
**** Create Saga Middleware
     #+NAME: create saga middleware
     #+BEGIN_SRC js
       const sagaMiddleware = createSagaMiddleware()
     #+END_SRC
**** Apply Saga Middleware
     #+NAME: apply saga middleware
     #+BEGIN_SRC js
       sagaMiddleware.run(mySaga, app)

     #+END_SRC
*** Components
**** App
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React from 'react'
        import { HashRouter, Route } from 'react-router-dom'

        import { bindActionCreators } from 'redux'

        import { connect } from 'react-redux'

        import * as actionCreators from '../actions/actionCreators'
        import Main from './Main'
      #+END_SRC
***** MapStateToProps
      This lets us bring the app's state as properties to the component, in other words as things the html elements know how to display without having to know anything about the data itself.
      #+NAME: MapStateToProps
      #+BEGIN_SRC js
        function mapStateToProps (state) {
          return {
            cats: state.cats
          }
        }
      #+END_SRC

***** MapDispatchToProps
      This lets us call out actions easily (with less this.state.actions.dispatch.action nonsense)
      #+NAME: MapDispatchToProps
      #+BEGIN_SRC js
        function mapDispatchToProps (dispatch) {
          return bindActionCreators(actionCreators, dispatch)
        }
      #+END_SRC

***** The App Component
      #+NAME: App
      #+BEGIN_SRC js
        class App extends React.Component {
          componentDidMount () {
            this.props.funZachAction()
            this.props.dispatch(services.cats.get())
            this.props.actionCats()
          }
          render(){
            return (
            <HashRouter>
              <div>
                <Route exact path='/' component={Main} />
              </div>
            </HashRouter>
            )
          }
        }
        export default connect(mapStateToProps, mapDispatchToProps)(App)
      #+END_SRC

**** Main
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatList from './CatList'
      #+END_SRC

***** The Main Class
      #+NAME: Main
      #+BEGIN_SRC js
        class Main extends Component {
          render(){
            return(
              <div>
                <h1>This is the Main Component</h1>
              </div>
            )
          }
        }
        export default Main
      #+END_SRC

**** Home
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatList from './CatList'
      #+END_SRC
***** The Home Class
      #+NAME: Home
      #+BEGIN_SRC js
        class Home extends Component {
          render(){
            return(
              <div>
                <CatList {...this.props}/>
              </div>
            )
          }
        }

        export default Home
      #+END_SRC
**** CatList
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import CatCard from './CatCard'
      #+END_SRC

***** The CatList Class
      #+NAME: Cat
      #+BEGIN_SRC js
        class CatList extends Component {
          constructor(props){
            super(props)

            this.props.actionCats()
          }

          render(){
            return(
                <ul>
                {this.props.cats.map((cat, i) => <CatCard {...this.props} key={i} cat={cat} />)}
              </ul>
            )
          }
        }

        export default CatList
      #+END_SRC

**** CatCard
***** Requirements
      #+NAME: Requirements
      #+BEGIN_SRC js
        import React, { Component } from 'react'
      #+END_SRC

***** The CatCard Class
      #+NAME: CatCard
      #+BEGIN_SRC js
        class CatCard extends Component {
          render(){
            const { cat } = this.props
            return (
                <li>
                  <h2>{cat.name}</h2>
                  <em>{cat.catchphrase}</em>
                </li>
            )
          }
        }

          export default CatCard
      #+END_SRC
*** Actions
**** actionCreators
     :PROPERTIES:
     :header-args-disabled: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/actions/actionCreators.js
     :END:
     This delivers the content do our reducers.  Actions are just objects with information.
     At the beginning we want to just make sure this all works.  We have an api called /cats so let's work with that!
     #+NAME: action
     #+BEGIN_SRC js
       export function actionCats () {
         return {
           type: 'CATS_REQUESTED'
         }
       }

       export function funZachAction () {
         return {
           type: 'TEST'
         }
       }
     #+END_SRC

*** Reducers
    In our cats one we have a test just to make sure these reducers are working.  I can properly send out dispatches for both of these, so the reducer is correctly attached to our client.
**** cats
     :PROPERTIES:
     :header-args-disabled: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/cats.js
     :END:
    #+NAME: cats
    #+BEGIN_SRC js
      function cats (state=[], action) {
        switch(action.type) {
          case 'CATS_SUCCEEDED':
            return action.cats
          case 'TEST':
            return 'test is success'
          default:
            return state
        }
      }
      export default cats
    #+END_SRC
**** index
     :PROPERTIES:
     :header-args-disabled: :noweb yes :tangle ~/Projects/ii/apisnoop_webui/client/src/reducers/index.js
     :END:
    This one will gather all our other reducers into a single rootReducer, this is the one that gets added to our store in [[*index.js][client/index.js]]
***** requirements
      Right now we are doing feathers-redux, if that goes away, they can go away here too.
     #+NAME: requirements
     #+BEGIN_SRC js
       import { combineReducers } from 'redux'
       import { routerReducer } from 'react-router-redux'

       import reduxifyServices from 'feathers-redux'
       import feathers from '@feathersjs/client'
       import superagent from 'superagent'

       import cats from './cats'
     #+END_SRC
***** Create application
      Our goal is to use feathers-redux (more info here:[[https://github.com/feathers-plus/feathers-redux][feathers-redux github]] )
      We'll connect this to our feathers backend which is located at localhost:3030, using the feathers client adaptor.  This can be configured so it works with authentication, with the hooks on each thing (modifying data as it flows through the service), and we'll bring in superagent so the api calls work correctly with redux.
      #+NAME: create application
      #+BEGIN_SRC js
        const host = 'http://localhost:3030'
        export const feathersClient = feathers()
          .configure(feathers.rest(host).superagent(superagent))
          .configure(feathers.authentication({ store: window.localstorage }))
      #+END_SRC
***** setup feathers services as reducers
    each service in the server can be rendered as an object for state here.
    #+NAME: feathers services
    #+BEGIN_SRC js
      const services = reduxifyServices(feathersClient, ['cats'])
    #+END_SRC

***** Combine reducers and export
      #+NAME: the reducer
      #+BEGIN_SRC js
        const rootReducer = combineReducers({
          cats,
          routing: routerReducer,
          fcat: services.cats.reducer
        })

        export default rootReducer
      #+END_SRC
