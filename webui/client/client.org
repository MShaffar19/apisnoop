#+NAME: APISnoop WebUI Client
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:tmate :socket "/tmp/.zz-left.isocket"
#+PROPERTY: header-args:tmate :session api:main
#+PROPERTY: header-args:js :results silent

* Understanding our Webui
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
** TODO Setting It up On Your own with tmate
*** Setup Backend
 after cloning repository
- cd apisnoop/backend
- npm install
- Make sure we have a jsons folder in apisnoop/backend with this tree structure:
#+RESULTS: File Structure
:RESULTS:
.
├── release
└── sunbursts

2 directories
:END:
#+NAME: File Structure
#+BEGIN_SRC shell :dir ./backend/jsons :results output raw drawer
tree -d
#+END_SRC
- Delete all .db's from src/data/
- npm start
- email zz@ii.coop with full error output and a coupon for soda.

*** Setup Client
    When backend server is on:
    - cd apisnoop/client
    - npm install
    # - figure out how to point to subheadings
    - go to [[Client/Actions/index.js]]   and change the client here to be whatever site you have this on (localhost or apisnoop)
    - npm start

** Running the Client
  In the web ui folder:
 ===
 cd client
 npm install
 npm start
 ===
 Then navigate to localhost:3000, if it isn't already opened for you.
** Architecture
   This is built as a dynamic web app, as opposed to a static site.  And so when the page loads, we dynamically fetch data from both our backend server and the app's own state management.  Then we display information derived from the application state and that backend server.

   We do this using React for the front-end framework, and redux-bundler for our state management.  This is all done 'client-side'
*** React
    React is our front-end framework, handling the presentational components of the site.
**** Why are we using it?
     Mostly for it's level of support.  It's a mature-enough framework that has a number of good documentation and books written about it and a continually active community.
     -
**** Resources
     :PROPERTIES:
     :CUSTOM_ID: arch-react
     :END:
    - [[https://reactjs.org/docs/getting-started.html][Official Documentation]]
      -
*** Redux
    :PROPERTIES:
    :CUSTOM_ID: arch-redux
    :END:
*** Redux-Bundler
**** Redux Bundler Resources
     :PROPERTIES:
     :CUSTOM_ID: arch-redux-bundler
     :END:
     - [[https://reduxbundler.com/][redux bundler documentation]]: documentation with good api references
     - [[https://read.reduxbook.com/][Human Redux]]: book by Henrik Joreteg about working with redux.  A lot of our principles are inspired by this book, and explained in better detail here
*** React-vis
    This is the visualization library we are using for the sunburst.  It provides a react wrapper to the d3 library.  So it is really d3 that we are using.
**** Why d3?
**** Why react-vis?
**** Resources
     :PROPERTIES:
     :CUSTOM_ID: arch_react-vis
     :END:
     - [[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][interactive applications with react-d3]]
 -    this is really good    .
     - [[https://www.smashingmagazine.com/2018/02/react-d3-ecosystem/][Bringing Together react, d3, and their ecosystem]]
     - [[http://www.adeveloperdiary.com/react-js/integrate-react-and-d3/][How to Integrate React and d3 the right way]]
     - [[https://bost.ocks.org/mike/join/][Thinking with Joins]]
*** Tachyons
    Our css framework.  It is done in a a functional style, where you add a class for every property you'd like to see.  V. different from the standard method of CSS, but it's perfect for working with a team (or unknown amount of maintainers), it's pleasant to use once you get the hang of it, and it's great for the component, modular style of our app.
**** Resources
     :PROPERTIES:
     :CUSTOM_ID: arch_tachyons
     :END:
     - [[http://tachyons.io/docs/][Official Documentation]]
     - [[https://tachyons-tldr.now.sh/#/classes][tachyons tldr]] - awesome source for checking class names
** Principles
*** Design the App like a Spreadsheet
    Inspired by Henrik's blogpost: '[[https://joreteg.com/blog/reactive-programming][Reactive Programming]]

*** Presentation is Separate from Logic
    the components do not care about the data, or affect the data.  They only present the data given to them.
*** Reducers are dumb and that's a good thing
    the reducer is a continually replaced object that holds the current state of the app.  We want the reducer to be as dumb and simple as possible...so no if/else statements or functions that define what the value of some part of the state should be.  It only holds the clean, proper value.
*** Our logic is done through selectors and reactors
    This is a philosophy of henrik joreteg, from 'human redux'. [[https://joreteg.com/blog/reactive-programming][original post]]

*** The URL is our source of truth
    As we navigate around the site, including navigating our mouse arounmd the chart, the URL will change to reflect the current method, level, and all that we are on.  The app then listens to this and updates its data appropriately.

*** Avoid infinite loops in reactors
    important: It is easy to make infinite loops. Make sure that any action triggered by a reactor, immediately change the conditions that caused your reactor function to return something (from the [[Redux Bundler Resources][redux-bundle documentation]]
** Conventions
*** Redux-Bundler
    how to write selectors, reducers, all that.
    stylistic choices.   Best practices go in our principles
**** Selectors
     selectors are always written with ~select~ at the start: ~selectReleaseNames~, ~selectAllConformanceTests~
**** ActionCreators
**** Reactors
**** Components
 ***
*** this org-file
    adding new bundles.
    structurikng the code
    the code block arguments
* The Code
** File Structure
** Initiatory Code
*** index.js
    :PROPERTIES:
    :header-args: :tangle ./src/index.js
    :END:
    #+NAME: index.js
    #+BEGIN_SRC js
      import React from 'react'
      import { render } from 'react-dom'
      import './index.css'

      import { Provider } from 'redux-bundler-react'

      import App from './components/app'
      import createStore from './bundles'

      var store = createStore()

      document.title = 'APISnoop | ' // + store.getState().routing.release

      render(
          <Provider store={store}>
          <App />
          </Provider>,
        document.getElementById('root')
      )
    #+END_SRC
** Bundles
*** Understanding Bundles
   Another way of thinking of these are 'concerns'.  As we add functionality, it will come in the form of a bundle.  This bundle will define:
 - the state as related to this concern (reducers),
 - How we manipulate and then give the data in the state to our components (the selectors),
 - How we listen for conditions in the state that would trigger actions to happen (the reactors),
 - The actions that change the state (Actions)
*** Index
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/index.js
    :END:
    This is the root bundler, that takes all the other individual ones and composes a single super bundle.
**** Import modules and bundles
     We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.
     #+NAME: bundle index: Import modules and bundles
     #+BEGIN_SRC js
       import { composeBundles } from 'redux-bundler'

       import config from './config'
       import currentReleaseResource from './current-release-resource'
       import endpointsResource from './endpoints-resource'
       import endpoints from './endpoints'
       import releases from './releases'
       import releasesIndexResource from './releases-index-resource'
       import routes from './routes'
       import sunburst from './sunburst'
       import testsResource from './tests-resource'

     #+END_SRC
**** Compose Bundle
     Then, we compose the bundles into a single store, listing all the ones we imported above.
     #+NAME: bundle index: compose bundle
     #+BEGIN_SRC js
       export default composeBundles(
         config,
         currentReleaseResource,
         endpointsResource,
         endpoints,
         releases,
         releasesIndexResource,
         routes,
         sunburst,
         testsResource
       )
     #+END_SRC

*** Endpoints Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints-resource.js :noweb yes
    :END:
    #+NAME: endpoints-resource.js
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'endpointsResource',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchEndpointsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactEndpointsFetch = createSelector(
        'selectEndpointsResourceShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchEndpointsResource' }
        }
      )


      export default bundle

      function fetchEndpointsByReleaseName (client, releaseName) {
        return client.service('endpoints').find({
          query: {
            release: releaseName
          }
        })
      }
    #+END_SRC
*** Endpoints
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/endpoints.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: endpoints bundle layout
    #+BEGIN_SRC js
    import { createSelector } from 'redux-bundler'
    import { groupBy, keyBy, mapValues } from 'lodash'
    import { calculateCoverage } from '../lib/utils.js'

    export default {
      name: 'endpoints',
        <<Endpoints Reducers>>,
        <<Endpoints Selectors>>
    }
    #+END_SRC
**** Reducers
     #+NAME: Endpoints Reducers
     #+BEGIN_SRC js :tangle no
      getReducer: () => {
        const initialState = {}

        return (state = initialState, action = {}) => {
          return state
        }
      }
     #+END_SRC
**** Selectors
     #+NAME: Endpoints Selectors
     #+BEGIN_SRC js :tangle no
       selectEndpointsById: createSelector(
         'selectEndpointsResource',
         (endpoints) => keyBy(endpoints, '_id')
       ),
       selectEndpointsByNameAndMethod: createSelector(
         'selectEndpointsResource',
         (endpoints) => {
           var endpointsByName = groupBy(endpoints, 'name')
           return mapValues(endpointsByName, endpointsInName => {
             return keyBy(endpointsInName, 'method')
           })
         }
       ),
       selectEndpointsByLevelAndCategoryAndNameAndMethod: createSelector(
         'selectEndpointsById',
         (endpointsById) => {
           var endpointsByLevel = groupBy(endpointsById, 'level')
           return mapValues(endpointsByLevel, endpointsInLevel => {
             var endpointsByCategory = groupBy(endpointsInLevel, 'category')
             return mapValues(endpointsByCategory, endpointsInCategory => {
               var endpointsByName = groupBy(endpointsInCategory, 'name')
               return mapValues(endpointsByName, endpointsInName => {
                 return keyBy(endpointsInName, 'method')
               })
             })
           })
         }
       ),
        selectEndpointsWithTestCoverage: createSelector(
          'selectEndpointsById',
          (endpointsById) => {
            var endpointsByLevel = groupBy(endpointsById, 'level')
            var coverage = calculateCoverage(endpointsById)
            return Object.assign({},{coverage}, mapValues(endpointsByLevel, endpointsInLevel => {
              var endpointsByCategory = groupBy(endpointsInLevel, 'category')
              var coverage = calculateCoverage(endpointsInLevel)
              return Object.assign({}, {coverage}, mapValues(endpointsByCategory, endpointsInCategory => {
                var endpointsByName = groupBy(endpointsInCategory, 'name')
                var coverage = calculateCoverage(endpointsInCategory)
                return Object.assign({}, {coverage}, mapValues(endpointsByName, endpointsInName => {
                  var methods = keyBy(endpointsInName, 'method')
                  return mapValues(methods, method => {
                    var coverage = method.test_tags ? method.test_tags : [] // display empty array if untested, so chart don't break.
                    return Object.assign({}, {coverage}, method)
                  })
                }))
              }))
            }))
          }
         )
     #+END_SRC
*** Releases Index Resource
    #+NAME: releases-index-resource.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases-index-resource.js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'releasesIndex',
        getPromise: ({ client, getState }) => {
          return fetchReleasesIndex(client)
        }
      })

      bundle.reactReleasesIndexFetch = createSelector(
        'selectReleasesIndexShouldUpdate',
        (shouldUpdate) => {
          if (shouldUpdate) {
            return { actionCreator: 'doFetchReleasesIndex' }
          }
        }
      )

      export default bundle

      function fetchReleasesIndex (client) {
        return client.service('releases').find({
          query: {
            $select: [
              'name',
              '_id'
            ]
          }
        })
      }
    #+END_SRC
*** Releases
    #+NAME: releases.js
    #+BEGIN_SRC js :tangle ./src/bundles/releases.js
      import { createSelector } from 'redux-bundler'
      import { keyBy } from 'lodash'

      export default {
        name: 'releases',
        init: (store) => {
          store.subscribeToSelectors(
            ['selectCurrentReleaseName'],
            (currentReleaseName) => {
              store.doMarkCurrentReleaseAsOutdated()
              store.doMarkEndpointsResourceAsOutdated()
              store.doMarkTestsAsOutdated()
            }
          )
        },
        getReducer: () => {
          const initialState = {}

          return (state = initialState, action = {}) => {
            return state;
          }
        },
        //
        // TODO make doMarkReleaseResourcesAsOutdated()
        // TODO make selectIsReleaseResourcesFetched()
        //
        selectCurrentReleaseName: createSelector(
          'selectRouteParams',
          (routeParams) => {
            return routeParams.releaseName || 'master'
          }
        ),
        selectCurrentReleaseId: createSelector(
          'selectCurrentReleaseName',
          'selectReleasesIndex',
          (currentReleaseName, releasesIndex) => {
            if (releasesIndex == null) return null
            const release = releasesIndex.find(release => {
              return release.name === currentReleaseName
            })
            return release == null ? null : release._id
          }
        ),
        selectReleasesIndexByName: createSelector(
          'selectReleasesIndex',
          releasesIndex => keyBy(releasesIndex, 'name')
        )
      }
    #+END_SRC
*** Routes
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/routes.js :noweb yes
    :END:
    #+NAME: routing
    #+BEGIN_SRC js
      import MainPage from '../pages/main-page'
      import NotFound from '../components/not-found'

      import { createRouteBundle } from 'redux-bundler'

      export default createRouteBundle({
        '/': MainPage,
        '/:releaseName': MainPage,
        '*': NotFound
      })
    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/sunburst.js :noweb yes
    :END:
**** Imports and Layout
    #+NAME: charts.js
    #+BEGIN_SRC js
      import { fadeColor } from '../lib/utils'
      import { createSelector } from 'redux-bundler'
      import {
        assign,
        forEach,
        get,
        includes,
        map,
        mapValues,
        orderBy,
        reduce,
        sortBy,
        values,
        without
      } from 'lodash'

      export default {
        name: 'charts',
        <<Sunburst Reducer>>,
        <<Sunburst Selectors>>,
        <<Sunburst Action Creators>>
      }

      <<Charts Helper Functions>>
    #+END_SRC
**** Reducer
   #+NAME: Sunburst Reducer
   #+BEGIN_SRC js :tangle no
     getReducer: () => {
       const initialState = {
         focusedKeyPath: [],
         chartLocked: false
       }

       return (state = initialState, action = {}) => {
         if (action.type === 'CHART_FOCUSED') {
           return {
             ...state,
             focusedKeyPath: action.payload
           }
         }
         if (action.type === 'CHART_UNFOCUSED') {
           return {
             ...state,
             focusedKeyPath: []
           }
         }
         if (action.type === 'CHART_LOCKED') {
           return {
             ...state,
             chartLocked: true
           }
         }
         if (action.type === 'CHART_UNLOCKED') {
           return {
             ...state,
             chartLocked: false
           }
         }
         return state;
       }
     }
   #+END_SRC

**** Selectors
   #+NAME: Sunburst Selectors
   #+BEGIN_SRC js :tangle no
     selectSunburst: createSelector(
       'selectEndpointsByLevelAndCategoryAndNameAndMethod',
       (endpointsByLevelAndCategoryAndNameAndMethod) => {
         return {
           name: 'root',
           children: map(endpointsByLevelAndCategoryAndNameAndMethod, (endpointsByCategoryAndNameAndMethod, level) => {
             return {
               name: level,
               color: colors[level],
               children: categoriesSortedByEndpointCount(endpointsByCategoryAndNameAndMethod)
             }
           })
         }
       }
     ),
     selectLabelStyle: () => {
       return {
         PERCENTAGE: {
           fontSize: '1.3em',
           textAnchor: 'middle'
         },
         FRACTION: {
           fontSize: '1.2em,',
           textAnchor: 'middle'
         },
         PATH: {
           fontSize: '1em',
           textAnchor: 'middle'
         },
         DESCRIPTION: {
           fontSize: '0.9em',
           textAnchor: 'middle'
         }
       }
     }
    #+END_SRC

   #+NAME: Sunburst Selectors Scratch
   #+BEGIN_SRC js :tangle no
     selectFocusPathAsArray: (state) => state.charts.focusedKeyPath
     selectChartLocked: (state) => state.charts.chartLocked,
     selectFocusPathAsString: createSelector(
       'selectFocusPathAsArray',
       (pathAsArray) => {
         return pathAsArray.join().replace(/,/g,' / ')
       }
     ),
     selectInteriorLabelComponents: createSelector(
       'selectFocusPathAsArray',
       'selectIsEndpointsReady',
       'selectEndpointsWithTestCoverage',
       'selectRelease',
       (focusPath, isEndpointsReady, endpoints, releaseFromRoute) => ({
         focusPath, isEndpointsReady, endpoints, releaseFromRoute
       })
     ),
     selectInteriorLabel: createSelector(
       'selectInteriorLabelComponents',
       (components) => {
         const { focusPath, endpoints, isEndpointsReady, releaseFromRoute } = components
         if (isEndpointsReady) {
           if (!focusPath.length) {
             return endpoints[releaseFromRoute]['coverage']
           } else {
             var path = (without(focusPath, 'root'))
             var testedEndpoint = get(endpoints[releaseFromRoute], path)
             if (testedEndpoint && testedEndpoint.coverage) {
               return testedEndpoint.coverage
             } else if (!testedEndpoint) {
               return {description: 'untested', test_tags: []}
             } else {
               var method = Object.keys(testedEndpoint)[0]
               return {description: testedEndpoint[method]['description'],
                       test_tags: testedEndpoint[method]['test_tags']
                      }
             }
           }
         }
       }
     ),
     selectLabelStyle: () => {
       return {
         PERCENTAGE: {
           fontSize: '1.3em',
           textAnchor: 'middle'
         },
         FRACTION: {
           fontSize: '1.2em,',
           textAnchor: 'middle'
         },
         PATH: {
           fontSize: '1em',
           textAnchor: 'middle'
         },
         DESCRIPTION: {
           fontSize: '0.9em',
           textAnchor: 'middle'
         }
       }
     },
     selectSunburstByRelease: createSelector(
       'selectEndpointsByReleaseAndLevelAndCategoryAndNameAndMethod',
       (endpointsByReleaseAndLevelAndCategoryAndNameAndMethod) => {
         var dataByRelease = mapValues(endpointsByReleaseAndLevelAndCategoryAndNameAndMethod, (endpointsByLevelAndCategoryAndNameAndMethod, release) => {
           return {
             name: 'root',
             children: map(endpointsByLevelAndCategoryAndNameAndMethod, (endpointsByCategoryAndNameAndMethod, level) => {
               return {
                 name: level,
                 color: colors[level],
                 children: categoriesSortedByEndpointCount(endpointsByCategoryAndNameAndMethod)
               }
             })
           }
         })
         return {
           dataByRelease
         }
       }
     ),
     selectSunburstByReleaseWithSortedLevel: createSelector(
       'selectSunburstByRelease',
       (endpointsByRelease) => {
         var dataByRelease = endpointsByRelease.dataByRelease
         var sortedDataByRelease = mapValues(dataByRelease, (release) => {
           var levels = release.children
           var sortedLevels = orderBy(levels, 'name', 'desc')
           release.children = sortedLevels
           return release
         })
         endpointsByRelease.dataByRelease = sortedDataByRelease
         return endpointsByRelease
       }
     ),
     selectIsSunburstReady: createSelector(
       'selectIsEndpointsReady',
       (isEndpointsReady) => isEndpointsReady
     )
    #+END_SRC

**** Action Creators
   #+NAME: Sunburst Action Creators
   #+BEGIN_SRC js :tangle no
     doLockChart: () => {
       return {
         type: 'CHART_LOCKED'
       }
     },
     doUnlockChart: () => {
       return {
         type: 'CHART_UNLOCKED'
       }
     },
     doUnfocusChart: () => {
       return {
         type: 'CHART_UNFOCUSED'
       }
     }
   #+END_SRC
   #+NAME: Sunburst Action Creator Scratch
   #+BEGIN_SRC :tangle no

   #+END_SRC
     doFocusChart: (keyPath) => {
       return function ({ dispatch, getState }) {
         dispatch({
           type: 'CHART_FOCUSED',
           payload: keyPath
         })

         const state = getState()
         const {route} = state
         const { url, params } = route
         const { level, category, endpoint, method } = params
         dispatch({
           type: 'URL_UPDATED',
           payload: {
             url: route.url,
             params: assign({}, route.params, {
               level,
               category,
               endpoint,
               method
             })
           }
         })
       }
     },
**** Helper Functions
     #+NAME: Charts Helper Functions
     #+BEGIN_SRC js :tangle no
       function categoriesSortedByEndpointCount (endpointsByCategoryAndNameAndMethod) {
         var categories = categoriesWithEndpointsAsChildren(endpointsByCategoryAndNameAndMethod)
         return orderBy(categories, (category) => category.children.length, ['desc'])
       }

       function categoriesWithEndpointsAsChildren (endpointsByCategoryAndNameAndMethod) {
         return map(endpointsByCategoryAndNameAndMethod, (endpointsByNameAndMethod, category) => {
           return {
             name: category,
             color: colors[`category.${category}`],
             children: endpointsSortedByConformance(endpointsByNameAndMethod)
           }
         })
       }

       function endpointsSortedByConformance (endpointsByNameAndMethod) {
         var endpoints = createEndpointAndMethod(endpointsByNameAndMethod)
         var sortedEndpoints = sortBy(endpoints, [
           (endpoint) => endpoint.tested === 'untested',
           (endpoint) => endpoint.isConformance !== 'conformance',
           (endpoint) => endpoint.testTagCount
         ])
         return sortedEndpoints
       }

       function createEndpointAndMethod(endpointsByNameAndMethod) {
         return values(reduce(
           endpointsByNameAndMethod,
           (sofar, endpointsByMethod, name) => {
             sofar = fillOutMethodInfo(sofar, endpointsByMethod, name)
             return sofar
           },
           {}
         ))
       }

       // TODO change endpoint to method for clarity starting on line 115
       function fillOutMethodInfo (sofar, endpointsByMethod, name) {
         forEach(endpointsByMethod, (endpoint, method) => {
           var { isTested } = endpoint
           var isConformance = checkForConformance(endpoint.test_tags)
           var path = `${name}/${method}`
           var size = (sofar[path] == null) ? 1 : sofar[path].size + 1
           sofar[path] = {
             name,
             testTagCount: endpoint.test_tags.length,
             tested: isTested ? 'tested' : 'untested',
             isConformance: isConformance ? "conformance" : "not conformance",
             size,
             color: isTested ? calculateColor(endpoint, isConformance) : 'rgba(244,244,244, 1)',
           }
         })
         return sofar
       }

       function checkForConformance (test_tags) {
         var tagsAsStrings = test_tags.map(tag => tag.replace(/\[|]/g,''))
         return includes(tagsAsStrings, 'Conformance')
       }

       var colors = {
         'alpha': 'rgba(230, 25, 75, 1)',
         'beta': 'rgba(0, 130, 200, 1)',
         'stable': 'rgba(60, 180, 75, 1)',
         'unused': 'rgba(255, 255, 255, 1)'
       }

       var categories = [
         "admissionregistration",
         "apiextensions",
         "apiregistration",
         "apis",
         "apps",
         "authentication",
         "authorization",
         "autoscaling",
         "batch",
         "certificates",
         "core",
         "events",
         "extensions",
         "logs",
         "networking",
         "policy",
         "rbacAuthorization",
         "scheduling",
         "settings",
         "storage",
         "version",
         "auditregistration",
         "coordination"
       ]

       var more_colors = [
         'rgba(183, 28, 28, 1)',
         'rgba(136, 14, 79, 1)',
         'rgba(74, 20, 140, 1)',
         'rgba(49, 27, 146, 1)',
         'rgba(26, 35, 126, 1)',
         'rgba(13, 71, 161, 1)',
         'rgba(1, 87, 155, 1)',
         'rgba(0, 96, 100, 1)',
         'rgba(0, 77, 64, 1)',
         'rgba(27, 94, 32, 1)',
         'rgba(51, 105, 30, 1)',
         'rgba(130, 119, 23, 1)',
         'rgba(245, 127, 23, 1)',
         'rgba(255, 111, 0, 1)',
         'rgba(230, 81, 0, 1)',
         'rgba(191, 54, 12, 1)',
         'rgba(244, 67, 54, 1)',
         'rgba(233, 30, 99, 1)',
         'rgba(156, 39, 176, 1)',
         'rgba(103, 58, 183, 1)',
         'rgba(63, 81, 181, 1)',
         'rgba(33, 150, 243, 1)',
         'rgba(3, 169, 244, 1)',
         'rgba(0, 188, 212, 1)',
         'rgba(0, 150, 136, 1)',
         'rgba(76, 175, 80, 1)',
         'rgba(139, 195, 74, 1)',
         'rgba(205, 220, 57, 1)',
         'rgba(255, 235, 59, 1)',
         'rgba(255, 193, 7, 1)',
         'rgba(255, 152, 0, 1)',
         'rgba(255, 87, 34, 1)'
       ]

       for (var catidx = 0; catidx < categories.length; catidx++) {
         var category = categories[catidx]
         colors['category.' + category] = more_colors[(catidx * 3) % more_colors.length]
       }

       function calculateColor (endpoint, isConformance) {
         if (endpoint.isTested && isConformance)  {
           return colors[`category.${endpoint.category}`]
         } else  if( endpoint.isTested && !isConformance) {
           var color = colors[`category.${endpoint.category}`]
           var fadedColor = fadeColor(color, '0.2')
           return fadedColor
         } else {
           return 'rgba(244, 244, 244, 1)'
         }
       }

     #+END_SRC
*** Tests Resource
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests-resouce.js :noweb yes
    :END:

    #+NAME: tests resource
    #+BEGIN_SRC js
      import { createAsyncResourceBundle, createSelector } from 'redux-bundler'

      const bundle = createAsyncResourceBundle({
        name: 'tests',
        getPromise: ({ client, store }) => {
          const currentReleaseName = store.selectCurrentReleaseName()
          return fetchTestsByReleaseName(client, currentReleaseName)
        }
      })

      bundle.reactTestsFetch = createSelector(
        'selectTestsShouldUpdate',
        (shouldUpdate, currentReleaseId) => {
          if (!shouldUpdate) return
          return { actionCreator: 'doFetchTests' }
        }
      )


      export default bundle

      function fetchTestsByReleaseName (client, releaseName) {
        return client.service('tests').find({
          query: {
            release: releaseName
          }
        })
      }

    #+END_SRC
*** Tests
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/tests.js :noweb yes
    :END:
    #+NAME: Tests Bundle
    #+BEGIN_SRC js
      /*
      const { keyBy } = require('lodash')

      const initialState = {
        activeTest: {},
        byId: {},
        endpointTests: [],
        errors: {},
        isLoading: false,
        hasLoaded: false
      }

      export default (state = initialState, action = {}) => {
        switch(action.type) {
        case 'FETCH_TESTS_PENDING': {
          return {
            ...state,
            isLoading: true
          }
        }
        case 'FETCH_TESTS_FULFILLED': {
          return {
            ...state,
            byId: {
              ...state.byId,
              ...keyBy(action.payload.data, '_id')
            },
            isLoading: false,
            hasLoaded: true
          }
        }
        case 'ENDPOINT_TESTS_SET': {
          return {
            ...state,
            endpointTests: action.payload
          }
        }
        case 'NEW_ACTIVE_TEST_CHOSEN': {
          return {
            ...state,
            activeTest: action.payload
          }
        }
        case 'ACTIVE_TEST_CLOSED': {
          return {
            ...state,
            activeTest: {}
          }
        }
        case 'CHART_UNLOCKED': {
          return {
            ...state,
            activeTest: {},
            endpointTests: []
          }
        }
        case 'ACTIVE_ROUTE_CHANGED': {
          return {
            ...state,
            activeTest: {},
            endpointTests: []
          }
        }
        default:
          return state;
        }
      }
      import { createSelector, createStructuredSelector } from 'reselect'
      import { groupBy, keyBy, mapValues } from 'lodash'

      export function selectTestsById (state) {
        return state.tests.byId
      }

      export const selectIsTestsReady = (state) => {
        return state.tests.hasLoaded
      }

      export const selectEndpointTests = (state) => {
        return state.tests.endpointTests
      }

      export const selectActiveTestRaw = (state) => {
        return {
          name: state.tests.activeTest,
          route: state.routing.release,
        }
      }

      export const selectTestsByReleaseAndName = createSelector(
        selectTestsById,
        (testsById) => {
          var testsByRelease = groupBy(testsById, 'release')
          return mapValues(testsByRelease, testsInRelease => {
            var testsByName = keyBy(testsInRelease, 'name')
            return mapValues(testsByName, testInName => {
              return {
                name: testInName.name,
                id: testInName._id,
                sequence: testInName.sequence
              }
            })
          })
        }
      )

      export const selectActiveTestComponents = createStructuredSelector({
        activeTest: selectActiveTestRaw,
        tests: selectTestsByReleaseAndName
      })

      export const selectActiveTest = createSelector(
        selectActiveTestComponents,
        (atc) => {
          if (atc.activeTest.name.length > 0) {
            var activeTest = atc.tests[atc.activeTest.route][atc.activeTest.name]
            return activeTest
          } else {
            return atc.activeTest.name
          }
        }
      )
      import { client } from './'

      const url = '/api/v1/tests'

      export function doFetchTests () {
        return dispatch => {
          dispatch({
            type: 'FETCH_TESTS',
            payload: client.get(url)
          })
        }
      }

      export function doChooseActiveTest (test) {
        return {
          type: 'NEW_ACTIVE_TEST_CHOSEN',
          payload: test
        }
      }

      export function doCloseActiveTest (test) {
        return {
          type: 'ACTIVE_TEST_CLOSED'
        }
      }

      export function doSetEndpointTests (endpointTests) {
        return {
          type: 'ENDPOINT_TESTS_SET',
          payload: endpointTests
        }
      }
      ,*/

    #+END_SRC
*** Config
    :PROPERTIES:
    :header-args: :tangle ./src/bundles/config.js :noweb yes
    :END:
    #+NAME: config.js
    #+BEGIN_SRC js
      import feathers from '@feathersjs/feathers'
      import RestClient from '@feathersjs/rest-client'
      import axios from 'axios'

      // TODO add envify as browserify transform
      const config = {
        backendUrl: process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000/api/v1'
      }

      export default {
        name: 'config',
        reducer: (state = config) => state,
        getExtraArgs: store => {
          return {
            config,
            client: createClient(config)
          }
        }
      }

      function createClient (config) {
        const restClient = RestClient(config.backendUrl)

        return feathers()
          .configure(restClient.axios(axios))
      }
    #+END_SRC
** Components
*** App
    :PROPERTIES:
    :header-args: :tangle ./src/components/app.js
    :END:
    the initiatory component.  This is sort of the standard layout in which all other views are placed within.
    #+Name: App.js
    #+BEGIN_SRC js
      import React from 'react'
      import navHelper from 'internal-nav-helper'
      import { connect } from 'redux-bundler-react'

      import Header from './header'
      import Footer from './footer'

      export default connect(
        'doUpdateUrl',
        'selectRoute',
        ({ doUpdateUrl, route }) => {
          const CurrentPage = route
          return (
              <div onClick={navHelper(doUpdateUrl)}>
              <Header />
              <CurrentPage />
              <Footer />
              </div>
          )
        }
      )
    #+END_SRC

    If you compare this to the original app, you can see it is far less duplicated or strange code.  Everything is just held in the connect function, where we bring in our selectors and actions, and then reference them directly in our presentational component.
    #+NAME: original app
    #+BEGIN_SRC js :tangle no
      import React, { Component } from 'react'
      import { connect } from 'react-redux'
      import { createStructuredSelector } from 'reselect'


      import { selectReleaseNamesFromEndpoints, selectIsEndpointsReady, selectPage } from '../selectors'
      import { fetchEndpoints } from '../actions/endpoints'
      import { doFetchTests } from '../actions/tests'

      import Header from './header'
      import Footer from './footer'
      import ReleasesList from './releases-list.js'

      class App extends Component {

        componentDidMount(){
          this.props.fetchEndpoints()
          this.props.fetchTests()
        }

        render(){
          const {
            Page,
            releaseNames,
            endpointsReady
          } = this.props

          return (
            <div id='app'>
              <Header />
              {endpointsReady &&
               <div>
               <ReleasesList
                 releases={releaseNames}
               />
              <Page />
              </div>
              }
              {!endpointsReady &&
              <div className='min-vh-80'>
              <h3>Loading...</h3>
              </div>
              }
              <Footer />
            </div>
          )
        }
      }

      export default connect(
        createStructuredSelector({
          releaseNames: selectReleaseNamesFromEndpoints,
          endpointsReady: selectIsEndpointsReady,
          Page: selectPage
        }),
        {fetchEndpoints,
         fetchTests: doFetchTests
        })(App)
    #+END_SRC
*** Releases List
    :PROPERTIES:
    :header-args: :tangle ./src/components/releases-list.js
    :END:
    #+NAME: releases-list
    #+BEGIN_SRC js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      function ReleaseItem (props) {
        const { release } = props
        return (
          <li className='dib'>
            <a
              className="f6 ml1 mr1 grow no-underline br-pill ba ph2 pv2 mb2 dib pink"
              href={getReleaseUrl(release)}
              key={release._id}
            >
              {release.name}
            </a>
          </li>
        )
      }

      function ReleasesList (props) {
        const { releasesIndex } = props

        if (releasesIndex == null) return null

        return (
          <div className="ph3 mt4">
            <h2 className="f6 fw6 ttu tracked">Releases</h2>
            <ul className='list'>
              {releasesIndex.map(release => {
                return <ReleaseItem release={release} />
              })}
            </ul>
          </div>
        )
      }

      function getReleaseUrl (release) {
        return `/${release.name}`
      }

      export default connect(
        'selectReleasesIndex',
        ReleasesList
      )
    #+END_SRC
*** Sunburst Container
    #+NAME: sunburst-container
    #+BEGIN_SRC js :tangle ./src/components/sunburst-container.js
      import React from 'react'
      import { connect } from 'redux-bundler-react'

      import Sunburst from './sunburst'

      const SunburstContainer = (props) => {
        const {
          currentReleaseName
        } = props
        return (
            <div id='sunburst-segment' className='pa4 flex'>
            <div id='sunburst'>
            <h2>{currentReleaseName}</h2>
            <Sunburst />
            </div>
            </div>
        )
      }

      export default connect(
        'selectCurrentReleaseName',
        SunburstContainer
      )

    #+END_SRC
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./src/components/sunburst.js
    :END:
    #+NAME: Sunburst
    #+BEGIN_SRC js
      import React from 'react'
      import { Sunburst } from 'react-vis'
      import { connect } from 'redux-bundler-react'
      import { get } from 'lodash'

      const SunburstChart = (props) => {
        const {
         sunburst,
         doUpdateQuery
        } = props

        return (
          <Sunburst
            hideRootNode
            colorType="literal"
            data={sunburst}
            height={500}
            width={500}
            getColor={node => node.color}
            onValueMouseOver={handleMouseOver}
          >
          </Sunburst>
        )
      function handleMouseOver (node, event) {
        var path = getKeyPath(node)
        doUpdateQuery({level: path[1]})
      }
      }


      function getKeyPath (node) {
        if (!node.parent) {
          return ['root'];
        }
        var nodeKey = get(node, 'data.name') || get(node, 'name')
        var parentKeyPath = getKeyPath(node.parent)
        return [...parentKeyPath, nodeKey]
      }
      export default connect(
        'selectLabelStyle',
        'selectSunburst',
        'doUpdateQuery',
        SunburstChart
      )
    #+END_SRC
    #+NAME: Sunburst Scratch
    #+BEGIN_EXAMPLE js
      import React from 'react'
      import { Sunburst, LabelSeries } from 'react-vis'
      import { forEach, get, includes, uniq, without } from 'lodash'
      import { fadeColor } from '../lib/utils'

      export default function SunburstChart (props) {
        const {
          chartLocked,
          endpoints,
          focusChart,
          focusPath,
          interiorLabel,
          lockChart,
          setEndpointTests,
          sunburst,
          unfocusChart,
          unlockChart
        } = props

        if (sunburst == null) return null
        return(
            <div className="sunburst-wrapper">
            <Sunburst
          hideRootNode
          colorType="literal"
          data={sunburst.data}
          height={500}
          width={500}
          getColor={node => node.color}
            >
          </Sunburst>
            </div>
        )

        function determineColor (node) {
          if (focusPath.length > 0 && !node.checked) {
            if (!node.color) {
              // return node.color = node.color
              node.checked = true
              return node.color = 'rgba(255,255,255,0.1)'
            } else if (node.parent && includes(focusPath, node.name) && includes(focusPath, node.parent.data.name)) {
              node.checked = true
              var brightColor = fadeColor(node.color, '1')
              return node.color = brightColor
              // return node.color = 'rgba(255,218,185,1)'
            } else {
              var fadedColor = fadeColor(node.color, '0.1')
              node.checked = true
              //         return node.color = 'rgba(255,218,185,1)'
              return node.color = fadedColor

            }
          }
          node.checked = false
          return node.color
        }

        function handleMouseOver (node, event) {
          if (!chartLocked) {
            focusChart(getKeyPath(node))
          }
        }

        function handleMouseOut () {
          if (!chartLocked) {
            unfocusChart()
          }
        }

        function handleClick () {
          if (chartLocked){
            unlockChart()
          } else if (!chartLocked && focusPath.length > 3) {
            var endpointTests = getEndpointTests(focusPath)
            setEndpointTests(endpointTests)
            lockChart()
          } else {
            lockChart()
          }
        }

        function getKeyPath (node) {
          if (!node.parent) {
            return ['root'];
          }
          var nodeKey = get(node, 'data.name') || get(node, 'name')
          var parentKeyPath = getKeyPath(node.parent)
          return [...parentKeyPath, nodeKey]
        }

        function getEndpointTests (focusPath) {
          var endpointTests = []
          var pathSansRoot = without(focusPath, 'root')
          var lockedEndpoint = get(endpoints, pathSansRoot)
          forEach(lockedEndpoint, (method) => {
            for (var test of method.tests) {
              endpointTests.push(test)
            }
          })
          return uniq(endpointTests)
        }
      }
    #+END_EXAMPLE
** Pages
   :PROPERTIES:
   :header-args: :tangle ./src/pages/main-page.js
   :END:
   #+NAME: Main Page
   #+BEGIN_SRC js
     import React from 'react'
     import { connect } from 'redux-bundler-react'

     import ReleasesList from '../components/releases-list'
     import SunburstContainer from '../components/sunburst-container'

     function MainPage () {
       return (
           <main id='main-splash' className='min-vh-80 pa4 flex'>
           <h2>You are doing a good job.</h2>
           <ReleasesList />
           <SunburstContainer />
           </main>
       )
     }

     export default connect(
       MainPage
     )
   #+END_SRC

   #+NAME: old main page
   #+BEGIN_EXAMPLE js
     import { createStructuredSelector } from 'reselect'

     import { focusChart, doLockChart, unfocusChart, doUnlockChart } from '../actions/charts'
     import { doChooseActiveTest, doCloseActiveTest, doSetEndpointTests } from '../actions/tests'

     import {
     selectActiveTest,
     selectChartLocked,
     selectEndpointTests,
     selectEndpointsWithTestCoverage,
     selectFocusPathAsArray,
     selectFocusPathAsString,
     selectInteriorLabel,
     selectRelease,
     selectReleaseNamesFromEndpoints,
     selectIsSunburstReady,
     selectIsTestsReady,
     selectSunburstByReleaseWithSortedLevel
     } from '../selectors'

     import SunburstSegment from '../components/sunburst-segment'
     import TestsContainer from '../components/tests-container'

     class MainPage extends Component {
     render(){
     const {
     activeTest,
     chartLocked,
     closeActiveTest,
     doChooseActiveTest,
     endpoints,
     endpointTests,
     focusChart,
     focusPath,
     focusPathAsString,
     interiorLabel,
     isSunburstReady,
     isTestsReady,
     lockChart,
     release,
     setEndpointTests,
     sunburstByRelease,
     unfocusChart,
     unlockChart
     } = this.props


     return (
     <main id='main-splash' className='min-vh-80 pa4 flex'>
     <h2>You are doing a good job.</h2>
     {isSunburstReady && <SunburstSegment
     sunburst={{data: sunburstByRelease.dataByRelease[release]}}
     chartLocked={chartLocked}
     endpoints={endpoints[release]}
     focusChart={focusChart}
     unfocusChart={unfocusChart}
     lockChart={lockChart}
     unlockChart={unlockChart}
     setEndpointTests={setEndpointTests}
     release= {release}
     focusPath={focusPath}
     focusPathAsString={focusPathAsString}
     interiorLabel={interiorLabel}
     />
     }
     <div>
     <TestsContainer
     closeActiveTest={closeActiveTest}
     interiorLabel={interiorLabel}
     isTestsReady={isTestsReady}
     chartLocked={chartLocked}
     activeTest={activeTest}
     chooseActiveTest={doChooseActiveTest}
     endpointTests={endpointTests}
     />
     </div>
     </main>
     )
     }
     }

     export default connect(
     createStructuredSelector({
     activeTest: selectActiveTest,
     chartLocked: selectChartLocked,
     endpoints: selectEndpointsWithTestCoverage,
     endpointTests: selectEndpointTests,
     focusPath: selectFocusPathAsArray,
     focusPathAsString: selectFocusPathAsString,
     isSunburstReady: selectIsSunburstReady,
     isTestsReady: selectIsTestsReady,
     interiorLabel: selectInteriorLabel,
     release: selectRelease,
     releaseNames: selectReleaseNamesFromEndpoints,
     sunburstByRelease: selectSunburstByReleaseWithSortedLevel
     }),
     {doChooseActiveTest,
     closeActiveTest: doCloseActiveTest,
     focusChart,
     lockChart: doLockChart,
     setEndpointTests: doSetEndpointTests,
     unfocusChart,
     unlockChart: doUnlockChart
     })(MainPage)
   #+END_EXAMPLE
* Glossary
** Bundle (<<<bundles>>> | <<<bundle>>>)
   a collection of redux code all organized by some concern or idea.  It's a marked difference from the typical organizing style, where you organize files by what they are (reducers, selectors, etc.).  This, instead, organizes files by their topic.
** Component (<<<Component>>> | <<<Components>>>)
Self-contained, presentational parts of our front-end site.  It is what people actually see and interact with on our site.  What is unique is how specific and reusable components are.  Every singular bit of the api should essentially be a component.  We do this because it is easier to build upon, to collaborate with others, to maintain, and to share components across other projects.
** Dynamic Web App (<<<dynamic web app>>>)
A site whose content and presentation is determined by code that is run when the site is first loaded.  As opposed to a static web site, where the content is already generated and delivered to you from the server when you log on.  The upside is that it allows for a robust site that is tailored to individual visitors, who can navigate around the area quickly and easily.  The downside is that they can be resource heavy, and do not work on browsers that have disabled javascript.
** Client-Side (<<<client-side>>>)
Refers to  code that is run on the client (as opposed to on the server).  The client is most often the web browser.  So a client-side app, if done well, allows for a quick data fetch from the server and then a snappy full-powered web app since all the functionality is being handled by the browser itself
** <<<static web site>>>
A site whose content is pre-set, and not made based on the actions of the site visitor or their browser.  Original html sites are static (coolguy.website being an example).  Apisnoop is dynamic.  You can see the differenve by viewikng the source code of their index.html files.  coolguy has all the code written directly in the file.  apisnoop has nothing except a javascript file waiting to be run.
** <<<immutable state>>>
In our context, state refers to the state of the app.  Immutable means that it cannot be changed. So this means, whenever there is any action that should change the state we replace the entire state.  For example: the current state might hold values like the current URL, and that we are currently fetching data and it's pending.  When the data fetch is accomplished, we want to update the state.  We do this not by looking for our 'DATA' value and adjusting it.  Instead, we replace the state entirely, with our new state being the same url but now 'data fetch fulfilled'.

Doing it in this way means we can have a snapshot of the state for every update to it.  If we wanna see what the app looked like before the data was fetched, we can simply go back to the state when it was still pending.  This makes the site easier to debug and easier to maintain.

It is a core principle or [[#arch-redux][redux]], and brought up often when discussing redux apps and functional programming.
** <<<selector>>> | <<<selectors>>>
a concept within [[#arch-redux][redux]].  A selector will 'select' data in our redux store, potentially make changes to it, and then give it to our components.  It is a [[arch-redux-bundle][redux bundle]] best practice to never have the componets draw from the redux store directly, and instead always get it from selectors.  This sets up a pattern where the store remains 'dumb', which makes it easier to debug.

 For example, let's say in our app we fetch release names from a server and they come to us like this:
- release_1.12.3
- release_2.4
- release_1.3.1

We want to take these names and display them on the frontpage of the site, but we want them to be sorted, and cleaned up to not have underscores and have relase be capitalized.  We _could_ adjust them as they get added to our store, by doing some quick sort and replace functions in our reducer.  But this will make it harder to reason about later, or compare it to the equivalent files in our server.  Instead, we just want to have raw data in our redux store, have a selector select it, and have the selector do the sorting and cleanup.  This way, if there's an issue with the basic data we check redux.  If there's an issue with sorting or capitalization, we check the selector.  We don't ahve to check some helper function nested inside a reducer store or some other hard to debug thang.
** <<<Reducer>>> | <<<Reducers>>>
 An immutable object containing the current state of the app.  Driving principle of [[#arch-redux][redux]].  Called a reducer because it takes a number of objects given to it and reduces it down to a single thing.  By object, we mean it in the literal javascript sense...and so the entire state of a complex app can be represented as:

#+BEGIN_EXAMPLE
{ name: 'something',
  users: ['list', 'of', 'users'],
  current_path: '/@timothee/profile'
}
#+END_EXAMPLE

In other words, we take a lot of complexity and reduce it down to a text object that can be easily updated or replaced. This brings us closer to designing an app as a spreadhseet, where the frontend is just displaying the data in pleasing way, and the backend has a consistent and logical way to add and amend the data.
** <<<action>>> | <<<actions>>>
In our context, an object that announces a change in state, along with a payload of data for that change.  Actions are represented as so:

#+NAME: example action
#+BEGIN_EXAMPLE
{
  type: 'NEW_USER_ADDED',
  payload: userData
}
#+END_EXAMPLE

So actions always have a type and a payload.  The type is written like a news headline, and the payload can be anything (a string, an object, an array, an integer, etc).  For more info, check out our conventions section.
** <<<action creator>>>
A function that creates an action.  They are written as 'doThisAction', so in the example above, we might have a function called 'doAddNewUser', and running the function results in the action object above.
** <<<reactor>>> | <<<Reactors>>>
 A special type of selector, that is set up to listen to conditions that should prompt an action.  An example might be if you wanted your app to attempt another data fetch if the first one failed.  You'd have a reactor that was waiting for a 'DATA_FETCH_FAILED' action, and when that came it would trigger a 'DATA_FETCH_STARTED' action in response.  Reactors bring us closer to a clearly separated app, where the reducer just holds data, the components just display the data given, and selectors and reactors handle the rest.
** Store (-<<<store>>>)
Kinda used interchangable with state, and short for redux store.  It refers to the big object containing the entire state of the app.
** State (<<<State>>>)
  All the data, properties, truths, and so on of the app at this moment in time.  Similar to your emotional, personal, physical state.

* isocket
** Connecting the left pair / isocket

 ssh needs '-t' twice because it needs to be forced to allocate a remote terminal
 _even_ when we don't have have local one (within emacs)


#+NAME: left_session_create
#+BEGIN_SRC shell :var session="zz-left" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n emacs \
      emacs --fg-daemon=$session" \
  &
#+END_SRC

#+NAME: left_session_setup
#+BEGIN_SRC shell :var session="zz-left" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  ssh -att $user@$host \
  "tmate -S /tmp/.$session.isocket \
        new-window \
        -n client" \
   "emacsclient -nw \
              --socket-name $session \
              ~/apisnoop/webui/web_ui.org"
#+END_SRC

 #+NAME: left_session
 #+BEGIN_SRC shell :wrap "SRC text :noeval" :results verbatim :var session="zz-left" user="zz" host="apisnoop.cncf.io" :results silen
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket wait tmate-ready > /dev/null &&
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\' 2> /dev/null
# ssh -tt root@apisnoop.cncf.io \
#  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS: left_session
 #+BEGIN_SRC text :noeval
 #+END_SRC

*** Connecting to emacs daemon

#+NAME: alse run emacsclient
#+BEGIN_SRC tmate :noeval
export SESSION=lt-emacs
emacsclient --socket-name $SESSION
#+END_SRC

** Connecting the right pair / isocket

#+NAME: right_session_create
#+BEGIN_SRC shell :var session="zz-right" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n misc" \
  &
#+END_SRC


 #+NAME: right_session_join
 #+BEGIN_SRC shell :results silent
 export SESSION=api-snoop
 export XTERM_EXEC="roxterm -e"
 $XTERM_EXEC ssh -Att root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
   at \; sleep 9999
 #+END_SRC

 #+NAME: right_session_setup
 #+BEGIN_SRC shell :results verbatim
 export SESSION=api-snoop
 echo ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
    new-window -n session \
     bash
 #+END_SRC

 #+NAME: right_session
 #+BEGIN_SRC shell :cache yes :wrap "SRC text :noeval" :results verbatim
 export SESSION=api-snoop
 ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS[dd96525b42bbbe741e292e99ad5f3592a7163025]: right_session
 #+BEGIN_SRC text :noeval
 ssh mJrsCgvGTOTOFagYpBKvRf7EE@sf2.tmate.io
 #+END_SRC





 #+NAME: give this to your pair
 #+BEGIN_SRC bash :noweb yes :var left_session=left_session() right_session=right_session()
 echo "ii pair session ready
 left: $left_session
 right: $right_session
 "
 #+END_SRC

 #+RESULTS: give this to your pair
 | ii     | pair | session | ready |
 | left:  | nil  |         |       |
 | right: | nil  |         |       |
 |        |      |         |       |

** TODO Sharing your eyes

#+NAME: give this to your pair
#+BEGIN_SRC bash :noweb yes :var left_session=left_session() :var right_session=right_session()
echo "ii pair session ready
left: $left_session
right: $right_session
"
#+END_SRC
* Tasks                                                            :apisnoop:
** DONE get basic webpage working with redux bundler
   CLOSED: [2018-12-05 Wed 11:29]
   just get it to say hello at least
** DONE bring back our headers and footers to basic page
   CLOSED: [2018-12-05 Wed 14:22]
** DONE add glossary of common react/redux terms.
** NEXT get releaseNames showing on app page
** TODO Choose Current Release and Sync with URL
** TODO When URL shows current release, fetch current release and endpoints and test
** TODO Render Chart with data from Current Release
** TODO Better understand the use of resource as a bundle name.  Is this temporary, or a good pattern?
   SCHEDULED: <2018-12-06 Thu>
** TODO Share a link to a build and the build loads quickly
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/15][issue link]]
** TODO Share a link to a chart filtered to an endpoint
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/12][gitlab link]]
  this would be filtered to level, category, endpoint, and method.  iT shoudl show the chart locked and highlighted.
** TODO Webui loads meaningful chart within seconds
   SCHEDULED: <2018-12-06 Thu>
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/9][gitlab link]]
  before any data lods, there'll be a chart outline to signify loading.  But the data should still come quickly.
** TODO We have distinct dev and prod environments for the client
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/11][gitlab link]]
  interesting note for debugging for production.  Redux dev-tools is built into redux bundle, and can be turned on or off based on if local.storage.debug is set to true or false.  From the  [[https://reduxbundler.com/guides/patterns.html][redux-bundle documentation]]:
===
Using Redux DevTools
Both the debug bundle and redux dev tools are enabled if localStorage.debug is set to something "truthy". In this way you can keep your production apps debuggable, you just have to flip that localStorage.debug flag to enable it. Also beware that running localStorage.debug = false in your browser console won't actually turn it off. This is because LocalStorage serializes everything to strings so the value that's stored is actually the string "false" which... is truthy! So to turn it back off again, you can just do: delete localStorage.debug instead.
===
** TODO [3/15] Future Tasks
   - [ ]  Integrate user interaction with sunburst (filter by UserAgent).  This'll test our hypothesis that we can manipulate the data far quicker than before.
   - [X] Hover over Part of Sunburst shows relevant rays highlighted.
   - [X] Hover over Sunburst, see testing percentage update in center.
   - [ ] Click on Useragent, sunburst zooms onto that subset of data.
   - [ ] Refactor Chart Selector to not be heavily nested..
   - [ ] Move colors calculation out of sunburst selector into its own thing.
   - [ ] Separate sunburst selector thangs from chart interaction thangs (maybe?  may be premature optimization).
   - [X] Remove unused props from app.js
   - [ ] Make each test Sequence an object, instead of an array. or at least ask someone if that's really necessary?  Maybe not necessary.
   - [ ] Improve performance of page load, by only calling a test when needed.
   - [ ] Refactor tests so the entire object isn't being loaded in the client.  That feels way too heavy, and instead you should only load up the testInfo (all the api endpoints being accessed) when there is an active_test, and you display that only on that active test.
   - [ ] When you click on an endpoint, it adds to the URL so that you can share the URL and have be right on the hovered sunburst with the filtered tests and such.
   - [ ] add queryString to our arsenal, so you can do a direct url to an endpoint
   - [ ] Change endpoint path so it displays UNTESTED for the whole untested block (currently displaying random endpoint name).
   - [ ] Add logic to API to filter endpoints to only those touched by e2e. We are showing all.  It'll be faster, and simpler to only be ones whose useragents includes the regex string 'e2e.test'

** TODO consolidate notes from last mikey pair (the note left about the role of the url)
   SCHEDULED: <2018-12-06 Thu>
  it is in patchwork .  Find it and add it after!

** DONE [11/11] Tasks For Refactoring our Data and understanding of it.
   CLOSED: [2018-11-07 Wed 21:01]
   - [X]  Convert JSON dump to New Flat Database
   - [X] Hookup react/redux to query endpoints.
   - [X] Integrate Reselect to computed data views (instead of getting data, withoutm assaging, and trying to fit it into the sunburst.)
   - [X] Practice Converting flat database to Sunburst Data structure.
   - [X] Sort Level so it is Stable, Beta, Alpha
   - [X] pass down chart selector data to main page props, pass down focused key path to render label within sunburst
   - [X] Add Percentage Calculation to center label.
     - I think I would want to do a data transformation, that counts the isTested for each of the child nodes, and piles that into an equation in the parent node.
     - How much of the existing work can I use with this?
     - STRATEGY: we've added the coverage to our endpoints information.  So we could now have a 'coverage' selector that listens to the full path array and finds the coverage information in the endpoints for it.  We don't need to do any extra action, we just need to work off our existing stuff.
     - If nothing is set, then we are going to want to know the coverage by release.  So the first step, then, would be: 'Without Focus Path selectInteriorLabel = endpoints[release][coverage]' with focus path it would be endpoints[release][fp1][fp2][coverage]...i guess based on the full apth length (it could be up to 3, level, category, endpoint).
   - [X] Fix routing so activeRoute isn't hard-coded.
   - [X] re-hook up routing to route by release name
   - [X] Query endpoints by Release.
   - [X] remove dependency on releaseStore reducer.
** DONE [10/10] Achievements To Unlock to match and surpass old webui
   CLOSED: [2018-11-06 Tue 13:49]
   - [X] Mikey has a functional understanding of what we're trying to do.
   - [X] It generally feels better
   - [X] Sunburst Changes Based on Route
   - [X] It loads faster
   - [X] When you click on a test, it lists the endpoints sequence.
   - [X] Add testTags to our endpoint api
   - [X] When you hover on an endpoint, it shows the test tags.
   - [X] When you click on an endpoint, it locks the chart in place.
     - [X] Add 'clicked' as state in sunburstChart, following the same logic in the [[https://github.com/uber/react-vis/blob/master/showcase/sunbursts/basic-sunburst.js][react-vis tutorial]]
     - [X] When you mouseOut, if clicked isn't true //then// send out the clearing of focusPath.  Otherwise, keep it.
   - [X] When you click on an endpoint, it filters the list of tests to just the ones that touch that endpoint.
     - [X] Devise strategy: when you click on a node you have the focus path as an array, which would end with an endpoint (if we are on an endpoint, otherwise it'd show the category or level). We have tests who each have an endpoint listed within them.  Maybe we query our db at that point for tests?endpointsIncludeEndpointName, or something similar to that.  Then, we change the logic beneath to only show tests once an endpoint is clicked, and it's based on the tests we retrieve...
     - [X] Doublecheck our releases for tests, to see how it be structured:  it goes release.data.tests.count.endpoints.  These endpoints //look// to correspond with our endpoint names pretty nicely.  But I think this means we'll have to separate out the tests into their own endoint too. It'd be best if it was just called 'tests', but we already ahve that for test_sequence.  how hard is it to switch that over?
   - [X] When you view the endpoint sequence, it is single line with a timestamp of HH:MM:SS:ss and then the rest of the info.
** DONE Change front-end logic so it only pulls data from the necessary sunburst.
   CLOSED: [2018-11-04 Sun 22:29]
   Right now the we have an endpoint called /Releases, organized by Build name.  These correspond to the sunbursts.  We are pulling in the entire api, we should only do buildname.data.sunburst
*** [3/4] Subtasks
    - [X] Remove excess noise from front-end for right now--the filters essentially.
    - [X] Add URL path to each Release you click
    - [X] Add fetchSunburst action to sunburst segment component, and pass it along the url params.
    - [ ] Query the api database based on the params and return just the sunburst data.`
** DONE change keypath logic so it only highlights if parent is on keypath.
   CLOSED: [2018-11-04 Sun 22:30]
** DONE-AND-SHARED [6/6] Add Test Information To Webui
   CLOSED: [2018-11-06 Tue 03:37]
   - State "DONE-AND-SHARED" from "NEXT"       [2018-11-06 Tue 03:37]
   When I am looking at a release,  I can see both the sunburst and a list of tests that happen with this release, so that I have more context on what is actually happening with our test coverage.
   When I click on a test, I can see a chronological list of the endpoints it accesses, so I can understand what this test is doing and if it is necessary.
- [X] Add unique api endpoint for tests
- [X] Bring the tests into our redux store when app first loads.
- [X] Massage data to group by release, using same format as our endpoints
- [X] list tests to side of sunburst
- [X] clicking on a test makes it the 'active_test', which updates state.
- [X] When there is an active_test, display its chronological list.  does not need to be styled fancy.

** DONE-AND-SHARED Visually distinguish tested endpoints tagged [Conformance]
   SCHEDULED: <2018-12-06 Thu>
   - State "DONE-AND-SHARED" from "DONE"       [2018-12-05 Wed 14:22]
   [[https://github.com/cncf/apisnoop/issues/46][Github Issue]].  So we can do a bit of regex on the endpoint...though I thionk each one has a test tag and those would include conformance...right?
