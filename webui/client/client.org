#+NAME: APISnoop WebUI Client
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:tmate :socket "/tmp/.zz-left.isocket"
#+PROPERTY: header-args:tmate :session api:main

* Introduction
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
** Reimagining how the web app is built.
   At this point, the work here is a proof of concept refactoring of the orignal site, to make our structure more extensible and modular.  When new work is done with the dating processing, we want to be able to quickly visualize the results of this work for others.  The current site is static html, with each new section intentionally and manually hard-coded. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new element.  We have to keep a mental map of every aspect of the site this new dataset should influence and update those accordingly.  Not only is this time-consuming, it's error-prone and hard to maintin.

   At the same time, there was a good amount of work done by the team to get to the current site, and that work should be preserved as much as possible.  The goal of this refactor, then, is to re-make the original site to then build incredible things beyond and above it.
http://uber.github.io/react-vis/documentation/other-charts/sunburst-diagram
** Setting It up On Your own
*** Setup Backend
 after cloning repository
- cd apisnoop/backend
- npm install
- Make sure we have a jsons folder in apisnoop/backend with this tree structure:
#+RESULTS: File Structure
:RESULTS:
.
├── release
└── sunbursts

2 directories
:END:
#+NAME: File Structure
#+BEGIN_SRC shell :dir ./backend/jsons :results output raw drawer
tree -d
#+END_SRC
- Delete all .db's from src/data/
- npm start
- email zz@ii.coop with full error output and a coupon for soda.

*** Setup Client
    When backend server is on:
    - cd apisnoop/client
    - npm install
    # - figure out how to point to subheadings
    - go to [[Client/Actions/index.js]]   and change the client here to be whatever site you have this on (localhost or apisnoop)
    - npm start

** Running the Client
  In the web ui folder:
 ===
 cd client
 npm install
 npm start
 ===
 Then navigate to localhost:3000, if it isn't already opened for you.
* Architecture
** React
** Redux-Bundler
*** Resources
    - [[https://reduxbundler.com/][redux bundler homepage]]: documentation with good api references
    - [[https://read.reduxbook.com/][Human Redux]]: book by Henrik Joreteg about working with redux.  A lot of our principles are inspired by this book, and explained in better detail here
** Tachyons
* Principles
** Presentation is Separate from Logic
   the components do not care about the data, or affect the data.  They only present the data given to them.
** Reducers are dumb and that's a good thing
   the reducer is a continually replaced object that holds the current state of the app.  We want the reducer to be as dumb and simple as possible...so no if/else statements or functions that define what the value of some part of the state should be.  It only holds the clean, proper value
** Our logic is done through selectors and reactors
* File Structure
* Initiatory Code
** index.js
   :PROPERTIES:
   :header-args: :tangle ./src/index.js
   :END:
   #+NAME: index.js
   #+BEGIN_SRC js
     import React from 'react'
     import { render } from 'react-dom'
     import './index.css'

     import { Provider } from 'redux-bundler-react'

     import App from './components/app'
     import createStore from './bundles'

     var store = createStore()

     // document.title = 'APISnoop | ' + store.getState().routing.release

     render(
         <Provider store={store}>
         <App />
         </Provider>,
       document.getElementById('root')
     )
   #+END_SRC
* Components
** App
   :PROPERTIES:
   :header-args: :tangle ./src/components/app.js
   :END:
   the initiatory component.  This is sort of the standard layout in which all other views are placed within.
   #+Name: App.js
   #+BEGIN_SRC js
     import React from 'react'
     import { connect } from 'redux-bundler-react'

     export default connect(
       ({}) => (
           <div>
             <h1>hello</h1>
           </div>
       )
     )
   #+END_SRC

   #+RESULTS: App.js

* Bundles
** index
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/index.js
   :END:
   This is the root bundler, that takes all the other individual ones and composes a single super bundle.
*** Import modules and bundles
    We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.
    #+NAME: bundle index: Import modules and bundles
    #+BEGIN_SRC js
      import { composeBundles } from 'redux-bundler'
      import zachBundle from './zach.js'
    #+END_SRC
*** Compose Bundle
    Then, we compose the bundles into a single store, listing all the ones we imported above.
    #+NAME: bundle index: compose bundle
    #+BEGIN_SRC js
      export default composeBundles(
        zachBundle
      )
    #+END_SRC

** zach
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/zach.js :noweb yes
   :END:
   This is a made up bundle, just to get a good idea of how it works.  We'll just import this one into our full app to show that it's actually working.
*** Basic Layout
    #+NAME: zach bundle basic layout
    #+BEGIN_SRC js
      export default {
        name: 'zach',
        <<Zach Reducer>>
      }
    #+END_SRC
*** Reducer
    #+NAME: Zach Reducer
    #+BEGIN_SRC js :tangle no
      reducer:  (state = [], action) => {
        return state
      }
    #+END_SRC
*** Selectors
*** Actions
*** Reactors
* Footnotes
** Resources
*** d3
**** [[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][interactive applications with react-d3]]
     this is really good.
**** [[https://www.smashingmagazine.com/2018/02/react-d3-ecosystem/][Bringing Together react, d3, and their ecosystem]]
**** [[http://www.adeveloperdiary.com/react-js/integrate-react-and-d3/][How to Integrate React and d3 the right way]]
**** [[https://bost.ocks.org/mike/join/][Thinking with Joins]]
*** react/redux
    - [[https://read.reduxbook.com][Human Redux, by Henrik Joreteg]]

** isocket
*** Connecting the left pair / isocket

 ssh needs '-t' twice because it needs to be forced to allocate a remote terminal
 _even_ when we don't have have local one (within emacs)


#+NAME: left_session_create
#+BEGIN_SRC shell :var session="zz-left" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n emacs \
      emacs --fg-daemon=$session" \
  &
#+END_SRC

#+NAME: left_session_setup
#+BEGIN_SRC shell :var session="zz-left" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  ssh -att $user@$host \
  "tmate -S /tmp/.$session.isocket \
        new-window \
        -n client" \
   "emacsclient -nw \
              --socket-name $session \
              ~/apisnoop/webui/web_ui.org"
#+END_SRC

 #+NAME: left_session
 #+BEGIN_SRC shell :wrap "SRC text :noeval" :results verbatim :var session="zz-left" user="zz" host="apisnoop.cncf.io" :results silen
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket wait tmate-ready > /dev/null &&
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\' 2> /dev/null
# ssh -tt root@apisnoop.cncf.io \
#  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS: left_session
 #+BEGIN_SRC text :noeval
 #+END_SRC

**** Connecting to emacs daemon

 #+NAME: alse run emacsclient
 #+BEGIN_SRC tmate :noeval
 export SESSION=lt-emacs
 emacsclient --socket-name $SESSION
 #+END_SRC

*** Connecting the right pair / isocket

#+NAME: right_session_create
#+BEGIN_SRC shell :var session="zz-right" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n misc" \
  &
#+END_SRC


 #+NAME: right_session_join
 #+BEGIN_SRC shell :results silent
 export SESSION=api-snoop
 export XTERM_EXEC="roxterm -e"
 $XTERM_EXEC ssh -Att root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
   at \; sleep 9999
 #+END_SRC

 #+NAME: right_session_setup
 #+BEGIN_SRC shell :results verbatim
 export SESSION=api-snoop
 echo ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
    new-window -n session \
     bash
 #+END_SRC

 #+NAME: right_session
 #+BEGIN_SRC shell :cache yes :wrap "SRC text :noeval" :results verbatim
 export SESSION=api-snoop
 ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS[dd96525b42bbbe741e292e99ad5f3592a7163025]: right_session
 #+BEGIN_SRC text :noeval
 ssh mJrsCgvGTOTOFagYpBKvRf7EE@sf2.tmate.io
 #+END_SRC





 #+NAME: give this to your pair
 #+BEGIN_SRC bash :noweb yes :var left_session=left_session() right_session=right_session()
 echo "ii pair session ready
 left: $left_session
 right: $right_session
 "
 #+END_SRC

 #+RESULTS: give this to your pair
 | ii     | pair | session | ready |
 | left:  | nil  |         |       |
 | right: | nil  |         |       |
 |        |      |         |       |

*** TODO Sharing your eyes

#+NAME: give this to your pair
#+BEGIN_SRC bash :noweb yes :var left_session=left_session() :var right_session=right_session()
echo "ii pair session ready
left: $left_session
right: $right_session
"
#+END_SRC
** Working with d3
*** Introduction
   d3 is the data visualization library that was used to make our original sunburst.  The way it works is to mount itself to the dom, and then appends new elements to the dom based on the data it was given. If that data changes, it transforms the elements as needed.

   The way react works is it attaches itself to the dom, then creates a //shadow dom// that it is continually listening to, adding and removing elements in this dom as needed based on the data(the state) it was given.

   In other words, they work in largely the same way, and both wanna attach themselves to the dom and manipulate it.  This...isn't good.  We want to have /1/ thing making shadow doms and calls on the website, and so it is a bit tricky to get react and d3 working together.

The upside is that a number of people have tackled this challenge and created different react/d3 libraries for how the two can work together.  The downside is that I'm not sure yet which is the best to do.

Put simply, it is not easy to take our existing sunburst code and just paste it into our new app.  We are going to need to transform it in some way based on the guidance of the library we are using.

So the question is why we are putting ourselves into this trouble?
*** WHY WE ARE PUTTING OURSELVES INTO THIS TROUBLE
    My assumption with all of this is that when people hear 'apisnoop', they are thinking of the site in which you can see the data visualziations.  And so the webapp is important for the project and will be expanded.  React would be great for this in the long run.

Similarly, I am expecting that we are going to have more types of visualizations than just the sunburst--and that even the sunburst may change.  So we are going to want to have an understanding for a language in which we can make a //bunch// of visualizations. d3 is great for this.

If we do it right, we can have reusable components too that other teams could use for their own k8s projects, and that we could use ourselves.  For example--displaying two sunburst charts side by side would be much easier in react/d3 then what i ws trying to do before (appending both to the same id on a standard html document.)  This requires that I move through some d3 tutorials though.

At the end of this, though, we will have a backend server that is easy to setup and can ping different url's (github repos or testgrid artifacts) and grab their data.  Then, we can manipulate that data in whatever way we want but also pass it along to our frontend.  This front-end can then have different options and tags setto really dive in and explore.

If this is the purpose of apisnoop then let's do it.  If it's too much overkill though, then I can try a simpler solution.
*** Possible Process to get going
**** Setup a simple d3 visualization to understand the process
**** pipe data into this simple visualization through our redux state.
**** Pore over the original code again (the original blog post) to see how to best convert it
**** Change the sunburst's origin point from a CSV file to JSON
**** Change the sunbursts origin point from JSON to our redux store.
*** Second Process
**** Setup different pages for different d3-react libraries that already have ubilt components.
**** explore piping our data into the one we like.
**** Use testgrid conformance data and make simple visualizations to it.
     We are wanting to keep the data retrieval tied into the visualizing, so we dont' end up with a pretty graph that can't be used for what we have.  So we can grab the testgrid stuff now and see what we can do with it.


**** Use that going forward.
*** Possible Libraries to use
**** Victory
     https://formidable.com/open-source/victory/
**** Britecharts react
     https://eventbrite.github.io/britecharts-react/
**** Recharts
     http://recharts.org/en-US/
** Aaron Feedback
- useful troubleshooting tool:
  - adding test names to user agents to verify a test was testing what we thought it was.
  - filter audit logs by user-agent and then see 'when this test case is run, here are the endpoints it accesses chronologically".
    - This is separate from number of times hit.  that is useful in aggregate, this is something different.
  - pulling in an audit log of timestamp/verb/uri
- Feature of pointing to the specific line in the source for each test, to pull its definition, would be a good //Next// step.
  - This is something we can do with whakapapa, but it's not something we have now.
- Discovery front: Filtering more endpoints from APIsnoop's definition of coverage.
  - If beta endpoints always get hit because an api server is doing discovery, then that's cool but nothing we can ever prevent conformance tests from doing and we shouldn't care about it from a test coverage perspective.
  - How do we signify that this is the kinda hit that's happening for an endpoint?
  - We have a good start with filtering to just e2e, but even our e2etests are hitting those endpoints.  There are some endpoints where, logically they don't need to get tested or anything like that.
  - Get to a point whwere we can manually specify, or have a blacklist of apiendpoints that we aren't factoring into our coverage viz.
  - One way to do this is to filter out the endpoints that are hit by nearly all of the tests.  This is a good indicator that the endpoint is for initialization or something like that, and not actually a part of this test's function.
- Unique Endpoints hit by a test: this is something that isn't covered by our sunburst or katherine's viz.  Pick a test, and then see the endpoints that are //only// hit by this test.
  - which endpoints hit are unique, versus which ones are common across all test cases.  This would let us know which test cases are doing good stuff and which endpoints are essentially meaningless.
  - you could have a center endpoint change to the perspective of that test, and then that test would only show the endpoints that it hits.....but that may not be that useful.  We dont' wanna see All the endpoints, we wanna see which ones are //special// for this test.
  - Hierarchy vizes aren't that useful.
  - I just wanna find a way to slice and dice data with raw queries and see where that leads us...and take some of the more useful queries and generate reports from that.  This sounds like a new approach for apisnoop.

Question from this, then: Who is apisnoop's audience?  Is it Aaron,and people like aaron?  is it a kubernetes end user?  If it's aaraon, he is saying he knows how to write certain queries, but he would rather have this  already done and then he can do further exploration.
'For an endpoint that's only hit three times, what are the tests that are hitting this endpoint.  And then we could follow up with what the tests are doing from an api perspective.  'Okay, now let me see the full api stream from this test."
 - auotmate this, or provide shiny reports for this.  This isn't the end user coming up with the interesting things, this is us coming up with interesting things that we are letting the end user come to their own conclusions on.
 - We eventually want to show api coverage going up over time across different builds. o
 - We might be able to format things in such a way to have a test dashboard that shows individual api endpoints and #'s: how many times they been hit, something like that.
 - Is code coverage a different thing?  when talking about it being a command line tool that generates reports from it...or is that just what the group is trying to do.  the benefit of the command line tool is that you can automate it running for every build. We could then just have a page that displays these reports even maybe.
 - We want to share shinies at kubeconf china.
 - Get visualization up to good place that replaces existing visualization.
 - Showing all the api accesses per user-agent or test as a different Dashboard to have.
 - Take care of you for whatever demos you need for apisnoop.
 - It would be worth it to show we're providing value to cncf as a whole, but right now it's good to just be able to have Aaron say that the work we're doing makes it easier for conformance to do the things they want to do.
 - Let's not work on things that don't end up providing value, over-delivering when he really just wants somethings maller and specific.  He's happy to have some reports that don't need to be that shiny, but maybe a little bit interactive.  and these reports would be:
   - If I click on a user agent, I can see the in-order access of all the api endpoints.
   - To get some kind of report that shows me what kind of endpoints don't matter (every test hits them) and which ones are interesting (cos only a few endpoints hit them) and what are those tests?
     - this may lead to a point where we try to make a whitelist of endpoints in our coverage, but let's not cross that bridge yet.
   - For wednesday deadline...this isn't a hard deadline, we can touch base on Tuesday/Monday and see where we at.
** Pairing With Mikey
*** Background
    I went through a pairing Session with [[https://dinosaur.is][Mikey]], to help with the overall architecture and code logic of the webui
* Tasks
** TODO Visually distinguish tested endpoints tagged [Conformance]
   [[https://github.com/cncf/apisnoop/issues/46][Github Issue]].  So we can do a bit of regex on the endpoint...though I thionk each one has a test tag and those would include conformance...right?
** TODO [3/15] Future Tasks
   - [ ]  Integrate user interaction with sunburst (filter by UserAgent).  This'll test our hypothesis that we can manipulate the data far quicker than before.
   - [X] Hover over Part of Sunburst shows relevant rays highlighted.
   - [X] Hover over Sunburst, see testing percentage update in center.
   - [ ] Click on Useragent, sunburst zooms onto that subset of data.
   - [ ] Refactor Chart Selector to not be heavily nested..
   - [ ] Move colors calculation out of sunburst selector into its own thing.
   - [ ] Separate sunburst selector thangs from chart interaction thangs (maybe?  may be premature optimization).
   - [X] Remove unused props from app.js
   - [ ] Make each test Sequence an object, instead of an array. or at least ask someone if that's really necessary?  Maybe not necessary.
   - [ ] Improve performance of page load, by only calling a test when needed.
   - [ ] Refactor tests so the entire object isn't being loaded in the client.  That feels way too heavy, and instead you should only load up the testInfo (all the api endpoints being accessed) when there is an active_test, and you display that only on that active test.
   - [ ] When you click on an endpoint, it adds to the URL so that you can share the URL and have be right on the hovered sunburst with the filtered tests and such.
   - [ ] add queryString to our arsenal, so you can do a direct url to an endpoint
   - [ ] Change endpoint path so it displays UNTESTED for the whole untested block (currently displaying random endpoint name).
   - [ ] Add logic to API to filter endpoints to only those touched by e2e. We are showing all.  It'll be faster, and simpler to only be ones whose useragents includes the regex string 'e2e.test'

** DONE [11/11] Tasks For Refactoring our Data and understanding of it.
   CLOSED: [2018-11-07 Wed 21:01]
   - [X]  Convert JSON dump to New Flat Database
   - [X] Hookup react/redux to query endpoints.
   - [X] Integrate Reselect to computed data views (instead of getting data, withoutm assaging, and trying to fit it into the sunburst.)
   - [X] Practice Converting flat database to Sunburst Data structure.
   - [X] Sort Level so it is Stable, Beta, Alpha
   - [X] pass down chart selector data to main page props, pass down focused key path to render label within sunburst
   - [X] Add Percentage Calculation to center label.
     - I think I would want to do a data transformation, that counts the isTested for each of the child nodes, and piles that into an equation in the parent node.
     - How much of the existing work can I use with this?
     - STRATEGY: we've added the coverage to our endpoints information.  So we could now have a 'coverage' selector that listens to the full path array and finds the coverage information in the endpoints for it.  We don't need to do any extra action, we just need to work off our existing stuff.
     - If nothing is set, then we are going to want to know the coverage by release.  So the first step, then, would be: 'Without Focus Path selectInteriorLabel = endpoints[release][coverage]' with focus path it would be endpoints[release][fp1][fp2][coverage]...i guess based on the full apth length (it could be up to 3, level, category, endpoint).
   - [X] Fix routing so activeRoute isn't hard-coded.
   - [X] re-hook up routing to route by release name
   - [X] Query endpoints by Release.
   - [X] remove dependency on releaseStore reducer.
** DONE [10/10] Achievements To Unlock to match and surpass old webui
   CLOSED: [2018-11-06 Tue 13:49]
   - [X] Mikey has a functional understanding of what we're trying to do.
   - [X] It generally feels better
   - [X] Sunburst Changes Based on Route
   - [X] It loads faster
   - [X] When you click on a test, it lists the endpoints sequence.
   - [X] Add testTags to our endpoint api
   - [X] When you hover on an endpoint, it shows the test tags.
   - [X] When you click on an endpoint, it locks the chart in place.
     - [X] Add 'clicked' as state in sunburstChart, following the same logic in the [[https://github.com/uber/react-vis/blob/master/showcase/sunbursts/basic-sunburst.js][react-vis tutorial]]
     - [X] When you mouseOut, if clicked isn't true //then// send out the clearing of focusPath.  Otherwise, keep it.
   - [X] When you click on an endpoint, it filters the list of tests to just the ones that touch that endpoint.
     - [X] Devise strategy: when you click on a node you have the focus path as an array, which would end with an endpoint (if we are on an endpoint, otherwise it'd show the category or level). We have tests who each have an endpoint listed within them.  Maybe we query our db at that point for tests?endpointsIncludeEndpointName, or something similar to that.  Then, we change the logic beneath to only show tests once an endpoint is clicked, and it's based on the tests we retrieve...
     - [X] Doublecheck our releases for tests, to see how it be structured:  it goes release.data.tests.count.endpoints.  These endpoints //look// to correspond with our endpoint names pretty nicely.  But I think this means we'll have to separate out the tests into their own endoint too. It'd be best if it was just called 'tests', but we already ahve that for test_sequence.  how hard is it to switch that over?
   - [X] When you view the endpoint sequence, it is single line with a timestamp of HH:MM:SS:ss and then the rest of the info.
** DONE Change front-end logic so it only pulls data from the necessary sunburst.
   CLOSED: [2018-11-04 Sun 22:29]
   Right now the we have an endpoint called /Releases, organized by Build name.  These correspond to the sunbursts.  We are pulling in the entire api, we should only do buildname.data.sunburst
*** [3/4] Subtasks
    - [X] Remove excess noise from front-end for right now--the filters essentially.
    - [X] Add URL path to each Release you click
    - [X] Add fetchSunburst action to sunburst segment component, and pass it along the url params.
    - [ ] Query the api database based on the params and return just the sunburst data.`
** DONE change keypath logic so it only highlights if parent is on keypath.
   CLOSED: [2018-11-04 Sun 22:30]
** DONE-AND-SHARED [6/6] Add Test Information To Webui
   CLOSED: [2018-11-06 Tue 03:37]
   - State "DONE-AND-SHARED" from "NEXT"       [2018-11-06 Tue 03:37]
   When I am looking at a release,  I can see both the sunburst and a list of tests that happen with this release, so that I have more context on what is actually happening with our test coverage.
   When I click on a test, I can see a chronological list of the endpoints it accesses, so I can understand what this test is doing and if it is necessary.
- [X] Add unique api endpoint for tests
- [X] Bring the tests into our redux store when app first loads.
- [X] Massage data to group by release, using same format as our endpoints
- [X] list tests to side of sunburst
- [X] clicking on a test makes it the 'active_test', which updates state.
- [X] When there is an active_test, display its chronological list.  does not need to be styled fancy.

** TODO [0/1] Questions
   - [ ] Why does brining in the selectsunburstSorted selector affect the sunburst (when it is a new selector, not the previous one.
