#+NAME: APISnoop WebUI Client
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:tmate :socket "/tmp/.zz-left.isocket"
#+PROPERTY: header-args:tmate :session api:main
#+PROPERTY: header-args:js :results silent

* Introduction
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
** Reimagining how the web app is built.
   At this point, the work here is a proof of concept refactoring of the orignal site, to make our structure more extensible and modular.  When new work is done with the dating processing, we want to be able to quickly visualize the results of this work for others.  The current site is static html, with each new section intentionally and manually hard-coded. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new element.  We have to keep a mental map of every aspect of the site this new dataset should influence and update those accordingly.  Not only is this time-consuming, it's error-prone and hard to maintin.

   At the same time, there was a good amount of work done by the team to get to the current site, and that work should be preserved as much as possible.  The goal of this refactor, then, is to re-make the original site to then build incredible things beyond and above it.
http://uber.github.io/react-vis/documentation/other-charts/sunburst-diagram
** Setting It up On Your own
*** Setup Backend
 after cloning repository
- cd apisnoop/backend
- npm install
- Make sure we have a jsons folder in apisnoop/backend with this tree structure:
#+RESULTS: File Structure
:RESULTS:
.
├── release
└── sunbursts

2 directories
:END:
#+NAME: File Structure
#+BEGIN_SRC shell :dir ./backend/jsons :results output raw drawer
tree -d
#+END_SRC
- Delete all .db's from src/data/
- npm start
- email zz@ii.coop with full error output and a coupon for soda.

*** Setup Client
    When backend server is on:
    - cd apisnoop/client
    - npm install
    # - figure out how to point to subheadings
    - go to [[Client/Actions/index.js]]   and change the client here to be whatever site you have this on (localhost or apisnoop)
    - npm start

** Running the Client
  In the web ui folder:
 ===
 cd client
 npm install
 npm start
 ===
 Then navigate to localhost:3000, if it isn't already opened for you.
* Architecture
  This is built as a dynamic web app, as opposed to a static site.  And so when the page loads, we dynamically fetch data from both our backend server and the app's own state management.  Then we display information derived from the application state and that backend server.

  We do this using React for the front-end framework, and redux-bundler for our state management.  This is all done 'client-side'
** React
** Redux-Bundler
*** Resources
    - [[https://reduxbundler.com/][redux bundler homepage]]: documentation with good api references
    - [[https://read.reduxbook.com/][Human Redux]]: book by Henrik Joreteg about working with redux.  A lot of our principles are inspired by this book, and explained in better detail here
** Tachyons
* Principles
** Presentation is Separate from Logic
   the components do not care about the data, or affect the data.  They only present the data given to them.
** Reducers are dumb and that's a good thing
   the reducer is a continually replaced object that holds the current state of the app.  We want the reducer to be as dumb and simple as possible...so no if/else statements or functions that define what the value of some part of the state should be.  It only holds the clean, proper value
** Our logic is done through selectors and reactors
** The App is designed as a v. pretty spreadsheet
   as taken from human redux.  Essentially have everything based on simple data in the redux store, that we manipulate thorugh other functions.
** The URL is our source of truth
   As we navigate around the site, including navigating our mouse arounmd the chart, the URL will change to reflect the current method, level, and all that we are on.  The app then listens to this and updates its data appropriately.

* Conventions
** Redux-Bundler
   how to write selectors, reducers, all that.
   stylistic choices.   Best practices go in our principles
** this org-file
   adding new bundles.
   structurikng the code
   the code block arguments
* File Structure
* Initiatory Code
** index.js
   :PROPERTIES:
   :header-args: :tangle ./src/index.js
   :END:
   #+NAME: index.js
   #+BEGIN_SRC js
     import React from 'react'
     import { render } from 'react-dom'
     import './index.css'

     import { Provider } from 'redux-bundler-react'

     import App from './components/app'
     import createStore from './bundles'

     var store = createStore()

     // document.title = 'APISnoop | ' + store.getState().routing.release

     render(
         <Provider store={store}>
         <App />
         </Provider>,
       document.getElementById('root')
     )
   #+END_SRC
* Bundles
  Another way of thinking of these are 'concerns'.  As we add functionality, it will come in the form of a bundle.  This bundle will define:
- the state as related to this concern (reducers),
- How we manipulate and then give the data in the state to our components (the selectors),
- How we listen for conditions in the state that would trigger actions to happen (the reactors),
- The actions that change the state (Actions)

** index
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/index.js
   :END:
   This is the root bundler, that takes all the other individual ones and composes a single super bundle.
*** Import modules and bundles
    We import all the various bundles we make here.  The only module we need is redux-bundle's compose bundle function.
    #+NAME: bundle index: Import modules and bundles
    #+BEGIN_SRC js
      import { composeBundles } from 'redux-bundler'
      import zachBundle from './zach.js'
    #+END_SRC
*** Compose Bundle
    Then, we compose the bundles into a single store, listing all the ones we imported above.
    #+NAME: bundle index: compose bundle
    #+BEGIN_SRC js
      export default composeBundles(
        zachBundle
      )
    #+END_SRC

** zach
   :PROPERTIES:
   :header-args: :tangle ./src/bundles/zach.js :noweb yes
   :END:
   This is a made up bundle, just to get a good idea of how it works.  We'll just import this one into our full app to show that it's actually working.
*** Basic Layout
    #+NAME: zach bundle basic layout
    #+BEGIN_SRC js
      export default {
        name: 'zach',
          <<Zach Reducer>>,
          <<Zach Selectors>>,
          <<Zach Actions>>
      }
    #+END_SRC
*** Reducer
    #+NAME: Zach Reducer
    #+BEGIN_SRC js :tangle no
      getReducer: () => {
        const initialState = {
          nickName: 'Cool Zach, my Dear Friend.',
          isAwesome: true,
          favoriteMovie: 'Fired Up'
        }
        return((state = initialState, action) => {
          if (action.type === 'FAVORITE_MOVIE_CHANGED') {
            state = {
              ...state,
              favoriteMovie: action.payload
            }
          }
          return state
        })
      }


    #+END_SRC
    We are using getReducer because we want to dynamically configure our reducer (e.g. setting an initial state that gets fed to the reducer.)
*** Selectors
    these are what would handle any sort of data manipulation or transformation, so the reducer can be a simple, dumb object.
    The components often then request information from the selectors, and not directly from a reducer.
    #+NAME: Zach Selectors
    #+BEGIN_SRC js :tangle no
      selectFavoriteMovie: state => state.zach.favoriteMovie,
      selectNickName: state => state.zach.nickName
    #+END_SRC
*** Actions
    #+NAME: Zach Actions
    #+BEGIN_SRC js :tangle no
      doChangeFavoriteMovie: () => ({ dispatch }) => {
        var favoriteMovies = [
          'Fired Up',
          'Sullivan\'s Travels',
          'The Big Lebowski',
          'Tully'
        ]
        dispatch({
          type: 'FAVORITE_MOVIE_CHANGED',
          payload: favoriteMovies[Math.floor(Math.random()*favoriteMovies.length)]
        })
      }
    #+END_SRC
*** Reactors
* Components
** App
   :PROPERTIES:
   :header-args: :tangle ./src/components/app.js
   :END:
   the initiatory component.  This is sort of the standard layout in which all other views are placed within.
   #+Name: App.js
   #+BEGIN_SRC js
     import React from 'react'
     import { connect } from 'redux-bundler-react'

     import Header from './header'
     import Footer from './footer'

     export default connect(
       'selectFavoriteMovie',
       'selectNickName',
       'doChangeFavoriteMovie',
       ({ doChangeFavoriteMovie, favoriteMovie, nickName}) => (
           <div id='app'>
           <Header />
           <div class='min-vh-80'>
           <h1>hello, {nickName}</h1>
           <p>Your favorite movie is {favoriteMovie}</p>
           <button
         onClick={() =>
                  doChangeFavoriteMovie()
                 }
           >Change Fave Movie</button>
           </div>
           <Footer />
           </div>
       )
     )
   #+END_SRC

   If you compare this to the original app, you can see it is far less duplicated or strange code.  Everything is just held in the connect function, where we bring in our selectors and actions, and then reference them directly in our presentational component.
   #+NAME: original app
   #+BEGIN_SRC js :tangle no
     import React, { Component } from 'react'
     import { connect } from 'react-redux'
     import { createStructuredSelector } from 'reselect'


     import { selectReleaseNamesFromEndpoints, selectIsEndpointsReady, selectPage } from '../selectors'
     import { fetchEndpoints } from '../actions/endpoints'
     import { doFetchTests } from '../actions/tests'

     import Header from './header'
     import Footer from './footer'
     import ReleasesList from './releases-list.js'

     class App extends Component {

       componentDidMount(){
         this.props.fetchEndpoints()
         this.props.fetchTests()
       }

       render(){
         const {
           Page,
           releaseNames,
           endpointsReady
         } = this.props

         return (
           <div id='app'>
             <Header />
             {endpointsReady &&
              <div>
              <ReleasesList
                releases={releaseNames}
              />
             <Page />
             </div>
             }
             {!endpointsReady &&
             <div className='min-vh-80'>
             <h3>Loading...</h3>
             </div>
             }
             <Footer />
           </div>
         )
       }
     }

     export default connect(
       createStructuredSelector({
         releaseNames: selectReleaseNamesFromEndpoints,
         endpointsReady: selectIsEndpointsReady,
         Page: selectPage
       }),
       {fetchEndpoints,
        fetchTests: doFetchTests
       })(App)
   #+END_SRC
* Footnotes
** Glossary
 - client-side ::
 - dynamic web app ::
 - static web site ::
 - immutable state ::
 - selector ::
 - reducer ::
 - action creator ::
 - reactor ::
 - store ::
 - state ::
** Resources
*** d3
**** [[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][interactive applications with react-d3]]
     this is really good.
**** [[https://www.smashingmagazine.com/2018/02/react-d3-ecosystem/][Bringing Together react, d3, and their ecosystem]]
**** [[http://www.adeveloperdiary.com/react-js/integrate-react-and-d3/][How to Integrate React and d3 the right way]]
**** [[https://bost.ocks.org/mike/join/][Thinking with Joins]]
** isocket
*** Connecting the left pair / isocket

 ssh needs '-t' twice because it needs to be forced to allocate a remote terminal
 _even_ when we don't have have local one (within emacs)


#+NAME: left_session_create
#+BEGIN_SRC shell :var session="zz-left" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n emacs \
      emacs --fg-daemon=$session" \
  &
#+END_SRC

#+NAME: left_session_setup
#+BEGIN_SRC shell :var session="zz-left" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  ssh -att $user@$host \
  "tmate -S /tmp/.$session.isocket \
        new-window \
        -n client" \
   "emacsclient -nw \
              --socket-name $session \
              ~/apisnoop/webui/web_ui.org"
#+END_SRC

 #+NAME: left_session
 #+BEGIN_SRC shell :wrap "SRC text :noeval" :results verbatim :var session="zz-left" user="zz" host="apisnoop.cncf.io" :results silen
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket wait tmate-ready > /dev/null &&
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\' 2> /dev/null
# ssh -tt root@apisnoop.cncf.io \
#  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS: left_session
 #+BEGIN_SRC text :noeval
 #+END_SRC

**** Connecting to emacs daemon

 #+NAME: alse run emacsclient
 #+BEGIN_SRC tmate :noeval
 export SESSION=lt-emacs
 emacsclient --socket-name $SESSION
 #+END_SRC

*** Connecting the right pair / isocket

#+NAME: right_session_create
#+BEGIN_SRC shell :var session="zz-right" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n misc" \
  &
#+END_SRC


 #+NAME: right_session_join
 #+BEGIN_SRC shell :results silent
 export SESSION=api-snoop
 export XTERM_EXEC="roxterm -e"
 $XTERM_EXEC ssh -Att root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
   at \; sleep 9999
 #+END_SRC

 #+NAME: right_session_setup
 #+BEGIN_SRC shell :results verbatim
 export SESSION=api-snoop
 echo ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
    new-window -n session \
     bash
 #+END_SRC

 #+NAME: right_session
 #+BEGIN_SRC shell :cache yes :wrap "SRC text :noeval" :results verbatim
 export SESSION=api-snoop
 ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS[dd96525b42bbbe741e292e99ad5f3592a7163025]: right_session
 #+BEGIN_SRC text :noeval
 ssh mJrsCgvGTOTOFagYpBKvRf7EE@sf2.tmate.io
 #+END_SRC





 #+NAME: give this to your pair
 #+BEGIN_SRC bash :noweb yes :var left_session=left_session() right_session=right_session()
 echo "ii pair session ready
 left: $left_session
 right: $right_session
 "
 #+END_SRC

 #+RESULTS: give this to your pair
 | ii     | pair | session | ready |
 | left:  | nil  |         |       |
 | right: | nil  |         |       |
 |        |      |         |       |

*** TODO Sharing your eyes

#+NAME: give this to your pair
#+BEGIN_SRC bash :noweb yes :var left_session=left_session() :var right_session=right_session()
echo "ii pair session ready
left: $left_session
right: $right_session
"
#+END_SRC
* Tasks
** DONE get basic webpage working with redux bundler
   CLOSED: [2018-12-05 Wed 11:29]
   just get it to say hello at least
** DONE bring back our headers and footers to basic page
   CLOSED: [2018-12-05 Wed 14:22]
** TODO consolidate notes from last mikey pair (the note left about the role of the url)
** TODO Share a link to a build and the build loads quickly
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/15][issue link]]
** TODO It is possible to share a link to a chart filtered to an endpoint
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/12][gitlab link]]
  this would be filtered to level, category, endpoint, and method.  iT shoudl show the chart locked and highlighted.
** TODO Webui loads meaningful chart within seconds
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/9][gitlab link]]
  before any data lods, there'll be a chart outline to signify loading.  But the data should still come quickly.
** TODO We have distinct dev and prod backends
  [[https://gitlab.ii.coop/ii/cncf/apisnoop/issues/11][gitlab link]]
** TODO [3/15] Future Tasks
   - [ ]  Integrate user interaction with sunburst (filter by UserAgent).  This'll test our hypothesis that we can manipulate the data far quicker than before.
   - [X] Hover over Part of Sunburst shows relevant rays highlighted.
   - [X] Hover over Sunburst, see testing percentage update in center.
   - [ ] Click on Useragent, sunburst zooms onto that subset of data.
   - [ ] Refactor Chart Selector to not be heavily nested..
   - [ ] Move colors calculation out of sunburst selector into its own thing.
   - [ ] Separate sunburst selector thangs from chart interaction thangs (maybe?  may be premature optimization).
   - [X] Remove unused props from app.js
   - [ ] Make each test Sequence an object, instead of an array. or at least ask someone if that's really necessary?  Maybe not necessary.
   - [ ] Improve performance of page load, by only calling a test when needed.
   - [ ] Refactor tests so the entire object isn't being loaded in the client.  That feels way too heavy, and instead you should only load up the testInfo (all the api endpoints being accessed) when there is an active_test, and you display that only on that active test.
   - [ ] When you click on an endpoint, it adds to the URL so that you can share the URL and have be right on the hovered sunburst with the filtered tests and such.
   - [ ] add queryString to our arsenal, so you can do a direct url to an endpoint
   - [ ] Change endpoint path so it displays UNTESTED for the whole untested block (currently displaying random endpoint name).
   - [ ] Add logic to API to filter endpoints to only those touched by e2e. We are showing all.  It'll be faster, and simpler to only be ones whose useragents includes the regex string 'e2e.test'

** DONE [11/11] Tasks For Refactoring our Data and understanding of it.
   CLOSED: [2018-11-07 Wed 21:01]
   - [X]  Convert JSON dump to New Flat Database
   - [X] Hookup react/redux to query endpoints.
   - [X] Integrate Reselect to computed data views (instead of getting data, withoutm assaging, and trying to fit it into the sunburst.)
   - [X] Practice Converting flat database to Sunburst Data structure.
   - [X] Sort Level so it is Stable, Beta, Alpha
   - [X] pass down chart selector data to main page props, pass down focused key path to render label within sunburst
   - [X] Add Percentage Calculation to center label.
     - I think I would want to do a data transformation, that counts the isTested for each of the child nodes, and piles that into an equation in the parent node.
     - How much of the existing work can I use with this?
     - STRATEGY: we've added the coverage to our endpoints information.  So we could now have a 'coverage' selector that listens to the full path array and finds the coverage information in the endpoints for it.  We don't need to do any extra action, we just need to work off our existing stuff.
     - If nothing is set, then we are going to want to know the coverage by release.  So the first step, then, would be: 'Without Focus Path selectInteriorLabel = endpoints[release][coverage]' with focus path it would be endpoints[release][fp1][fp2][coverage]...i guess based on the full apth length (it could be up to 3, level, category, endpoint).
   - [X] Fix routing so activeRoute isn't hard-coded.
   - [X] re-hook up routing to route by release name
   - [X] Query endpoints by Release.
   - [X] remove dependency on releaseStore reducer.
** DONE [10/10] Achievements To Unlock to match and surpass old webui
   CLOSED: [2018-11-06 Tue 13:49]
   - [X] Mikey has a functional understanding of what we're trying to do.
   - [X] It generally feels better
   - [X] Sunburst Changes Based on Route
   - [X] It loads faster
   - [X] When you click on a test, it lists the endpoints sequence.
   - [X] Add testTags to our endpoint api
   - [X] When you hover on an endpoint, it shows the test tags.
   - [X] When you click on an endpoint, it locks the chart in place.
     - [X] Add 'clicked' as state in sunburstChart, following the same logic in the [[https://github.com/uber/react-vis/blob/master/showcase/sunbursts/basic-sunburst.js][react-vis tutorial]]
     - [X] When you mouseOut, if clicked isn't true //then// send out the clearing of focusPath.  Otherwise, keep it.
   - [X] When you click on an endpoint, it filters the list of tests to just the ones that touch that endpoint.
     - [X] Devise strategy: when you click on a node you have the focus path as an array, which would end with an endpoint (if we are on an endpoint, otherwise it'd show the category or level). We have tests who each have an endpoint listed within them.  Maybe we query our db at that point for tests?endpointsIncludeEndpointName, or something similar to that.  Then, we change the logic beneath to only show tests once an endpoint is clicked, and it's based on the tests we retrieve...
     - [X] Doublecheck our releases for tests, to see how it be structured:  it goes release.data.tests.count.endpoints.  These endpoints //look// to correspond with our endpoint names pretty nicely.  But I think this means we'll have to separate out the tests into their own endoint too. It'd be best if it was just called 'tests', but we already ahve that for test_sequence.  how hard is it to switch that over?
   - [X] When you view the endpoint sequence, it is single line with a timestamp of HH:MM:SS:ss and then the rest of the info.
** DONE Change front-end logic so it only pulls data from the necessary sunburst.
   CLOSED: [2018-11-04 Sun 22:29]
   Right now the we have an endpoint called /Releases, organized by Build name.  These correspond to the sunbursts.  We are pulling in the entire api, we should only do buildname.data.sunburst
*** [3/4] Subtasks
    - [X] Remove excess noise from front-end for right now--the filters essentially.
    - [X] Add URL path to each Release you click
    - [X] Add fetchSunburst action to sunburst segment component, and pass it along the url params.
    - [ ] Query the api database based on the params and return just the sunburst data.`
** DONE change keypath logic so it only highlights if parent is on keypath.
   CLOSED: [2018-11-04 Sun 22:30]
** DONE-AND-SHARED [6/6] Add Test Information To Webui
   CLOSED: [2018-11-06 Tue 03:37]
   - State "DONE-AND-SHARED" from "NEXT"       [2018-11-06 Tue 03:37]
   When I am looking at a release,  I can see both the sunburst and a list of tests that happen with this release, so that I have more context on what is actually happening with our test coverage.
   When I click on a test, I can see a chronological list of the endpoints it accesses, so I can understand what this test is doing and if it is necessary.
- [X] Add unique api endpoint for tests
- [X] Bring the tests into our redux store when app first loads.
- [X] Massage data to group by release, using same format as our endpoints
- [X] list tests to side of sunburst
- [X] clicking on a test makes it the 'active_test', which updates state.
- [X] When there is an active_test, display its chronological list.  does not need to be styled fancy.

** DONE-AND-SHARED Visually distinguish tested endpoints tagged [Conformance]
   CLOSED: [2018-12-05 Wed 14:22]
   - State "DONE-AND-SHARED" from "DONE"       [2018-12-05 Wed 14:22]
   [[https://github.com/cncf/apisnoop/issues/46][Github Issue]].  So we can do a bit of regex on the endpoint...though I thionk each one has a test tag and those would include conformance...right?
