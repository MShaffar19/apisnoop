#+NAME: APISnoop WebUI
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:tmate :socket "/tmp/.zz-left.isocket"
#+PROPERTY: header-args:tmate :session api:main

* Introduction
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
** Reimagining how the web app is built.
   At this point, the work here is a proof of concept refactoring of the orignal site, to make our structure more extensible and modular.  When new work is done with the dating processing, we want to be able to quickly visualize the results of this work for others.  The current site is static html, with each new section intentionally and manually hard-coded. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new element.  We have to keep a mental map of every aspect of the site this new dataset should influence and update those accordingly.  Not only is this time-consuming, it's error-prone and hard to maintin.

   At the same time, there was a good amount of work done by the team to get to the current site, and that work should be preserved as much as possible.  The goal of this refactor, then, is to re-make the original site to then build incredible things beyond and above it.
http://uber.github.io/react-vis/documentation/other-charts/sunburst-diagram
** Setting It up On Your own
*** Setup Backend
 after cloning repository
- cd apisnoop/backend
- npm install
- Make sure we have a jsons folder in apisnoop/backend with this tree structure:
#+RESULTS: File Structure
:RESULTS:
.
├── release
└── sunbursts

2 directories
:END:
#+NAME: File Structure
#+BEGIN_SRC shell :dir ./backend/jsons :results output raw drawer
tree -d
#+END_SRC
- Delete all .db's from src/data/
- npm start
- email zz@ii.coop with full error output and a coupon for soda.

*** Setup Client
    When backend server is on:
    - cd apisnoop/client
    - npm install
    # - figure out how to point to subheadings
    - go to [[Client/Actions/index.js]]   and change the client here to be whatever site you have this on (localhost or apisnoop)
    - npm start

* Architecture
The site will be made to have a distinct front-end and backend, with the front-end able to be ported over to any other backend.
The front-end will consist of multiple components that wait to be told what data to display, instead of being written as part of the component.  In this way, if we want to make changes to our 'SIG Tag Bubble', we can just find the component named that and make changes there, instead of trying to find/replace the code within the file.
** FRONTEND
The frontend will be made with React, Redux, maybe Saga, and Tachyons, and Axios
*** Why React?
    [[https://reactjs.org/][React]] is the most well-known and supported front-end framework among my dev friends in Wellington, and is widely used and respected globally.  It was created originally by Facebook and then made open-source.  So it has a tremendous amount of support around it and good video tutorials for learning it.  I find it to be a bulky and kinda clumsy framework (which is why the first version of this used my personal fave Choo instead), but felt it was good to pick one that more people knew (and could help with).

*** Why Redux?
   [[https://redux.js.org/][Redux]]  provides one global 'state' for the app, and makes React actually usable.  It will help us push the data appropriately to the right parts and keep things clean and efficient.

    - [ ] Query endpoints by Release.
*** Reselect
   [[https://github.com/reduxjs/reselect][Reselect]]  allows us to massage the state into friendly props specific to components.  This helps us keep a philosophy that nothing in the state is repeated, and instead you have //all// state that you can then derive into different selectors based on what you need for the component.
   #+NAME: install Reselect
   #+BEGIN_SRC shell :dir ./client :results output list raw
npm install reselect
   #+END_SRC

   #+RESULTS: install Reselect
   - + reselect@4.0.0
   - added 1 package, removed 15 packages and audited 21041 packages in 14.857s
   - found 1 low severity vulnerability
   - run `npm audit fix` to fix them, or `npm audit` for details

*** AXIOS
   [[https://www.npmjs.com/package/axios][Axios]] is a simple tool for handling http requests across different servers.  We'll need this for the client to be portable, and able to call to multiple API's (our backend plus github for example).
*** Why Tachyons?
    Tachyons is a css framework for writing functional CSS.  It's a much different approach to CSS, but it's one that matches a unix philosophy and is super easy to spin things up and maintain them.  AS we make changes, we don't have to worry that some class hidden deep in some css file causes our whole site to look weird.  Instead, every class has a single purpose, and you add multiple classes to a site to add-upon and combine each of these classes functions (like piping commands together on the command line).  This makes all our components //reusable// too, as we only need to copy over the code and not any stylesheet attached to the code.
** BACKEND
   For the backend we will be using Feathers //for right now//.  We may find that we want something completely different, or that we want our webui to be able to live in multiple places.  Our goal is for the two to be entirely separate, so either can change if needed.
*** Feathers
    [[https://feathersjs.com/][Feathers]] is a well-designed and well-documented api layer written in Node.  It has good support among my Wellington dev friends, and so I have better help if I encounter any sorta problem.  It also is just really pleasant to use so far, with a good model for how to create different services.  It also has an existing React connector.
**** Feathers Resources
***** [[https://www.youtube.com/playlist?list=PLwSdIiqnDlf_lb5y1liQK2OW5daXYgKOe][youtube channel]]
***** [[https://stackoverflow.com/questions/tagged/feathersjs][stackoverflow tag]]
***** [[https://github.com/issues?utf8=%25E2%259C%2593&q=is%253Aopen+is%253Aissue+user%253Afeathersjs+][github page]]
***** [[https://blog.feathersjs.com/][medium page]]
***** [[http://slack.feathersjs.com/][slack channel]]

* Backend
** Setting up our API Initially
**** Generating the Services
     We will be using the processed data provided by the audit-log review to generate an api path for us to traverse.  Each build will have its own data, which will include the tags in it, the agents in it, and a sunburst path.
** Services
   (**NOTE**: for each service, make sure paginate is turned off.  In the future I should do this automatically.)
*** Introduction

Services refer to the different paths of our api, and the various jobs and manipulation we do to the data being fed through these paths.  They act as gatekeeepers to our various db's, so we aren't doing a bunch of db queries from all over the code and potentially causing strange behavior and hard to track errors.  Throug these, we have a consistent and reliable way to ask for and give data to our server: talk to the relevant service and have them do the work for you.

We generate a service using feathers cli.  This creates a number of files for us and makes sure the service is known to the entire backend.  Which is to say that there will be a number of file changes made when we make a new service, but the files within this section only refer to the core code we are writing.
**** Service Definitions
   We have two services now.
 - Config :: Handles the initial setup (reading json files from disk and distributing the file to the proper Releases service, performing any cleanup as necessary).
 - Releases ::  the heart of our data, has all the info we need by release and we use this for our presentational components in the front end..
*** Config
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./backend/src/services/config/config.class.js
    :END:
   The config is run whenever the server starts up, and takes JSON files placed in ~data/processed-audits~ and generates paths from the data held within.

   We are in a midpoint now from the original style, where we created a single path with many nests, to a new FLAT style (that is generally more preferred, and more [[https://zen-of-python.info/][zen]]).  ~api/v1/endpoints~ is the beginning of this flat style.  Here, we generate new endpoints from all the different files, but each one has a release, method, and name.  Then, when we want to see only stuff for 1.12, we query our endpoint access for those with a release of 1.12 (instead of finding the 1.12 entry and navigating through its various nests to get the endpoints).
**** Overall Layout
     #+NAME: config.class.js layout
     #+BEGIN_SRC js
       /* eslint-disable no-unused-vars */
       const fs = require('fs')
       class Service {
         constructor (options) {
           this.options = options || {};
         }

         async setup (app, params) {
           populateReleases(app,'./data/processed-audits')
         }
       }

       <<Define populateReleases>>

       module.exports = function (options) {
         return new Service(options);
       };

       module.exports.Service = Service;
    #+END_SRC

We only have a single method here, which is setup.  We don't want this to be an accessible path, we are just using it to run through commands when the server first starts up.  In this case, we run a command that looks in a directory for processed JSons and puts each file into its own entry in our releases api path.
**** Define populateReleases
     #+NAME: Define populateReleases
     #+BEGIN_SRC js :tangle no
       function populateReleases (app, dir)  {
         var processedAudits = fs.readdirSync(dir)
         for (var i = 0; i < processedAudits.length; i++) {
           var fileName = processedAudits[i]
           var releaseJson = fs.readFileSync(`${dir}/${fileName}`, 'utf-8')
           var releaseData = JSON.parse(releaseJson)
           addEntryToReleaseService(app, fileName, releaseData)
           addEntryToEndpointService(app, fileName, releaseData)
         }
       }

       async function addEntryToReleaseService (app, fileName, releaseData) {
         var service = app.service('/api/v1/releases')
         var name = fileName.replace('-processed-audit.json', '')
         var existingEntry = await service.find({query:{name}})
         if (existingEntry.length === 0) {
           service.create({name: name, data: releaseData})
         } else {
           service.update(existingEntry[0]._id, {name: name, data: releaseData})
         }
       }

       async function addEntryToEndpointService (app, fileName, releaseData) {
         var service = app.service('/api/v1/endpoints')
         var release = fileName.replace('-processed-audit.json', '')
         var endpointNames = Object.keys(releaseData.endpoints)
         for (var endpointName of endpointNames) {
           var endpointMethods = Object.keys(releaseData.endpoints[endpointName])
           for (var endpointMethod of endpointMethods) {
             var rawEndpoint = releaseData.endpoints[endpointName][endpointMethod]
             var endpoint = {
               name: endpointName,
               method: endpointMethod,
               release: release,
               level: rawEndpoint.level,
               path: rawEndpoint.path,
               category: rawEndpoint.cat,
               isTested: rawEndpoint.counter > 0
             }
             // An endpoint is unique by name, release, method.
             var existingEntry = await service.find({
               query:{
                 name: endpoint.name,
                 method: endpoint.method,
                 release: endpoint.release
               }
             })
             if (existingEntry.length === 0) {
               await service.create(endpoint)
             } else {
               await service.update(existingEntry[0]._id, endpoint)
             }
           }
         }
       }

     #+END_SRC

     This will read the file and send the data to our releases service, but releaes will reject it by default because some of the fiels in the data have periods and our database does not like that.  So we add a hook to Releases that takes this data given to it and changes it's peirods to underscores before trying to add it to the database.  We generated the hook using feathers/cli, setting it to be before any create or update action...meaning it manipualtes the file BEFORE it is added to the db through CREATE or UPDATE
*** Releases
    The file that handles this service is boilerplate feathers, so we will use this section to write and discuss the hooks used as part of the releases service.
**** cleanReleaseData
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./backend/src/hooks/clean-release-data.js
     :END:
    #+NAME clean-release-data.js
    #+BEGIN_SRC js
      const _ = require('lodash')

      module.exports = function (options = {}) {
        return async context => {
          var data = context.data.data
          data = cleanUp(data)
          context.data = {name: context.data.name, data: data}
          return context;
        }
      }

      function cleanUp (obj) {
        var cleanObj = {}
        for (key in obj) {
          if (_.isPlainObject(obj[key])) {
            cleanObj[key.replace(/\./g,'_')] = cleanUp(obj[key])
          } else {
            cleanObj[key.replace(/\./g,'_')] = obj[key]
          }
        }
        return cleanObj
      }
    #+END_SRC

* Client
  :PROPERTIES:
  :header-args: :dir ./client
  :END:
  The client will be all the files that bundle up into a bundle.js file that is called on our index.html page.  In other words, the FRONTEND
** Running the Client
  In the web ui folder:
 ===
 cd client
 npm install
 npm start
 ===
 Then navigate to localhost:3000, if it isn't already opened for you.
** File Structure

    Our client is set up as so...
    #+NAME: Our Directory Structure
    #+BEGIN_SRC shell :dir ./client :results output verbatim drawer replace
   tree  -I 'node_modules' -d
    #+END_SRC

    #+RESULTS: Our Directory Structure
    :RESULTS:
    .
    ├── public
    └── src
        ├── actions
        ├── components
        ├── css
        ├── lib
        ├── pages
        ├── reducers
        └── selectors

    9 directories
    :END:

    The core work is done in the src folder. Public holds our stylesheets and assets, and build holds everything when we set it up for production.

 Within our Src, file:
 - Actions manage calls to the app's state, requesting new data.
 - Components are modular parts of our UI, like dropdown boxes and navbars and such.
 - Pages are collections of components that display based on the route of the site and the actions of the user.  They are similar to html pages.
 - reducers listens to actions and the payload of data they contain and reducer that data into a single state tree for the app.  This is the data being called upon in the components.
 - Sagas are not being used yet.
** Setup
*** Creation
**** initial react app
     We are going to use the default app style (because we want this to be familiar to others), and luckily there's an npm module to create react apps for us to do just that!
     #+NAME: Create React App
     #+BEGIN_SRC sh :dir ./client :results output
       npx create-react-app client
     #+END_SRC
     #+RESULTS: Create React App
**** dependencies
     :PROPERTIES:
     :header-args: :noweb yes :dir ./client
     :END:
    We want to add some adaptors for react to use redux //and// feathers //and// tachyons
    #+NAME: install dependencies
    #+BEGIN_SRC shell :results output verbatim drawer
      npm install --save \
          @feathersjs/client \
          feathers-localstorage \
          feathers-redux \
          react-dom \
          react-redux \
          react-router \
          react-router-redux \
          react-router-dom \
          redux \
          redux-thunk \
          redux-devtools-extension \
          redux-saga \
          superagent \
          d3
    #+END_SRC

    #+RESULTS: install dependencies
    :RESULTS:
    + react-dom@16.5.2
    + react-router@4.3.1
    + feathers-localstorage@3.0.0
    + react-redux@5.0.7
    + redux@4.0.0
    + superagent@4.0.0-beta.5
    + redux-saga@0.16.0
    + react-router-redux@4.0.8
    + @feathersjs/client@3.7.3
    added 11 packages from 11 contributors, updated 5 packages and audited 14613 packages in 12.257s
    found 0 vulnerabilities

    :END:
**** file structure
     Within our client we want to manage our various components, the actions they can call upon, and the reducers that turn all these actions into a single state of the app. These dont' come with the basic react app, so we'll create them.
     We also want to delete any of the default react icons or CSS stuff and move our App.js into a component (cos that's what it is.
     #+BEGIN_SRC sh :results output
       cd src
       rm App.css index.css logo.svg
       mkdir components actions reducers sagas
       mv App.js components
       cd ..
       tree -I 'node_modules'
     #+END_SRC
     #+RESULTS:
     #+begin_example
     .
     ├── README.md
     ├── package-lock.json
     ├── package.json
     ├── public
     │   ├── favicon.ico
     │   ├── index.html
     │   └── manifest.json
     ├── src
     │   ├── App.test.js
     │   ├── actions
     │   ├── components
     │   │   └── App.js
     │   ├── index.js
     │   ├── reducers
     │   ├── registerServiceWorker.js
     │   └── sagas
     └── yarn.lock

     5 directories, 11 files
     #+end_example

*** Adding Tachyons
    We want to bring tachyons right into our app, installing it through node.  This way we have full access to the css library without relying on outside links and this library is as up-to-date as possible(or rather, v. easy to stay up to date.)  I am following the guide for react that tachyons listed[[https://github.com/tachyons-css/tachyons-and-react][ on their github page.]]
**** Install Tachyons and Sheetify
     I wont' be using sheetify right now, but the goal is to use it upon a refactor (when we've moved away from webpack to browseriy)
     #+NAME: Install Tachyons
     #+BEGIN_SRC shell :dir ./client :results output verbatim drawer
       npm install --save tachyons tachyons-cli sheetify
     #+END_SRC

     #+RESULTS: Install Tachyons
     :RESULTS:
     + tachyons-cli@1.3.2
     + tachyons@4.11.1
     + sheetify@7.3.3
     added 31 packages from 18 contributors, updated 2 packages, moved 3 packages and audited 20856 packages in 29.843s
     found 1 low severity vulnerability
       run `npm audit fix` to fix them, or `npm audit` for details
     :END:
**** Find Home for CSS
     #+NAME: Find Home for CSS
     #+BEGIN_SRC shell :dir ./client/src :results output verbatim drawer
       mkdir css
       echo '@import "tachyons"' > css/app.css
       tree css
     #+END_SRC

     #+RESULTS: Find Home for CSS
     :RESULTS:
     css
     └── app.css

     0 directories, 1 file
     :END:
**** Add CSS scripts
 I'll add a couple additions to our package.json (this is best outlined in the github link)
** index.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ./client/src/index.js
   :END:
   The entry point of the app.  This is what gets mounted to our index.html page, and then leads us into the rest of the frontend.  So we want to make a nice package to mount that has our redux store and our react app bundled up together.
*** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import React from 'react'
      import ReactDOM from 'react-dom'
      import { BrowserRouter } from 'react-router-dom'
      import './index.css'

      import {Provider} from 'react-redux'

      import App from './components/App'
      import store from './store.js'
      import registerServiceWorker from './lib/service-workers'

    #+END_SRC
*** index mounted to dom.
Here we define the wrapped up chunk of code that will be mounted to the 'root' id in our index.html page, and flower into the full app
#+NAME: main index.js
#+BEGIN_SRC js
  ReactDOM.render(
      <BrowserRouter>
      <Provider store={store}>
      <App />
      </Provider>
      </BrowserRouter>,
    document.getElementById('root')
  )
    registerServiceWorker()
#+END_SRC
** Our App(app.js)
   :PROPERTIES:
   :header-args: :noweb yes :tangle ./client/src/components/App.js
   :END:
***** Introduction
    The app component is often seen as the 'layout template' for the frontend.  Anything we want to be displayed at all times should go here (e.g. a header and navbar).  The app component will also handle the navigation between the different components, based on routes given.

    This is a 'single-page-app' which means: to the server, we are only showing a single html page, the index.html.  Within this page we have javascript code running that renders different views dynamically, based on what the site visitor wants to see.  We can give these views the format of a URL, so it appears like we are going to different pages within apisnoop (and so we can share specific urls to others), but it's all really a continually transforming bit of Javascript.
***** Requirements
   #+NAME: Import React
   #+BEGIN_SRC js
     import React, { Component } from 'react'
     import { connect } from 'react-redux'
     import { Route } from 'react-router-dom'

     import { fetchReleaseNames} from '../actions/releases'
     import { fetchEndpoints } from '../actions/endpoints'
     import { changeActiveRoute } from '../actions/routes'

     import Header from './header'
     import Footer from './footer'
     import ReleasesList from './releases-list.js'
     import MainPage from '../pages/main-page.js'
   #+END_SRC
 We'll start by bringing in React and its Component class-we inherit all the features of this class when we render our own components, which gives them all the power we may not see at first.  We also bring in connect, which will connect our react ui to the front-end's state; which lets us dynamically change what's displayed based on the data being fed it.

We are doing this because we want to have navigation links for the different releases, that will show a sunburst graph per release.  We don't know what these release_names will be though, and so we'll fetch them from the db and dynamically build our navlinks from them.

 Next, we'll bring in react's smart navigation.  These are what make the app appear to be multiple pages.

We will grab our release names from the database and use that to build out our navigation links dynamically.


 Lastly, we bring in our different pages, which we can navigate between using a nice lil' tab and navlinks..

I think this will end up that we use MainPage multiple times, feeding in props as url params.  So the main page will always show a sunburst graph, and a list of tests to click into, but what data is being fed that is based on the route we are going on.

***** The overall Layout
      The general shape of this template is here:
    #+NAME: App Layout
    #+BEGIN_SRC js
      class App extends Component {
        componentDidMount(){
          this.props.fetchReleaseNames()
          this.props.fetchEndpoints()
        }

        render(){
          return (
            <div id='app'>
              <Header />
              {this.props.release_names &&
               <ReleasesList
                 releases={this.props.release_names}
                 selected='master'
                 changeActiveRoute={this.props.changeActiveRoute}
               /> }
        <Route exact path='/' component={MainPage} />
        <Route exact path='/:release' component={MainPage} />
              <Footer />
            </div>
          )
        }
      }

      function mapStateToProps (state) {
        return {
        release_names: state.releasesStore.release_names
        }
      }

      export default connect(mapStateToProps, {fetchReleaseNames, fetchEndpoints, changeActiveRoute})(App)
    #+END_SRC

** Pages
    We are following a convention where, if a component acts as its own route and holds many different components within it, then it's called a page.  Think of navigating between different pages in a site, and each one is made up of several diff. section.  It is the same here, just that we are navigating between JS dispalying different Page components.
**** MainPage
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/pages/main-page.js
     :END:
     This page will hold the different areas for release--it's sunburst, and its list of test names.  We can add additional Segments here too, as our visualizations expand.
       #+BEGIN_SRC js
         import React, { Component } from 'react'
         import { connect } from 'react-redux'
         import { createStructuredSelector } from 'reselect'

         import { focusChart, unfocusChart } from '../actions/charts'
         import {
           selectActiveRoute,
           selectEndpointsWithTestCoverage,
           selectFocusPathAsArray,
           selectFocusPathAsString,
           selectReleaseNamesFromEndpoints,
           selectRouteChange,
           selectIsSunburstReady,
           selectSunburstByReleaseWithSortedLevel
         } from '../selectors'

         import SunburstSegment from '../components/sunburst-segment'

         class MainPage extends Component {
           render(){
             const {
               activeRoute,
               endpointsWithTestCoverage,
               focusPath,
               focusPathAsString,
               routeChange,
               sunburstByRelease
             } = this.props

             const releaseBasedOnRoute = this.props.location.pathname.replace('/','')

             return (
                 <main id='main-splash' className='min-vh-100'>
                 <h2>You are doing a good job.</h2>
                 {this.props.isSunburstReady && <SunburstSegment
                  sunburst={{
                    data: routeChange ? sunburstByRelease.dataByRelease[activeRoute]
                      : sunburstByRelease.dataByRelease[releaseBasedOnRoute]
                  }}
                  endpoints={ routeChange ?
                              endpointsWithTestCoverage[activeRoute] :
                              endpointsWithTestCoverage[releaseBasedOnRoute]
                            }
                  focusChart={this.props.focusChart}
                  unfocusChart={this.props.unfocusChart}
                  release= {activeRoute}
                  focusPath={focusPath}
                  focusPathAsString={focusPathAsString}
                  />
                 }
               </main>
             )
           }
         }

         export default connect(
           createStructuredSelector({
             activeRoute: selectActiveRoute,
             endpointsWithTestCoverage: selectEndpointsWithTestCoverage,
             focusPath: selectFocusPathAsArray,
             focusPathAsString: selectFocusPathAsString,
             isSunburstReady: selectIsSunburstReady,
             releaseNames: selectReleaseNamesFromEndpoints,
             routeChange: selectRouteChange,
             sunburstByRelease: selectSunburstByReleaseWithSortedLevel,
           }),
           {focusChart,
            unfocusChart
            }
         ) (MainPage)
       #+END_SRC

       #+RESULTS:

** Components
The various visual parts of the app.  For the most part, we want these to be as dumb as possible--they present the stuff they're given, and if they have to do any interactive stuff it remains contained to within itself.  Any other changes should be handled outside of the component through actionCreators our and reducer updating the global state of the app.  In other words, the components display the state as it is now, and they can trigger events which update the state, but they always simply display it as it is now.
*** Header
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/header.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <header className='flex flex-row pt2 pb2 pl4 pr4 items-center justify-between bg-light-gray black shadow-3'>
            <div id='logo' className= 'flex flex-wrap items-center'>
            <img className='h2' src='./apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
            <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
            </div>
            <div id='source-code' className='flex items-center'>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
              <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
            </div>
          </header>
      )
    #+END_SRC

    #+RESULTS: Header

*** Footer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/footer.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <footer className='flex flex-row pt2 pb2 pl4 pr4 items-center justify-between bg-black black shadow-3'>
            <div id='logo' className= 'flex flex-wrap items-center'>
            <img className='mw2' src='./apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
            <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
            </div>
            <div id='source-code' className='flex items-center'>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
              <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
            </div>
          </footer>
      )
    #+END_SRC

    #+RESULTS: Header

*** Sunburst
**** Sunburst Segment
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/sunburst-segment.js
     :END:
     This is the section of the site dedicated to the sunburst, including any additional text we want to include or a nice header or anything like that.
     #+NAME: Sunburst Segment
     #+BEGIN_SRC js
       import React, { Component } from 'react'
       import SunburstChart from './sunburst-chart'


       class SunburstSegment extends Component {
         render() {
           const {endpoints,
                  focusChart,
                  focusPath,
                  focusPathAsString,
                  sunburst,
                  unfocusChart} = this.props

           return (
               <div id='sunburst-segment' className='bg_washed-red pa4'>
               <h2>{this.props.release}</h2>
               {focusPathAsString.length > 0 ? <div>{focusPathAsString}</div>
                      : <div>'Hover over Chart for Path'</div>
             }
               <SunburstChart
                 sunburst={sunburst}
                 endpoints={endpoints}
                 focusChart={focusChart}
                 focusPath={focusPath}
                 focusPathAsString={focusPathAsString}
                 unfocusChart={unfocusChart}
               />
               </div>
           )
         }
       }

       export default SunburstSegment
     #+END_SRC
**** Sunburst Chart
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/sunburst-chart.js
     :END:
     We are passing a single prop to this, sunburst, which was created by our selector.  It is divided in {name, children} with the organization of level > category > name + method.  For the name+method there is an additional thing.


     #+NAME: sunburst-chart.js
     #+BEGIN_SRC js
       import React from 'react'
       import { Sunburst, LabelSeries } from 'react-vis'
       import { get, includes } from 'lodash'

       const LABEL_STYLE = {
         PERCENTAGE: {
           fontSize: '1.3em',
           textAnchor: 'middle'
         },
         FRACTION: {
           fontSize: '1.2em,',
           textAnchor: 'middle'
         },
         PATH: {
           fontSize: '1em',
           textAnchor: 'middle'
         }
       }

       export default function SunburstChart (props) {

         const {
           focusChart,
           focusPath,
           sunburst,
           unfocusChart
         } = props

         if (sunburst == null) return null
         return(
             <div className="sunburst-wrapper">
             <Sunburst
               hideRootNode
               colorType="literal"
               data={sunburst.data}
               getColor={node => determineColor(node)}
               height={500}
               width={500}
               onValueMouseOver={handleMouseOver}
               onValueMouseOut={handleMouseOut}
               onValueClick={handleClick}

             >

             <LabelSeries
                data={[
                  {x: 0, y: 20, label: 'good times', style: LABEL_STYLE.PERCENTAGE},
                  {x: 0, y: 0, label: 'fun times', style: LABEL_STYLE.FRACTION},
                  {x: 0, y: -20, label: 'sweet times', style: LABEL_STYLE.PATH}
                ]}
              />
             </Sunburst>
             </div>
         )

         function determineColor (node) {
           if (focusPath.length > 0) {
             if (node.parent && includes(focusPath, node.name) && includes(focusPath, node.parent.data.name)) {
               return node.color
             } else {
               return node.color + '19'
             }
           }
           return node.color
         }

         function handleMouseOver (node, event) {
           focusChart(getKeyPath(node))
         }

         function handleMouseOut () {
           unfocusChart()
         }

         function handleClick (node) {
         }

         function getKeyPath (node) {
           if (!node.parent) {
             return ['root'];
           }
           var nodeKey = get(node, 'data.name') || get(node, 'name')
           var parentKeyPath = getKeyPath(node.parent)
           return [...parentKeyPath, nodeKey]
         }
       }
     #+END_SRC

     #+RESULTS: sunburst-chart.js

*** Filter List
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/filters-list.js
    :END:
    #+NAME: filters-list.js
    #+BEGIN_SRC js
      import React, { Component } from 'react'

      class FiltersList extends Component {
        constructor (props) {
          super(props)
          this.optionsList = this.optionsList.bind(this)
        }

        optionsList (options) {
           var formattedNames = options.map(name => {
             return name.replace(/[\[\]]/g,'').replace(/_/g,'.')
           })
          var selected = this.props.selected.map(selection => {
            return selection.replace(/_/g,'.') //.replace(/^/,'[').replace(/$/,']')
          })
          return formattedNames.map(name => {
            console.log({name, selected})
            if (selected.includes(name)) {
              return(
                  <a className="f6 ml1 mr1 grow no-underline br-pill ba ph2 pv2 mb2 dib pink" href="#0" key={`filter_${name}`}>{name}</a>
              )
            } else {
              return (
                  <a className="f6 ml1 mr1 grow no-underline br-pill ba ph2 pv2 mb2 dib silver" href="#0" key={`filter_${name}`}>{name}</a>
              )
            }
          })
        }

          render () {
            console.log({filterProps: this.props})
            return (
                <div className="ph3 mt4">
                <h1 className="f6 fw6 ttu tracked">{this.props.context}</h1>
                {this.optionsList(this.props.options)}
              </div>
            )
          }
        }

        export default FiltersList
    #+END_SRC

   Is expecting:
- context :: a string that determines the header of the list
- selected ::  an array of strings, for the options selected by default
- options :: an array of options we will create buttons for.
*** Releases List
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/releases-list.js
    :END:
    #+NAME: releases-list.js
    #+BEGIN_SRC js
      import React, { Component } from 'react'
      import { NavLink } from 'react-router-dom'

      class ReleasesList extends Component {
        constructor (props) {
          super(props)
          this.optionsList = this.optionsList.bind(this)
          this.handleClick = this.handleClick.bind(this)
        }

        optionsList (options) {
          return options.map(option => {
            return(
                <NavLink
                  className="f6 ml1 mr1 grow no-underline br-pill ba ph2 pv2 mb2 dib pink"
                  exact to={option.name}
                  key={`release_${option._id}`}
                  onClick={this.handleClick}
                >
                {option.name}
              </NavLink>
            )
          })
        }

        render () {
          return (
              <div className="ph3 mt4">
              <h1 className="f6 fw6 ttu tracked">Releases</h1>
              {this.optionsList(this.props.releases)}
              </div>
          )
        }

        handleClick (e) {
          console.log('hi from clicking!!', e.target.innerText)
          this.props.changeActiveRoute(e.target.innerText)
        }
      }


      export default ReleasesList
    #+END_SRC

    #+RESULTS: releases-list.js

   Is expecting:
- context :: a string that determines the header of the list
- selected ::  an array of strings, for the options selected by default
- options :: an array of options we will create buttons
** Lib
*** Service workers
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/lib/service-workers.js
    :END:
    #+BEGIN_SRC js
      // In production, we register a service worker to serve assets from local cache.

      // This lets the app load faster on subsequent visits in production, and gives
      // it offline capabilities. However, it also means that developers (and users)
      // will only see deployed updates on the "N+1" visit to a page, since previously
      // cached resources are updated in the background.

      // To learn more about the benefits of this model, read https://goo.gl/KwvDNy.
      // This link also includes instructions on opting out of this behavior.

      const isLocalhost = Boolean(
        window.location.hostname === 'localhost' ||
          // [::1] is the IPv6 localhost address.
        window.location.hostname === '[::1]' ||
          // 127.0.0.1/8 is considered localhost for IPv4.
        window.location.hostname.match(
          /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
        )
      );

      export default function register() {
        if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
          // The URL constructor is available in all browsers that support SW.
          const publicUrl = new URL(process.env.PUBLIC_URL, window.location);
          if (publicUrl.origin !== window.location.origin) {
            // Our service worker won't work if PUBLIC_URL is on a different origin
            // from what our page is served on. This might happen if a CDN is used to
            // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374
            return;
          }

          window.addEventListener('load', () => {
            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

            if (!isLocalhost) {
              // Is not local host. Just register service worker
              registerValidSW(swUrl);
            } else {
              // This is running on localhost. Lets check if a service worker still exists or not.
              checkValidServiceWorker(swUrl);
            }
          });
        }
      }

      function registerValidSW(swUrl) {
        navigator.serviceWorker
          .register(swUrl)
          .then(registration => {
            registration.onupdatefound = () => {
              const installingWorker = registration.installing;
              installingWorker.onstatechange = () => {
                if (installingWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    // At this point, the old content will have been purged and
                    // the fresh content will have been added to the cache.
                    // It's the perfect time to display a "New content is
                    // available; please refresh." message in your web app.
                    console.log('New content is available; please refresh.');
                  } else {
                    // At this point, everything has been precached.
                    // It's the perfect time to display a
                    // "Content is cached for offline use." message.
                    console.log('Content is cached for offline use.');
                  }
                }
              };
            };
          })
          .catch(error => {
            console.error('Error during service worker registration:', error);
          });
      }

      function checkValidServiceWorker(swUrl) {
        // Check if the service worker can be found. If it can't reload the page.
        fetch(swUrl)
          .then(response => {
            // Ensure service worker exists, and that we really are getting a JS file.
            if (
              response.status === 404 ||
                response.headers.get('content-type').indexOf('javascript') === -1
            ) {
              // No service worker found. Probably a different app. Reload the page.
              navigator.serviceWorker.ready.then(registration => {
                registration.unregister().then(() => {
                  window.location.reload();
                });
              });
            } else {
              // Service worker found. Proceed as normal.
              registerValidSW(swUrl);
            }
          })
          .catch(() => {
            console.log(
              'No internet connection found. App is running in offline mode.'
            );
          });
      }

      export function unregister() {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.ready.then(registration => {
            registration.unregister();
          });
        }
      }

    #+END_SRC
*** Utils
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/lib/utils.js
    :END:
    #+NAME: Utils
    #+BEGIN_SRC js
      export function calculateCoverage (endpoints) {
        var total = endpoints.length
        var tested = endpoints.filter(endpoint => endpoint.isTested).length
        var percentage = (100 * tested /total).toPrecision(3)

        return {
          tested,
          total,
          percentage: `${percentage}%`,
          ratio: `${tested}/${total}`
        }
      }
    #+END_SRC

** Actions
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/index.js
    :END:
    We'll use the index page of the actions to set up our axios client.  axios handles our fetch requests, since we'll be fetching from another server and not from a data file within this app.  Axios is an http request client that uses promises (a new javascript convention for handling asynchronous calls).[[https://www.npmjs.com/package/axios][ Axios page on NPM]]

    We'll want to configure a client app for axios, that sets the host we are trying to connect to and the type of information we are expecting to get.  Since we are working with a feathers api, then we know we just need to grab JSON.
    #+NAME: axios_config
    #+BEGIN_SRC js
      import axios from 'axios'

      export const client = axios.create({
        baseURL: "http://localhost:3030",
        headers: {
          "Content-Type": "application/json"
        }
      })
    #+END_SRC

    #+RESULTS: axios_config

   These work with redux to deliver our store an object that has a 'type' and a payload.  So the type tells our store reducers what to do with it, and the payload is the data that is being added to the global state.

*** Releases Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/releases.js
    :END:
**** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

    #+END_SRC
**** Our URL Variables
     #+NAME: URL Variable
     #+BEGIN_SRC js
      const url = '/api/v1/releases'
     #+END_SRC

**** Fetching Releases
      #+NAME: Fetch Releases
      #+BEGIN_SRC js
        export function fetchReleases () {
          return dispatch => {
            dispatch({
              type: 'FETCH_RELEASES',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC
**** Fetching Release
      #+NAME: Fetch Release
      #+BEGIN_SRC js
        export function fetchRelease (releaseId) {
          return dispatch => {
            dispatch({
              type: 'FETCH_RELEASE',
              payload: client.get(`${url}?_id=${releaseId}`)
            })
          }
        }
      #+END_SRC
**** Fetch Release Names
     This gives us the url's to fed our release list, so on the main page you can choose between 1.11 and 1.12 and so on.
     What I want to do is a client.get but only ask for the sunburst data back.

Feathers lets us do some nice REST style querying, choosing which elements we are selecting from the db.  For the release_names we just want the names and the _id for each entry, so we add those to our select route.  Now we can use the _id in a find request when someone clicks on a particular route.
     #+NAME: fetchReleaseNames
     #+BEGIN_SRC js
        export function fetchReleaseNames () {
          return dispatch => {
            dispatch({
              type: 'FETCH_RELEASE_NAMES',
              payload: client.get('/api/v1/releases?$select[]=name&$select[]=_id')
            })
          }
        }

     #+END_SRC
**** Choose New Main Release
      #+NAME: chooseNewMain
      #+BEGIN_SRC js
        export function chooseNewMain (name) {
          return dispatch => {
            dispatch({
              type: 'NEW_MAIN_CHOSEN',
              payload: name
            })
          }
        }
      #+END_SRC
*** Endpoint Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/endpoints.js
    :END:
**** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

    #+END_SRC
**** Our URL Variables
     #+NAME: URL Variable
     #+BEGIN_SRC js
      const url = '/api/v1/endpoints'
     #+END_SRC

**** Fetching Endpoints
      #+NAME: Fetch Endpoints
      #+BEGIN_SRC js
        export function fetchEndpoints () {
          return dispatch => {
            dispatch({
              type: 'FETCH_ENDPOINTS',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC
*** Charts Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/charts.js
    :END:
**** Focus Chart
      #+NAME: Focusing Chart
      #+BEGIN_SRC js
        export function focusChart (keyPath) {
          return {
            type: 'CHART_FOCUSED',
            payload: keyPath
          }
        }
      #+END_SRC
**** Unfocus Chart
      #+NAME: Unfocus Chart
      #+BEGIN_SRC js
        export function unfocusChart() {
          return {
            type: 'CHART_UNFOCUSED'
          }
        }
      #+END_SRC
*** Routes Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/routes.js
    :END:
**** Change Route
      #+NAME: Focusing Chart
      #+BEGIN_SRC js
        export function changeActiveRoute (target) {
          return {
            type: 'ACTIVE_ROUTE_CHANGED',
            payload: target
          }
        }
      #+END_SRC
    #+NAME: Routes Actions
** Reducers
*** Introduction
 - Reducers/Charts :: Help us manage how a chart is manipulated based on mouseover, click, mouseleave, and other things..
 - Reducers/Endpoints :: Handles when we make a call to our endpoints API, changing the loading status upon pending, and delivering the endpoints (sorted by ID) to our store when the API request is fulfilled.
 - Reducers/Releases :: Older reducer that will likely be phased out.
 - Reducers/Routes :: listens to the  URL routes and updates state accordingly (so we can set the component based on current URL.

For each reducer, we follow a similar pattern:  we'll set an initial state for what should be held in this store, and what types it's expecting (object, array, string, etc).  Then, we listen to various action dispatches and handle them through a switch operation.  Each action will come with some sorta payload (defined by the action creator in our actions folder).  The reducer just takes the payload and adds it to the store, which will update the state.

The reducer is not manipulating the data in any way.  It takes the payload unaffected and adds it to the state the same way.  We then use our selectors to massage the data to work for whatever props we need.

*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/index.js
    :END:
    Here we combine all our different reducers into one big one.  This lets us think about the app in different, focused concerns that then get added to the larger application seamlessly.

    #+NAME: Requirements
    #+BEGIN_SRC js
      import { combineReducers } from 'redux'

      import ReleasesReducer from './releases'
      import EndpointsReducer from './endpoints'
      import ChartsReducer from './charts'
      import RoutesReducer from './routes'
    #+END_SRC

    #+NAME: Reducers
    #+BEGIN_SRC js
      const reducers = {
        charts: ChartsReducer,
        endpoints: EndpointsReducer,
        releasesStore: ReleasesReducer,
        routes: RoutesReducer
      }

      const rootReducer = combineReducers(reducers)

      export default rootReducer
    #+END_SRC
*** Charts Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/charts.js
    :END:


     #+NAME: The Charts Reducer
     #+BEGIN_SRC js
       const initialState = {
         focusedKeyPath: []
       }

       export default (state = initialState, action = {}) => {
         switch (action.type) {
         case 'CHART_FOCUSED':
           return {
             ...state,
             focusedKeyPath: action.payload
           }
         case 'CHART_UNFOCUSED':
           return {
             ...state,
             focusedKeyPath: []
           }
         default:
           return state;
         }
       }
     #+END_SRC

*** Endpoints Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/endpoints.js
    :END:

     #+NAME: The Endpoints Reducer
     #+BEGIN_SRC js
       const initialState = {
         byId: {},
         isLoading: false,
         hasLoaded: false,
         errors: {}
       }

       const { keyBy } = require('lodash')
       export default (state = initialState, action = {}) => {
         switch(action.type) {
         case 'FETCH_ENDPOINTS_PENDING': {
           return {
             ...state,
             isLoading: true
           }
         }
         case 'FETCH_ENDPOINTS_FULFILLED': {
           return {
             ...state,
             byId: {
               ...state.byId,
               ...keyBy(action.payload.data, '_id')
             },
             isLoading: false,
             hasLoaded: true
           }
         }
         default:
           return state;
         }
       }
     #+END_SRC
*** Releases Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/releases.js
    :END:
     #+NAME: The Releases Reducer
     #+BEGIN_SRC js
       const initialState = {
         release_names: [],
         active_release: {},
         loading: true,
         errors: {}
       }
       export default (state = initialState, action = {}) => {
         switch (action.type) {
         case 'FETCH_RELEASE_NAMES_FULFILLED': {
           return {
             ...state,
             release_names: action.payload.data
           }
         }
         case 'FETCH_RELEASE_FULFILLED': {
           return {
             ...state,
             active_release: {name: action.payload.data[0].name, ...action.payload.data[0].data},
             loading: false
           }
         }
         default:
           return state;
         }
       }
     #+END_SRC

*** Routes Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/routes.js
    :END:

    The goal is to listen to the location change and adjust the state accordingly.  We can then have our component always be showing the release related to the lastest route.

     #+NAME: The Routes Reducer
     #+BEGIN_SRC js
       const initialState = {
         activeRoute: '',
         routeChange: false
       }
            export default (state = initialState, action = {}) => {
              switch (action.type) {
              case 'ACTIVE_ROUTE_CHANGED':
                return {
                  ...state,
                  activeRoute: action.payload,
                  routeChange: true
                }
              default:
                return state;
              }
            }
     #+END_SRC
** Selectors
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/selectors/index.js
    :END:
   #+NAME: Selectors index.js
   #+BEGIN_SRC js
     export * from './endpoints'
     export * from './charts'
     export * from './routes'
   #+END_SRC

   #+RESULTS: Selectors index.js

*** Endpoints Selector
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/selectors/endpoints.js
    :END:
    #+NAME: Endpoints Selector
    #+BEGIN_SRC js
      import { createSelector } from 'reselect'
      import { groupBy, keyBy, mapValues } from 'lodash'
      import { calculateCoverage } from '../lib/utils.js'

      export function selectEndpointsById (state) {
        return state.endpoints.byId
      }

      export const selectEndpointsByReleaseAndNameAndMethod = createSelector(
        selectEndpointsById,
        (endpointsById) => {
          var endpointsByRelease = groupBy(endpointsById, 'release')
          return mapValues(endpointsByRelease, endpointsInRelease => {
            var endpointsByName = groupBy(endpointsInRelease, 'name')
            return mapValues(endpointsByName, endpointsInName => {
              return keyBy(endpointsInName, 'method')
            })
          })
        }
      )

      export const selectReleaseNamesFromEndpoints = createSelector(
        selectEndpointsByReleaseAndNameAndMethod,
        (endpointsByReleaseAndNameAndMethod) => {
          return Object.keys(endpointsByReleaseAndNameAndMethod)
        }
      )

      export const selectEndpointsByReleaseAndLevelAndCategoryAndNameAndMethod = createSelector(
        selectEndpointsById,
        (endpointsById) => {
          var endpointsByRelease = groupBy(endpointsById, 'release')
          return mapValues(endpointsByRelease, endpointsInRelease => {
            var endpointsByLevel = groupBy(endpointsInRelease, 'level')
            return mapValues(endpointsByLevel, endpointsInLevel => {
              var endpointsByCategory = groupBy(endpointsInLevel, 'category')
              return mapValues(endpointsByCategory, endpointsInCategory => {
                var endpointsByName = groupBy(endpointsInCategory, 'name')
                return mapValues(endpointsByName, endpointsInName => {
                  return keyBy(endpointsInName, 'method')
                })
              })
            })
          })
        }
      )

      export const selectEndpointsWithTestCoverage = createSelector(
        selectEndpointsById,
        (endpointsById) => {
          var endpointsByRelease = groupBy(endpointsById, 'release')
          return mapValues(endpointsByRelease, endpointsInRelease => {
            var coverage = calculateCoverage(endpointsInRelease)
            var endpointsByLevel = groupBy(endpointsInRelease, 'level')
            return Object.assign({},{coverage}, mapValues(endpointsByLevel, endpointsInLevel => {
              var endpointsByCategory = groupBy(endpointsInLevel, 'category')
              var coverage = calculateCoverage(endpointsInLevel)
              return Object.assign({}, {coverage}, mapValues(endpointsByCategory, endpointsInCategory => {
                var endpointsByName = groupBy(endpointsInCategory, 'name')
                var coverage = calculateCoverage(endpointsInCategory)
                return Object.assign({}, {coverage}, mapValues(endpointsByName, endpointsInName => {
                  return keyBy(endpointsInName, 'method')
                }))
              }))
            }))
          })
        }
      )

      export const selectIsEndpointsReady = (state) => {
        return state.endpoints.hasLoaded
      }
    #+END_SRC

Endpoints are unique by Release, Name, and Method.

*** Chart Selector
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/selectors/charts.js
    :END:
    #+NAME: Chart Selector
    #+BEGIN_SRC js
      import { createSelector } from 'reselect'
      import { forEach, map, mapValues, orderBy, reduce, values } from 'lodash'

      import { selectEndpointsByReleaseAndLevelAndCategoryAndNameAndMethod, selectIsEndpointsReady } from './endpoints'


      export function selectInteriorLabel (state) {
        return state.charts.interiorLabel
      }

      export function selectFocusPathAsArray (state) {
        return state.charts.focusedKeyPath
      }

      export const selectFocusPathAsString = createSelector(
        selectFocusPathAsArray,
        (pathAsArray) => {
          return pathAsArray.join().replace(/,/g,' / ')
        }
      )


      export const selectSunburstByRelease = createSelector(
        selectEndpointsByReleaseAndLevelAndCategoryAndNameAndMethod,
        (endpointsByReleaseAndLevelAndCategoryAndNameAndMethod) => {
          var dataByRelease = mapValues(endpointsByReleaseAndLevelAndCategoryAndNameAndMethod, (endpointsByLevelAndCategoryAndNameAndMethod, release) => {
            return {
              name: 'root',
              children: map(endpointsByLevelAndCategoryAndNameAndMethod, (endpointsByCategoryAndNameAndMethod, level) => {
                return {
                  name: level,
                  color: colors[level],
                  children: map(endpointsByCategoryAndNameAndMethod, (endpointsByNameAndMethod, category) => {
                    return {
                      name: category,
                      color: colors[`category.${category}`],
                      children: values(reduce(
                        endpointsByNameAndMethod,
                        (sofar, endpointsByMethod, name) => {
                          forEach(endpointsByMethod, (endpoint, method) => {
                            var { isTested } = endpoint
                            var path = isTested ? `${name}/${method}` : 'untested'
                            var size = (sofar[path] == null) ? 1 : sofar[path].size + 1
                            sofar[path] = {
                              name: name,
                              size,
                              color: isTested ? colors[`category.${category}`] : '#f4f4f4'
                            }
                          })
                          return sofar
                        },
                        {}
                      ))
                    }
                  })
                }
              })
            }
          })

          return {
            dataByRelease
          }
        }
      )


      export const selectSunburstByReleaseWithSortedLevel = createSelector(
        selectSunburstByRelease,
        (endpointsByRelease) => {
          var dataByRelease = endpointsByRelease.dataByRelease
          var sortedDataByRelease = mapValues(dataByRelease, (release) => {
            var levels = release.children
            var sortedLevels = orderBy(levels, 'name', 'desc')
            release.children = sortedLevels
            return release
          })
          endpointsByRelease.dataByRelease = sortedDataByRelease
          return endpointsByRelease
        }
      )

      export const selectIsSunburstReady = selectIsEndpointsReady

      var colors = {
        'alpha': '#e6194b',
        'beta': '#0082c8',
        'stable': '#3cb44b',
        'unused': '#ffffff'
      }

      var categories = [
        "admissionregistration",
        "apiextensions",
        "apiregistration",
        "apis",
        "apps",
        "authentication",
        "authorization",
        "autoscaling",
        "batch",
        "certificates",
        "core",
        "events",
        "extensions",
        "logs",
        "networking",
        "policy",
        "rbacAuthorization",
        "scheduling",
        "settings",
        "storage",
        "version"
      ]

      var more_colors = [
        "#b71c1c", "#880E4F", "#4A148C", "#311B92", "#1A237E", "#0D47A1",
        "#01579B", "#006064", "#004D40", "#1B5E20", "#33691E", "#827717",
        "#F57F17", "#FF6F00", "#E65100", "#BF360C", "#f44336", "#E91E63",
        "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4",
        "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107",
        "#FF9800", "#FF5722"
      ]

      for (var catidx = 0; catidx < categories.length; catidx++) {
        var category = categories[catidx]
        colors['category.' + category] = more_colors[(catidx * 3) % more_colors.length]
      }
    #+END_SRC

    #+RESULTS: Chart Selector

Endpoints are unique by Release, Name, and Method.

*** Routes Selector
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/selectors/routes.js
    :END:
    #+NAME: Routes Selector
    #+BEGIN_SRC js
      // import { createSelector } from 'reselect'

      export function selectActiveRoute (state) {
        return state.routes.activeRoute
      }

      export function selectRouteChange (state) {
        return state.routes.routeChange
      }
    #+END_SRC


Endpoints are unique by Release, Name, and Method.

* Process
* Footnotes
** Resources
*** d3
**** [[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][interactive applications with react-d3]]
     this is really good.
**** [[https://www.smashingmagazine.com/2018/02/react-d3-ecosystem/][Bringing Together react, d3, and their ecosystem]]
**** [[http://www.adeveloperdiary.com/react-js/integrate-react-and-d3/][How to Integrate React and d3 the right way]]
**** [[https://bost.ocks.org/mike/join/][Thinking with Joins]]
*** react/redux
    - [[https://read.reduxbook.com][Human Redux, by Henrik Joreteg]]

** isocket
*** Connecting the left pair / isocket

 ssh needs '-t' twice because it needs to be forced to allocate a remote terminal
 _even_ when we don't have have local one (within emacs)


#+NAME: left_session_create
#+BEGIN_SRC shell :var session="zz-left" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n emacs \
      emacs --fg-daemon=$session" \
  &
#+END_SRC

#+NAME: left_session_setup
#+BEGIN_SRC shell :var session="zz-left" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  ssh -att $user@$host \
  "tmate -S /tmp/.$session.isocket \
        new-window \
        -n client" \
   "emacsclient -nw \
              --socket-name $session \
              ~/apisnoop/webui/web_ui.org"
#+END_SRC

 #+NAME: left_session
 #+BEGIN_SRC shell :wrap "SRC text :noeval" :results verbatim :var session="zz-left" user="zz" host="apisnoop.cncf.io" :results silen
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket wait tmate-ready > /dev/null &&
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\' 2> /dev/null
# ssh -tt root@apisnoop.cncf.io \
#  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS: left_session
 #+BEGIN_SRC text :noeval
 #+END_SRC

**** Connecting to emacs daemon

 #+NAME: alse run emacsclient
 #+BEGIN_SRC tmate :noeval
 export SESSION=lt-emacs
 emacsclient --socket-name $SESSION
 #+END_SRC

*** Connecting the right pair / isocket

#+NAME: right_session_create
#+BEGIN_SRC shell :var session="zz-right" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n misc" \
  &
#+END_SRC


 #+NAME: right_session_join
 #+BEGIN_SRC shell :results silent
 export SESSION=api-snoop
 export XTERM_EXEC="roxterm -e"
 $XTERM_EXEC ssh -Att root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
   at \; sleep 9999
 #+END_SRC

 #+NAME: right_session_setup
 #+BEGIN_SRC shell :results verbatim
 export SESSION=api-snoop
 echo ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
    new-window -n session \
     bash
 #+END_SRC

 #+NAME: right_session
 #+BEGIN_SRC shell :cache yes :wrap "SRC text :noeval" :results verbatim
 export SESSION=api-snoop
 ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS[dd96525b42bbbe741e292e99ad5f3592a7163025]: right_session
 #+BEGIN_SRC text :noeval
 ssh mJrsCgvGTOTOFagYpBKvRf7EE@sf2.tmate.io
 #+END_SRC





 #+NAME: give this to your pair
 #+BEGIN_SRC bash :noweb yes :var left_session=left_session() right_session=right_session()
 echo "ii pair session ready
 left: $left_session
 right: $right_session
 "
 #+END_SRC

 #+RESULTS: give this to your pair
 | ii     | pair | session | ready |
 | left:  | nil  |         |       |
 | right: | nil  |         |       |
 |        |      |         |       |

*** TODO Sharing your eyes

#+NAME: give this to your pair
#+BEGIN_SRC bash :noweb yes :var left_session=left_session() :var right_session=right_session()
echo "ii pair session ready
left: $left_session
right: $right_session
"
#+END_SRC
** Working with d3
*** Introduction
   d3 is the data visualization library that was used to make our original sunburst.  The way it works is to mount itself to the dom, and then appends new elements to the dom based on the data it was given. If that data changes, it transforms the elements as needed.

   The way react works is it attaches itself to the dom, then creates a //shadow dom// that it is continually listening to, adding and removing elements in this dom as needed based on the data(the state) it was given.

   In other words, they work in largely the same way, and both wanna attach themselves to the dom and manipulate it.  This...isn't good.  We want to have /1/ thing making shadow doms and calls on the website, and so it is a bit tricky to get react and d3 working together.

The upside is that a number of people have tackled this challenge and created different react/d3 libraries for how the two can work together.  The downside is that I'm not sure yet which is the best to do.

Put simply, it is not easy to take our existing sunburst code and just paste it into our new app.  We are going to need to transform it in some way based on the guidance of the library we are using.

So the question is why we are putting ourselves into this trouble?
*** WHY WE ARE PUTTING OURSELVES INTO THIS TROUBLE
    My assumption with all of this is that when people hear 'apisnoop', they are thinking of the site in which you can see the data visualziations.  And so the webapp is important for the project and will be expanded.  React would be great for this in the long run.

Similarly, I am expecting that we are going to have more types of visualizations than just the sunburst--and that even the sunburst may change.  So we are going to want to have an understanding for a language in which we can make a //bunch// of visualizations. d3 is great for this.

If we do it right, we can have reusable components too that other teams could use for their own k8s projects, and that we could use ourselves.  For example--displaying two sunburst charts side by side would be much easier in react/d3 then what i ws trying to do before (appending both to the same id on a standard html document.)  This requires that I move through some d3 tutorials though.

At the end of this, though, we will have a backend server that is easy to setup and can ping different url's (github repos or testgrid artifacts) and grab their data.  Then, we can manipulate that data in whatever way we want but also pass it along to our frontend.  This front-end can then have different options and tags setto really dive in and explore.

If this is the purpose of apisnoop then let's do it.  If it's too much overkill though, then I can try a simpler solution.
*** Possible Process to get going
**** Setup a simple d3 visualization to understand the process
**** pipe data into this simple visualization through our redux state.
**** Pore over the original code again (the original blog post) to see how to best convert it
**** Change the sunburst's origin point from a CSV file to JSON
**** Change the sunbursts origin point from JSON to our redux store.
*** Second Process
**** Setup different pages for different d3-react libraries that already have ubilt components.
**** explore piping our data into the one we like.
**** Use testgrid conformance data and make simple visualizations to it.
     We are wanting to keep the data retrieval tied into the visualizing, so we dont' end up with a pretty graph that can't be used for what we have.  So we can grab the testgrid stuff now and see what we can do with it.


**** Use that going forward.
*** Possible Libraries to use
**** Victory
     https://formidable.com/open-source/victory/
**** Britecharts react
     https://eventbrite.github.io/britecharts-react/
**** Recharts
     http://recharts.org/en-US/
** Aaron Feedback
- useful troubleshooting tool:
  - adding test names to user agents to verify a test was testing what we thought it was.
  - filter audit logs by user-agent and then see 'when this test case is run, here are the endpoints it accesses chronologically".
    - This is separate from number of times hit.  that is useful in aggregate, this is something different.
  - pulling in an audit log of timestamp/verb/uri
- Feature of pointing to the specific line in the source for each test, to pull its definition, would be a good //Next// step.
  - This is something we can do with whakapapa, but it's not something we have now.
- Discovery front: Filtering more endpoints from APIsnoop's definition of coverage.
  - If beta endpoints always get hit because an api server is doing discovery, then that's cool but nothing we can ever prevent conformance tests from doing and we shouldn't care about it from a test coverage perspective.
  - How do we signify that this is the kinda hit that's happening for an endpoint?
  - We have a good start with filtering to just e2e, but even our e2etests are hitting those endpoints.  There are some endpoints where, logically they don't need to get tested or anything like that.
  - Get to a point whwere we can manually specify, or have a blacklist of apiendpoints that we aren't factoring into our coverage viz.
  - One way to do this is to filter out the endpoints that are hit by nearly all of the tests.  This is a good indicator that the endpoint is for initialization or something like that, and not actually a part of this test's function.
- Unique Endpoints hit by a test: this is something that isn't covered by our sunburst or katherine's viz.  Pick a test, and then see the endpoints that are //only// hit by this test.
  - which endpoints hit are unique, versus which ones are common across all test cases.  This would let us know which test cases are doing good stuff and which endpoints are essentially meaningless.
  - you could have a center endpoint change to the perspective of that test, and then that test would only show the endpoints that it hits.....but that may not be that useful.  We dont' wanna see All the endpoints, we wanna see which ones are //special// for this test.
  - Hierarchy vizes aren't that useful.
  - I just wanna find a way to slice and dice data with raw queries and see where that leads us...and take some of the more useful queries and generate reports from that.  This sounds like a new approach for apisnoop.

Question from this, then: Who is apisnoop's audience?  Is it Aaron,and people like aaron?  is it a kubernetes end user?  If it's aaraon, he is saying he knows how to write certain queries, but he would rather have this  already done and then he can do further exploration.
'For an endpoint that's only hit three times, what are the tests that are hitting this endpoint.  And then we could follow up with what the tests are doing from an api perspective.  'Okay, now let me see the full api stream from this test."
 - auotmate this, or provide shiny reports for this.  This isn't the end user coming up with the interesting things, this is us coming up with interesting things that we are letting the end user come to their own conclusions on.
 - We eventually want to show api coverage going up over time across different builds. o
 - We might be able to format things in such a way to have a test dashboard that shows individual api endpoints and #'s: how many times they been hit, something like that.
 - Is code coverage a different thing?  when talking about it being a command line tool that generates reports from it...or is that just what the group is trying to do.  the benefit of the command line tool is that you can automate it running for every build. We could then just have a page that displays these reports even maybe.
 - We want to share shinies at kubeconf china.
 - Get visualization up to good place that replaces existing visualization.
 - Showing all the api accesses per user-agent or test as a different Dashboard to have.
 - Take care of you for whatever demos you need for apisnoop.
 - It would be worth it to show we're providing value to cncf as a whole, but right now it's good to just be able to have Aaron say that the work we're doing makes it easier for conformance to do the things they want to do.
 - Let's not work on things that don't end up providing value, over-delivering when he really just wants somethings maller and specific.  He's happy to have some reports that don't need to be that shiny, but maybe a little bit interactive.  and these reports would be:
   - If I click on a user agent, I can see the in-order access of all the api endpoints.
   - To get some kind of report that shows me what kind of endpoints don't matter (every test hits them) and which ones are interesting (cos only a few endpoints hit them) and what are those tests?
     - this may lead to a point where we try to make a whitelist of endpoints in our coverage, but let's not cross that bridge yet.
   - For wednesday deadline...this isn't a hard deadline, we can touch base on Tuesday/Monday and see where we at.
** Pairing With Mikey
*** Background
    I went through a pairing Session with [[https://dinosaur.is][Mikey]], to help with the overall architecture and code logic of the webui
* Experiment
  :PROPERTIES:
  :header-args: :dir (concat (file-name-directory buffer-file-name) "client")
  :header-args:tmate: :socket "/tmp/.zz-right.isocket"
  :header-args:tmate: :session "zz-right"
  :END:

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
* Tasks
** TODO [7/11] Tasks For Refactoring our Data and understanding of it.
   - [X]  Convert JSON dump to New Flat Database
   - [X] Hookup react/redux to query endpoints.
   - [X] Integrate Reselect to computed data views (instead of getting data, withoutm assaging, and trying to fit it into the sunburst.)
   - [X] Practice Converting flat database to Sunburst Data structure.
   - [X] Sort Level so it is Stable, Beta, Alpha
   - [X] pass down chart selector data to main page props, pass down focused key path to render label within sunburst
   - [ ] Add Percentage Calculation to center label.
     - I think I would want to do a data transformation, that counts the isTested for each of the child nodes, and piles that into an equation in the parent node.
     - How much of the existing work can I use with this?
     - STRATEGY: we've added the coverage to our endpoints information.  So we could now have a 'coverage' selector that listens to the full path array and finds the coverage information in the endpoints for it.  We don't need to do any extra action, we just need to work off our existing stuff.
     - If nothing is set, then we are going to want to know the coverage by release.  So the first step, then, would be: 'Without Focus Path selectInteriorLabel = endpoints[release][coverage]' with focus path it would be endpoints[release][fp1][fp2][coverage]...i guess based on the full apth length (it could be up to 3, level, category, endpoint).

   - [ ] Change endpoint path so it displays UNTESTED for the whole untested block (currently displaying random endpoint name).
   - [ ] re-hook up routing to route by release name
   - [X] Query endpoints by Release.
   - [ ] remove dependency on releaseStore reducer.
** TODO [1/8] Future Tasks
   - [ ]  Integrate user interaction with sunburst (filter by UserAgent).  This'll test our hypothesis that we can manipulate the data far quicker than before.
   - [X] Hover over Part of Sunburst shows relevant rays highlighted.
   - [ ] Hover over Sunburst, see testing percentage update in center.
   - [ ] Click on Useragent, sunburst zooms onto that subset of data.
   - [ ] Refactor Chart Selector to not be heavily nested..
   - [ ] Move colors calculation out of sunburst selector into its own thing.
   - [ ] Separate sunburst selector thangs from chart interaction thangs (maybe?  may be premature optimization).
   - [ ] Remove unused props from app.js
** TODO [4/5] Achievements To Unlock
   - [X] Mikey has a functional understanding of what we're trying to do.
   - [X] It generally feels better
   - [ ] Sunburst Matches Functionality of Previous Sunburst
   - [X] Sunburst Changes Based on Route
   - [X] It loads faster
** TODO Add logic to API to filter endpoints to only those touched by e2e.
   We are showing all.  It'll be faster, and simpler to only be ones whose useragents includes the regex string 'e2e.test'

** DONE Change front-end logic so it only pulls data from the necessary sunburst.
   CLOSED: [2018-11-04 Sun 22:29]
   Right now the we have an endpoint called /Releases, organized by Build name.  These correspond to the sunbursts.  We are pulling in the entire api, we should only do buildname.data.sunburst
*** [0/5] Subtasks
    - [ ] Remove excess noise from front-end for right now--the filters essentially.
    - [ ] Add URL path to each Release you click
    - [ ] Add fetchSunburst action to sunburst segment component, and pass it along the url params.
    - [ ] Query the api database based on the params and return just the sunburst data.`
** DONE change keypath logic so it only highlights if parent is on keypath.
   CLOSED: [2018-11-04 Sun 22:30]
** TODO [0/1] Questions
   - [ ] Why does brining in the selectsunburstSorted selector affect the sunburst (when it is a new selector, not the previous one.
