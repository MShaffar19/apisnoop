#+NAME: APISnoop WebUI
#+AUTHOR: Zach Mandeville
#+EMAIL: zz@ii.coop
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(i) | DONE(d) DONE-AND-SHARED(!)
#+PROPERTY: header-args :dir (file-name-directory buffer-file-name)
#+XPROPERTY: header-args:shell :results silent
#+XPROPERTY: header-args:shell :exports code
#+XPROPERTY: header-args:shell :wrap "SRC text"
#+PROPERTY: header-args:tmate :socket "/tmp/.zz-left.isocket"
#+PROPERTY: header-args:tmate :session api:main

* Introduction
  This is a web-based visual interface to the data curation and manipulation we are doing as the APISnoop project.  The purpose is to display previously unseen connections between the testing coverage of kubernetes, and the people and communities these various parts of kubernetes matter to.
** Reimagining how the web app is built.
   At this point, the work here is a proof of concept refactoring of the orignal site, to make our structure more extensible and modular.  When new work is done with the dating processing, we want to be able to quickly visualize the results of this work for others.  The current site is static html, with each new section intentionally and manually hard-coded. Whenever we want to make a change to the site (like adding a new dataset), it requires going into the html file, finding the right section, and adding a new element.  We have to keep a mental map of every aspect of the site this new dataset should influence and update those accordingly.  Not only is this time-consuming, it's error-prone and hard to maintin.

   At the same time, there was a good amount of work done by the team to get to the current site, and that work should be preserved as much as possible.  The goal of this refactor, then, is to re-make the original site to then build incredible things beyond and above it.
http://uber.github.io/react-vis/documentation/other-charts/sunburst-diagram
** Setting It up On Your own
*** Setup Backend
 after cloning repository
- cd apisnoop/backend
- npm install
- Make sure we have a jsons folder in apisnoop/backend with this tree structure:
#+RESULTS: File Structure
:RESULTS:
.
├── release
└── sunbursts

2 directories
:END:
#+NAME: File Structure
#+BEGIN_SRC shell :dir ./backend/jsons :results output raw drawer
tree -d
#+END_SRC
- Delete all .db's from src/data/
- npm start
- email zz@ii.coop with full error output and a coupon for soda.

*** Setup Client
    When backend server is on:
    - cd apisnoop/client
    - npm install
    # - figure out how to point to subheadings
    - go to [[Client/Actions/index.js]]   and change the client here to be whatever site you have this on (localhost or apisnoop)
    - npm start

* Architecture
The site will be made to have a distinct front-end and backend, with the front-end able to be ported over to any other backend.
The front-end will consist of multiple components that wait to be told what data to display, instead of being written as part of the component.  In this way, if we want to make changes to our 'SIG Tag Bubble', we can just find the component named that and make changes there, instead of trying to find/replace the code within the file.
** FRONTEND
The frontend will be made with React, Redux, maybe Saga, and Tachyons, and Axios
*** Why React?
    [[https://reactjs.org/][React]] is the most well-known and supported front-end framework among my dev friends in Wellington, and is widely used and respected globally.  It was created originally by Facebook and then made open-source.  So it has a tremendous amount of support around it and good video tutorials for learning it.  I find it to be a bulky and kinda clumsy framework (which is why the first version of this used my personal fave Choo instead), but felt it was good to pick one that more people knew (and could help with).

*** Why Redux?
   [[https://redux.js.org/][Redux]]  provides one global 'state' for the app, and makes React actually usable.  It will help us push the data appropriately to the right parts and keep things clean and efficient.

*** AXIOS
   [[https://www.npmjs.com/package/axios][Axios]] is a simple tool for handling http requests across different servers.  We'll need this for the client to be portable, and able to call to multiple API's (our backend plus github for example).
*** Why Saga?
   [[https://redux-saga.js.org/][Saga]] helps us with api calls and redux.  Redux likes pure clean objects sent to the store right away.  API calls don't work like that, and so Saga does the call and then sends the results to Redux.  It's working as a side effect.

*** Why Tachyons?
    Tachyons is a css framework for writing functional CSS.  It's a much different approach to CSS, but it's one that matches a unix philosophy and is super easy to spin things up and maintain them.  AS we make changes, we don't have to worry that some class hidden deep in some css file causes our whole site to look weird.  Instead, every class has a single purpose, and you add multiple classes to a site to add-upon and combine each of these classes functions (like piping commands together on the command line).  This makes all our components //reusable// too, as we only need to copy over the code and not any stylesheet attached to the code.
** BACKEND
   For the backend we will be using Feathers //for right now//.  We may find that we want something completely different, or that we want our webui to be able to live in multiple places.  Our goal is for the two to be entirely separate, so either can change if needed.
*** Feathers
    [[https://feathersjs.com/][Feathers]] is a well-designed and well-documented api layer written in Node.  It has good support among my Wellington dev friends, and so I have better help if I encounter any sorta problem.  It also is just really pleasant to use so far, with a good model for how to create different services.  It also has an existing React connector.
**** Feathers Resources
***** [[https://www.youtube.com/playlist?list=PLwSdIiqnDlf_lb5y1liQK2OW5daXYgKOe][youtube channel]]
***** [[https://stackoverflow.com/questions/tagged/feathersjs][stackoverflow tag]]
***** [[https://github.com/issues?utf8=%25E2%259C%2593&q=is%253Aopen+is%253Aissue+user%253Afeathersjs+][github page]]
***** [[https://blog.feathersjs.com/][medium page]]
***** [[http://slack.feathersjs.com/][slack channel]]

** Our Current Flow
   I would like to document the current setup, to make sure I can reason about it.

  We will have a site listed anywhere, for now it's localhost so we'll call it LH.

  We want to know which commits(?) of kubernetes should have conformance tests made for them, this is handled in a config.yaml file in kubernetes test-infra folder on github.

 The log of their tests is found in the artifacts of the latest build of the test found in gcsweb.k8s.io.  We need to know the exact url to ping for gcs to return any proper info for us.


And so we grab the config info from github and parse its contents looking for commits that we are intersted in (like all gce-conformance commits).  Then, we take a look at the test_group_name for each commit and use that info to parse the config file again.  Each test group name has a GCS_Prefix, which gives us the url path we can ping with gcsweb.io

So let's say there's a commit called 'commmit1.2'.  This commit has a test_group_name of 'foo_test'.  That test_group has a prefix of '/jenkins/tests/log/foo_test'.  This means we can go to gcsweb.io/gcs/jenkins/tests/log/foo_test and get more information about this particular test group.

That information is a bit of an overload though.  It has folders for all the builds along with a text file that contains a number that is the latest build.  so in foo_test we'd see a bunch of folders named "100, 101, 102, 103" plus "latest-build.txt".  Clicking on latest-build.txt gives us something like: '103', which we know means we should look in folder 103 for all the relevant stuff.

The txt file, though just a number, isn't stored on gcsweb.io.  It's actually stored at 'storage.googleapis.com'.  So trying to grab gcsweb.io/$GCS_PREFIX/latest-build.txt will give us a redirect.  If we grab that number, following the path of that latest build folder leads us to a url of something like:
http://gcsweb.k8s.io/gcs/kubernetes-jenkins/logs/foo_test-1-12/187/artifacts/bootstrap-e2e-master/

there's also different bootstrap folders beyond master for many of these.

Then, inside //this// folder would be some audit-logs.  These logs are what we are REALLLY looking for, as they have the data we want to visualize.


This means, though, that when we start up the app we need to ping github and with the converted response from that ping gcsweb.k8s.io and with the response from that site ping gcsweb again but at a specific url, looking for a specific type of file and with the response of that get a big buffer of text that we try to convert into json so that we can feed it into our components.


I feel like this is a tremendous amount to put onto a webpage upon first loading, and that there's a number of errors that could come up.  How much of this can be done by our server so it's at the ready when the page loads up.

For example: I can't imagine the config.yaml file updates /aaaalll/ that much.  If we have something that is current to the latest day, or even yesterday, would that be okay?  And if that's okay, is there a way we could pull the yaml file and add it to our database so we'd have something like:
- ourserver.com/dashboards
- ourserver.com/test_groups
- ourserver.com/commits
and each of these we could ping instead to get the info we want?  Then we aren't doing real-time conversion of a blob into a string into yaml into json---it's just ready for us.

In the same way, is there anyway we can parse our own api and grab the audit logs we need, and have them converted into json for us to parse.  So the web page loads, pings our server, finds the audit logs, and renders them.....That might be redundancy though, since they //are// already available on a server at gcsweb.  It just takes us some loops to figure out where.

The question I have, ultimately, is how much should be handled by the client and how much should be pre-requested/filtered/converted by the server before the client latches on---and whether there's a simpler way to do what we're trying to do.

* Backend
** Setting up our API Initially
**** Generating the backend app.
     #+NAME: Generate Feathers App
     #+BEGIN_SRC shell
       mkdir backend && cd backend
       feathers generate app
     #+END_SRC
**** Generating the Services
     We'll need a config service, which will be custom.  It makes a request to our config.yaml file and then distributes its contents to our various other services.
 From there, we need a service named for each of the major groups:
 - dashboards
 - test_groups
 - dashboard_names
** Services
   (**NOTE**: for each service, make sure paginate is turned off.  In the future I should do this automatically.)

Services refer to the different paths of our api, and the various jobs and manipulation we do to the data being fed through these paths.  They act as gatekeeepers to our various db's, so we aren't doing a bunch of db queries from all over the code and potentially causing strange behavior and hard to track errors.  Throug these, we have a consistent and reliable way to ask for and give data to our server: talk to the relevant service and have them do the work for you.
*** Services Breakdown
- [[*Config][Config]] :: Sets up majority of other services, taking from either our config.yaml file or our sunburst directory.
- [[*Release][Release]] :: takes each of the files located in ~jsons/release~ and creates services for the various sections held here, then populates these services with each branch's relevant info.
- [[*Dashboards][Dashboards]] :: is generated by Config, the dashboard in the testgrid ui, which we can use to get better context about each branch and job.
- [[*Audits][Audits]] :: is generated by config, information about each job/branch/audit(name tbd) that compiles relevant info from the dashboards and other bits of data distributed across the k8s community.
- [[*Sunburst][Sunburst]] :: Data formatted to work with our sunbursts.
*** Config
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./backend/src/services/config/config.class.js
    :END:

    This is the service used to ping github for our config file, and then populate the various dashboards from there.
**** Basic Layout
     So we create a new class for the service and construct it with the options we give it.  In this case, the options relate to the request to our github api that we want to send.  Then, we have a number of commented out methods followed by our setup method.  The setup method requests the configyaml from github, loads it into json, and then distributes each group using our distribute function (described in more detail below).
     #+NAME: config.class.js
     #+BEGIN_SRC js
       /* eslint-disable no-unused-vars */
       const request = require('request-promise')
       const yaml = require('js-yaml')
       const fs = require('fs')

       // hi.
       var options = {
           url: 'https://api.github.com/repos/kubernetes/test-infra/git/blobs/66c3f57e899a92afc9f6fca20387220a65312915',
           headers: {
               'User-Agent': 'request'
           }
       }
       //location of sunburst jsons
       var dir = './jsons/sunbursts'

       class service {
           constructor (options) {
               this.options = options || {};
           }

           async setup (app, params) {
               populateSunburst(app, dir)
              // request(options).then(blob => {
               //    blob = JSON.parse(blob)
              //     var content = Buffer.from(blob.content, 'base64').toString()
              //     var configGroups =  yaml.safeLoad(content)
              //     distribute(app, configGroups)
             //  })
           }
       }

           <<Distribute Config Groups To Individual Services>>
           <<Populate Entries For Each Config.yaml Service>>
           <<Define populateSunburst>>

       module.exports = function (options) {
           return new service(options);
       };

       module.exports.service = service;
     #+END_SRC

     #+RESULTS: config.class.js
**** Distribute Config Groups To Invidiual Services

     Our config file is given a number of groups, and half of them we don't care about.  We want to just create api services for these.
     Each of these will need to have a service named like so: 'api/v1/service_name', this is done using the feathers cli (feathers generate service)
     #+NAME: Distribute Config Groups To Individual Services
     #+BEGIN_SRC js :tangle no
       function distribute (app, configFile) {
           var relevantSections = ['dashboards', 'test_groups', 'dashboard_groups']
           for (var section of relevantSections) {
               var configSection = configFile[section]
               var service = app.service(`/api/v1/${section}`)
               populate(service, configSection)
           }
       }

     #+END_SRC

**** Populate Entries For Each Service
     Here we check the current db for the entry, using its name.  If it doesn't exist, we make it.  If it does, we should update it.
     first we have to check whether there's anything that exists.  So we do a service.find() and if there are no results, we create the entry.  If there are results, we check if they match our query.

     This is kind of a gross function (or a straight up gross function) I don't l ike nested if/else statements.  I feel there is a better way to handle this.
     I am also having a problem where it is only creating a single entry every single time for each one.  like...it knows

     Once I do have this, then i'll be able to restart the server, it'll make a db if needed, if not it will check the db for the existing entry, and then it will add or updae the entry....

     For some reason right now, it is only adding the last one--but enough times that I know it's going through each one.  Do I need to await some respone on a thing?
     #+NAME: Populate Entries For Each Service
     #+BEGIN_SRC js :tangle no
       async function populate (service, configSection) {
           for (var entry of configSection) {
               var existingEntry = await service.find({query:{name: entry.name}})
               if (existingEntry.length === 0) {
                   service.create(entry)
               } else {
                   service.update(existingEntry[0]._id, entry)
               }
           }
       }

     #+END_SRC

**** Define populateSunburst
     #+NAME: Define populateSunburst
     #+BEGIN_SRC js :tangle no
       async function populateSunburst (app, dir) {
           var sunbursts = fs.readdirSync(dir)
           for (var sunburst of sunbursts) {
               fs.readFile(`${dir}/${sunburst}`, 'utf-8', (err, data) => {
                   if (err) console.log({read_file_err: err})
                   addToSunburst(app, sunburst, data)
               })
           }
       }

       async function addToSunburst (app, sunburst, data) {
           var service = app.service('/api/v1/sunbursts')
           var json = JSON.parse(data)
           var existingEntry = await service.find({query:{name: sunburst}})
           if (existingEntry.length === 0) {
               service.create({name: sunburst, data: json})
               console.log(`sunburst made for: ${sunburst}`)
           } else {
               service.update(existingEntry[0]._id, {name: sunburst, data: json})
               console.log(`sunburst updated for: ${sunburst}`)
           }
       }

     #+END_SRC

     we read each file from our sunburst directory, which will give us a big string that we have to convert to JSON to do an ything useful with.  We then create that entry using the JSON now as its data.  The creation will be passed along to our [[*cleanSunburst][cleanSunburst]] hook, where we pass over each interior object and make sure k8s.io.fun becomes k8s_io_fun

*** Release
**** Setting up Release service.
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./backend/src/services/release/release.class.js
     :END:
***** Basic Layout
 #+NAME: service.class.js
 #+BEGIN_SRC js
   /* eslint-disable no-unused-vars */
   const fs = require('fs')

   var options = {
   }

   var services = [
     'statistics',
     'results',
     'unknown_methods',
     'unknown_urls',
     'counts'
   ]

   class service {
     constructor (options) {
       this.options = options || {}
     }

     async setup (app, params) {
       var dir = './jsons/release'
       fs.readdir(dir, (err, jsons) => {
         if (err) {
           console.log({setup_err: err})
         }
         for (var json of jsons) {
           populateServicesFromJson(app,dir, json)
         }
       })
     }
   }

   <<Populate Services From Json>>
   <<Parse and Distribute>>
   <<Update Service of Section>>

   module.exports = function (options) {
     return new service(options)
   }

   module.exports.service = service
 #+END_SRC

  the purpose is to read through our directory of results json and make an entry in the correct service for each section of the json.

***** Populate Services From Json
      #+NAME: Populate Services From Json
      #+BEGIN_SRC js :tangle no
        async function populateServicesFromJson (app, dir, JSON) {
          fs.readFile(`${dir}/${JSON}`, 'utf-8', (err, results) => {
            if (err) {
              console.log({ERR_populate_json: err})
            }
            parseAndDistribute(app, results, JSON)
          })
        }
      #+END_SRC
***** Parse and Distribute Sections of JSON file
      #+NAME: Parse and Distribute
      #+BEGIN_SRC js :tangle no
         async function parseAndDistribute (app, results, Name) {
           results = JSON.parse(results)
           var keys = ['statistics', 'results', 'unknown_methods', 'unknown_urls']
           for (var key of keys){
             var service = services.find(service => service.includes(key))
             var section = results[key]
             updateServiceOfSection(app, service, section, Name)
           }
         }

      #+END_SRC

***** Update Service of Section
      #+NAME: Update Service of Section
      #+BEGIN_SRC js :tangle no
        async function updateServiceOfSection (app, service, section, name) {
          var appService = app.service(`/api/v1/${service}`)
          name = name.replace('-audit-data.json','')
          var existingEntry = await appService.find({query:{name: name}})
          if (existingEntry.length === 0) {
            appService.create({name, data: section})
            console.log(`Entry Added to ${service} from ${name}`)
          } else {
            appService.update(existingEntry[0]._id, {name, data: section})
            console.log(`Entry Updated for ${service} from ${name}`)
          }
        }
      #+END_SRC



***** NEXT Refactor data coming in so paths don't have '.'
      feathers cannot add things to the Db if the field name includes a '.'.  I think it's an issue with nedb...so I could change the db there...but i'm not sure the best path to go forward to be honest.
***** TODO refactor  to not have to pass app so many times, take advantage of async
*** Sunburst
**** Hooks
***** cleanSunburst
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/clean-sunburst.js
      :END:
      #+NAME: cleanSunburst
      #+BEGIN_SRC js
        const _ = require('lodash')

        module.exports = function (options = {}) {
          return async context => {
            var data = context.data.data
            data = cleanUp(data)
            console.log({sunburst: Object.keys(data.tree)})
            context.data = {name: context.data.name, data}
            return context;
          }
        }

        function cleanUp (obj) {
          var cleanObj = {}
          for (key in obj) {
            if (Object.prototype.toString.apply(obj[key]) === '[object Object]') {
              cleanObj[key.replace(/\./g,'_')] = cleanUp(obj[key])
            } else {
              cleanObj[key.replace(/\./g,'_')] = obj[key]
            }
          }
            return cleanObj
        }

      #+END_SRC
      context is each entry added to the service.  Context.data is the body of the entry that we provide (everything else is additional context about a thang.)  We are providing a name for each entry, pulled from its json file and all the json as the ~data~ field.

      The data looks like so:
      #+NAME: sunburst object structure
      #+BEGIN_SRC json :tangle no
        {starburst: {
          alpha: {
            settings {...},
            rbacauthorization {...},
            storage	{…},
            batch	{…},
            admissionregistration	{…},
            scheduling	{…},
            auditregistration	{…}
          },
          beta: {
            settings {...},
            rbacauthorization {...},
            storage	{…},
            batch	{…},
            admissionregistration	{…},
            scheduling	{…},
            auditregistration	{…}
          },
          stable: {
            settings {...},
            rbacauthorization {...},
            storage	{…},
            batch	{…},
            admissionregistration	{…},
            scheduling	{…},
            auditregistration	{…}
          }
        }
      #+END_SRC

      Each subkey within alpha,beta,stable is a path of the api (and within each is a method like get push delete etc).  The path includes periods which we need to turn into underscores.

      There is likely a quicker way to do this, but for now I set up two functions, one that iterates and changes each key within the object by passing that key to another function, which converts the keys' `.` to `_`.

      Then, we can set this clenaed up data as the new context data and pass the context along.
      If we wanted to, we could then run our buildJsonHierarchy on the data, making a new section called 'formatted' and then we'd just call upon that. This way, we aren't doing the building of the data in our front-end.  the front-end just displays the right stuff we give it.
*** Dashboards
  accessible at /api/v1/dashboards
**** Hooks
***** cleanupGcsDashboard
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/cleanup-gcs-dashboard.js
      :END:
      Interesting thing here with async functions.  I have to put the quick ones in (like addBranch) before I do the addGcsPrefix.  If I try to add branch //after// this, then dashboardTab becomes undefined, or rather it is a pending promise of sorts.  There is a style of chaining these together that I know will make me happy, I feel like I am on the edge of comfort and this likely means someone else figured out a solution to this problem I am having.
      #+NAME: cleanup-gcs-dashboard.js
      #+BEGIN_SRC js
        // Use this hook to manipulate incoming or outgoing data.
        // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

        // eslint-disable-next-line no-unused-vars
        module.exports = function (options = {}) {
          return async context => {
            if (context.data.name === 'conformance-gce') {
              context = await elaborateUpon(context)
            }
            return context;
          };
          async function elaborateUpon (context) {
            var dashboardTab = context.data.dashboard_tab
            var test_groups = context.app.service('/api/v1/test_groups')
            dashboardTab = addBranch(dashboardTab)
            dashboardTab = await addGcsPrefix(dashboardTab, test_groups)
            return context
          }

          async function addGcsPrefix (dashboards, test_groups) {
            var promises = dashboards.map(async dashboard => {
              var gcsPrefix = await grabGcsPrefix(dashboard, test_groups)
              dashboard.gcs_prefix = gcsPrefix
              return dashboard
            })
            const results = await Promise.all(promises)
            return results
          }

          async function grabGcsPrefix (dashboard, test_groups) {
            var tg = dashboard.test_group_name
            var test_group = await test_groups.find({query: {name: tg}})
            return test_group[0].gcs_prefix
          }
          function addBranch (dashboards) {
            return dashboards.map(dashboard => {
              var name = dashboard.name.toLowerCase()
              if (name.includes('(dev)')) {
                dashboard.branch = 'dev'
              } else if (name.includes('release')) {
                dashboard.branch = 'release'
              } else {
                dashboard.branch = 'none given'
              }
              return dashboard
            })
          }

        };

      #+END_SRC
***** AddLatestBuild
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/add-latest-build.js
      :END:
      After the dashboard has been cleaned up, we check it's gcs_prefix and use that to find its latest build number.  This will require pinging that server and awaiting its response back.

      When you generate a hook using feathers cli, it automatically makes it an asynchronous hook.  This means that the functions happen in sequence in our dashboards.hooks.js.  So because addLatestBuild comes after

I started with a basic skeleton, and kinda like how i debugged this (or set it up as a thing to work on).  I wrote up the functions for the steps I'm trying to do, knowing each one would be asynchronous.  So here it's saying: if the thing coming in is for conformance, then add Builds for the Dashboards in its data before you return the context to the next thing (i.e. add it to the database).

For adding builds, we want to define the dashboards and then say they are going to be transformed by addingtheLatest build.  This is an asynchronous map function that returns just some hard-coded text back.

I console.log that text in my addLatestBuild section then, in my terminal running the program I have ~npm start | grep latestBuild~  .  So now I can just monitor that feed and make sure it shows what I think it should show.  If it does, I can then check out the dashboard on localhost to confirm that a latestBuild section has been added.

So now, I have a console.log setup to help me quickly, and I can confirm that the basic structure of all of this (the logic or whateveR) works.  Now I just need to have the grabLatestBuild portion ping a server.M
    #+NAME add-latest-build.js rough
    #+BEGIN_SRC js :tangle no
      // Use this hook to manipulate incoming or outgoing data.
      // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

      // eslint-disable-next-line no-unused-vars
      const rp = require('request-promise')

      module.exports = function (options = {}) {
        return async context => {
            if (context.data.name === 'conformance-gce') {
              addBuildsForDashboards(context)
            }
          return context;
        };

        async function addBuildsForDashboards (context) {
          var dashboards = context.data.dashboard_tab
          dashboards = await addLatestBuild(dashboards)
          return context
        }

        async function addLatestBuild (dashboards) {
          var promises = dashboards.map(async dashboard => {
            var latestBuild = await grabLatestBuild(dashboard)
            dashboard.latestBuild = latestBuild
            return dashboard
          })
          const results = await Promise.all(promises)
          return results
        }
        async function grabLatestBuild (dashboard) {
          var buildURL = `http://gcsweb.io/${dashboard.gcs_prefix}/latest-build.txt`

          return `put build here for ${buildURL}`
        }
      };

    #+END_SRC

so here is the good stuff.
    #+NAME add-latest-build.js
    #+BEGIN_SRC js
      // Use this hook to manipulate incoming or outgoing data.
      // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

      // eslint-disable-next-line no-unused-vars
      const rp = require('request-promise')

      module.exports = function (options = {}) {
        return async context => {
            if (context.data.name === 'conformance-gce') {
              context = await addBuildsForDashboards(context)
            }
          return context;
        };

        async function addBuildsForDashboards (context) {
          var dashboards = context.data.dashboard_tab
          dashboards = await addLatestBuild(dashboards)
          return context
        }

        async function addLatestBuild (dashboards) {
          var promises = dashboards.map(async dashboard => {
            var latestBuild = await grabLatestBuild(dashboard)
            dashboard.latestBuild = latestBuild
            return dashboard
          })
          const results = await Promise.all(promises)
          return results
        }
        async function grabLatestBuild (dashboard) {
          var url = `http://gcsweb.k8s.io/gcs/${dashboard.gcs_prefix}/latest-build.txt`
          var latestBuild = await rp(url)
          return latestBuild
        }
      };

    #+END_SRC
***** createAuditEntry
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/create-audit-entry.js
      :END:
      We'll be given a dashboard context that, if it has conformance-gce, should submit itself to the audits service with all the relevant deeetails.  We'll make this simpel right now, and handle the pinging of the server with the audits service.

      I also have confusion about async stuff still, of course.  I had issues when passing along the data originally that the dashboards would suddenly lose alot of details.  It works when I made success asynchronous, even though it's nonsense.  Like, everything I do is a 'sideffect' of the success function.  This doesn't smell right. and should be refactored.

      #+NAME: create-audit-entry.js
      #+BEGIN_SRC js
        // Use this hook to manipulate incoming or outgoing data.
        // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

        // eslint-disable-next-line no-unused-vars
        module.exports = function (options = {}) {
          return async context => {
            if (context.data.name === 'conformance-gce') {
                var dashboards = context.data.dashboard_tab.filter(dashboard => dashboard.branch.includes('dev'))
                var success = await createAuditsFrom(context, dashboards)
            }
            return context;
          };

          async function createAuditsFrom (context, dashboards) {
            var auditService = context.app.service('/api/v1/audits')
            for (var dashboard of dashboards) {
              var artifactsPath = `http://gcsweb.k8s.io/gcs/${dashboard.gcs_prefix}/${dashboard.latestBuild}/artifacts/`
              var existingEntry = await auditService.find({query:{branch: dashboard.name}})
              if (existingEntry.length === 0) {
                auditService.create({
                  branch: dashboard.name,
                  build: dashboard.latestBuild,
                  artifactsPath: artifactsPath
                }).then(res => console.log(`entry made for ${res.branch}!`))
              } else {
                auditService.update(existingEntry[0]._id, {
                  branch: dashboard.name,
                  build: dashboard.latestBuild,
                  artifactsPath: artifactsPath
                }).then(res => console.log('entry updated! for ' + res.branch))
              }
            }
            return 'good job'
          }
        }
      #+END_SRC
      #+RESULTS: create-audit-entry.js
***** next
*** Audits
    Takes the conformance-gce dashboards, finds the ones that are on dev, and adds their info as audit entries.
**** Hooks
***** acquireAuditLog
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/acquire-audit-log.js
      :END:
      We are using rp and cheerio to ping the gcsweb url that has all the various info from each k8s branch.  Our relevant info is within their bootstrap e2e master section, and we want to just look at the audit-log we find within there.

I checked the strucure of the file, and each link is held within a ~pure-u-2-5~ class.  Cheerio is like the node version of jquery, and so we can do nice jquery stuff like grab the hreft for the a link witin the pure class that contains the word 'audit'.

    #+NAME: acquireAuditLog
    #+BEGIN_SRC js
      // Use this hook to manipulate incoming or outgoing data.
      // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

      // eslint-disable-next-line no-unused-vars
      const rp = require('request-promise')
      const cheerio = require('cheerio')

      module.exports = function (options = {}) {
        return async context => {
          var auditLogPage = context.data.artifactsPath + 'bootstrap-e2e-master/'
          var auditLogArray = await crawlPage(auditLogPage)
          context.data.auditLogArray = auditLogArray
          return context;
        };

        function crawlPage (page)  {
          var options = {
            uri: page,
            transform: (body) => cheerio.load(body)
          }
          return rp(options).then(($) => {
            var links = $('.pure-u-2-5 a:first-of-type:contains(audit)').attr('href')
            return links
          })
        }
      }
    #+END_SRC
***** downloadAuditLog
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/download-audit-log.js
      :END:
****** General Notes
       This will happen after acquire, so we know that we have auditLogArray.  We'll take this array's url, and use request promise to grab all the stuff located there and write it to file.

       Since it's a big file, we'll wanna have a write stream, and perhaps upon success a ping saying '${branch} was successfully written.'

       A way to test this is to download the audit log to the same directory with a diff name, and then compare the line count for both files.

       We already have a data folder, that's holding our databases, and so I made a new folder called audit-logs within that file.  And I //think// we can just do a direct path to that from our hook.  So...i'ma try it now!
****** Code
    If you don't want to write all the logs to disk, then you can comment out writeToFile(branch, logPath)
    #+NAME: download-audit-log.js
    #+BEGIN_SRC js
      // Use this hook to manipulate incoming or outgoing data.
      // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

      // eslint-disable-next-line no-unused-vars
      const rp = require('request-promise')
      const fs = require('fs')
      const _ = require('lodash')

      module.exports = function (options = {}) {
        return async context => {
          var logPath = context.data.auditLogArray
          var branch = context.data.branch
          // writeToFile(branch, logPath)
          return context;
        }
        <<write to file>>
        <<format by pattern>>
      }

    #+END_SRC

    If given the path to the file, I should be able to set up a write stream that writes all the contents.  I am a little unsure where everything would download (like the relative path), and so I'll do a simple stream that just takes the name given and writes it to a file named after that particular branch.

    The branch will have a name like 'GCE, v1.12 (release)'. I'd like this to be a filename, but it should be closer to gce_v1-12-release_audit.log
    I could do a bunch of string replacements, but I think lodash would be faster.
    #+NAME: write to file
    #+BEGIN_SRC js :tangle no
      function writeToFile(branch, path) {
        var regex = /(,|.| |\(|\))/g
        var formattedPath = _.replace(branch, regex, formatByPattern)
        var fileName = `${formattedPath}audit.log`
        var writeStream = fs.createWriteStream(`./data/audit-logs/${fileName}`)
        console.log(`Attempting to write file for: ${fileName}` + '\n' + 'from:' + '\n' + path + '\n' + '~*~*~*~*~*~*~~*~*')
        rp(path)
          .then(response => {
            writeStream.write(response)
            writeStream.end()
            writeStream.on('finish', () => console.log(`file written: ./data/audit-logs/${fileName}!`))
            writeStream.on('error', (err) => console.log(`error for ${fileName}: ${err}`))})
          .catch(err => console.log('request promise error: ' + err))
      }
    #+END_SRC

    #+NAME: format by pattern
    #+BEGIN_SRC js :tangle no
      function formatByPattern (str) {
        switch (str) {
          case ',':
          case ')':
            return '_'
          case '(':
          case '.':
            return '-'
          case ' ':
            return ''
          default:
            return str
        }
      }
    #+END_SRC

    #+RESULTS: format by pattern
    : undefined

***** generateDataFromJson
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./backend/src/hooks/generate-data-from-json.js
      :END:
      FOR THE DEMO, GONNA CHANGE: we have a number of json files in our /jsons/ folder within the backend.  They are named stuff like `dev-1.10.json'.  We want to match the audit entry to this json file and then add it as ~DATA~ (name will change).
      So then we will generate a feathers hook for:
    - Audits Service
    - named: generateDataFromJson
    - After
    - Create, or Update
    #+NAME: generateDataFromJson
    #+BEGIN_SRC js
      const _ = require('lodash')
      const fs = require('fs')
      // Use this hook to manipulate incoming or outgoing data.
      // For more information on hooks see: http://docs.feathersjs.com/api/hooks.html

      // eslint-disable-next-line no-unused-vars
      module.exports = function (options = {}) {
        return async context => {
          var entry = context.data
          var build = _.words(entry.branch, /([0-9]|\.)/g).join('')
          var jsons = fs.readdirSync('./jsons')
          var json = jsons.filter(fileName => fileName.includes(build) && fileName.includes('.json'))[0]
          var rawString = fs.readFileSync(`./jsons/${json}`, 'utf-8')
          context.data.data = JSON.parse(rawString)
          return context;
        };
      };

    #+END_SRC

    #+RESULTS: generateDataFromJson

It's a huge file, so we are going to need to
***** other one?
      :PROPERTIES:
      :END:
* Client
  :PROPERTIES:
  :header-args: :dir ./client
  :END:
  The client will be all the files that bundle up into a bundle.js file that is called on our index.html page.  In other words, the FRONTEND
** Running the Client
 In the web ui folder:
===
cd client
npm install
npm start
===
Then navigate to localhost:3000, if it isn't already opened for you.
** File Structure

   Our client is set up as so...
   #+NAME: Our Directory Structure
   #+BEGIN_SRC shell :dir ./client :results output verbatim drawer replace
  tree  -I 'node_modules' -d
   #+END_SRC

   #+RESULTS: Our Directory Structure
   :RESULTS:
   .
   ├── build
   │   └── static
   │       └── js
   ├── public
   └── src
       ├── actions
       ├── components
       ├── css
       ├── pages
       ├── reducers
       └── sagas

   11 directories
   :END:

   The core work is done in the src folder. Public holds our stylesheets and assets, and build holds everything when we set it up for production.

Within our Src, file:
- Actions manage calls to the app's state, requesting new data.
- Components are modular parts of our UI, like dropdown boxes and navbars and such.
- Pages are collections of components that display based on the route of the site and the actions of the user.  They are similar to html pages.
- reducers listens to actions and the payload of data they contain and reducer that data into a single state tree for the app.  This is the data being called upon in the components.
- Sagas are not being used yet.
** Setup
*** Creation
**** initial react app
     We are going to use the default app style (because we want this to be familiar to others), and luckily there's an npm module to create react apps for us to do just that!
     #+NAME: Create React App
     #+BEGIN_SRC sh :dir ./client :results output
       npx create-react-app client
     #+END_SRC
     #+RESULTS: Create React App
**** dependencies
     :PROPERTIES:
     :header-args: :noweb yes :dir ./client
     :END:
    We want to add some adaptors for react to use redux //and// feathers //and// tachyons
    #+NAME: install dependencies
    #+BEGIN_SRC shell :results output verbatim drawer
      npm install --save \
          @feathersjs/client \
          feathers-localstorage \
          feathers-redux \
          react-dom \
          react-redux \
          react-router \
          react-router-redux \
          react-router-dom \
          redux \
          redux-thunk \
          redux-devtools-extension \
          redux-saga \
          superagent \
          d3
    #+END_SRC

    #+RESULTS: install dependencies
    :RESULTS:
    + react-dom@16.5.2
    + react-router@4.3.1
    + feathers-localstorage@3.0.0
    + react-redux@5.0.7
    + redux@4.0.0
    + superagent@4.0.0-beta.5
    + redux-saga@0.16.0
    + react-router-redux@4.0.8
    + @feathersjs/client@3.7.3
    added 11 packages from 11 contributors, updated 5 packages and audited 14613 packages in 12.257s
    found 0 vulnerabilities

    :END:
**** file structure
     Within our client we want to manage our various components, the actions they can call upon, and the reducers that turn all these actions into a single state of the app. These dont' come with the basic react app, so we'll create them.
     We also want to delete any of the default react icons or CSS stuff and move our App.js into a component (cos that's what it is.
     #+BEGIN_SRC sh :results output
       cd src
       rm App.css index.css logo.svg
       mkdir components actions reducers sagas
       mv App.js components
       cd ..
       tree -I 'node_modules'
     #+END_SRC
     #+RESULTS:
     #+begin_example
     .
     ├── README.md
     ├── package-lock.json
     ├── package.json
     ├── public
     │   ├── favicon.ico
     │   ├── index.html
     │   └── manifest.json
     ├── src
     │   ├── App.test.js
     │   ├── actions
     │   ├── components
     │   │   └── App.js
     │   ├── index.js
     │   ├── reducers
     │   ├── registerServiceWorker.js
     │   └── sagas
     └── yarn.lock

     5 directories, 11 files
     #+end_example

*** Adding Tachyons
    We want to bring tachyons right into our app, installing it through node.  This way we have full access to the css library without relying on outside links and this library is as up-to-date as possible(or rather, v. easy to stay up to date.)  I am following the guide for react that tachyons listed[[https://github.com/tachyons-css/tachyons-and-react][ on their github page.]]
**** Install Tachyons and Sheetify
     I wont' be using sheetify right now, but the goal is to use it upon a refactor (when we've moved away from webpack to browseriy)
     #+NAME: Install Tachyons
     #+BEGIN_SRC shell :dir ./client :results output verbatim drawer
       npm install --save tachyons tachyons-cli sheetify
     #+END_SRC

     #+RESULTS: Install Tachyons
     :RESULTS:
     + tachyons-cli@1.3.2
     + tachyons@4.11.1
     + sheetify@7.3.3
     added 31 packages from 18 contributors, updated 2 packages, moved 3 packages and audited 20856 packages in 29.843s
     found 1 low severity vulnerability
       run `npm audit fix` to fix them, or `npm audit` for details
     :END:
**** Find Home for CSS
     #+NAME: Find Home for CSS
     #+BEGIN_SRC shell :dir ./client/src :results output verbatim drawer
       mkdir css
       echo '@import "tachyons"' > css/app.css
       tree css
     #+END_SRC

     #+RESULTS: Find Home for CSS
     :RESULTS:
     css
     └── app.css

     0 directories, 1 file
     :END:
**** Add CSS scripts
 I'll add a couple additions to our package.json (this is best outlined in the github link)
** index.js
   :PROPERTIES:
   :header-args: :noweb yes :tangle ./client/src/index.js
   :END:
   The entry point of the app.  This is what gets mounted to our index.html page, and then leads us into the rest of the frontend.  So we want to make a nice package to mount that has our redux store and our react app bundled up together.
*** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import React from 'react'
      import ReactDOM from 'react-dom'
      import { BrowserRouter } from 'react-router-dom'
      import './index.css'

      import {Provider} from 'react-redux'

      import App from './components/App'
      import store from './store.js'
      import registerServiceWorker from './lib/service-workers'

    #+END_SRC
*** index mounted to dom.
Here we define the wrapped up chunk of code that will be mounted to the 'root' id in our index.html page, and flower into the full app
#+NAME: main index.js
#+BEGIN_SRC js
  ReactDOM.render(
      <BrowserRouter>
      <Provider store={store}>
      <App />
      </Provider>
      </BrowserRouter>,
    document.getElementById('root')
  )
    registerServiceWorker()
#+END_SRC
** Our App(app.js)
   :PROPERTIES:
   :header-args: :noweb yes :tangle ./client/src/components/App.js
   :END:
***** Introduction
    The app component is often seen as the 'layout template' for the frontend.  Anything we want to be displayed at all times should go here (e.g. a header and navbar).  The app component will also handle the navigation between the different components, based on routes given.

    This is a 'single-page-app' which means: to the server, we are only showing a single html page, the index.html.  Within this page we have javascript code running that renders different views dynamically, based on what the site visitor wants to see.  We can give these views the format of a URL, so it appears like we are going to different pages within apisnoop (and so we can share specific urls to others), but it's all really a continually transforming bit of Javascript.
***** Requirements
 I'll dive a bit into the import/requirements section as it sets up a style you see in a lot of React apps.

 We'll start by bringing in React and its Component class-we inherit all the features of this class when we render our own components, which gives them all the power we may not see at first.
   #+NAME: Import React
   #+BEGIN_SRC js
     import React, { Component } from 'react'
   #+END_SRC

 Next, we'll bring in react's smart navigation.  These are what make the app appear to be multiple pages.
 #+NAME: import routing and navigation
 #+BEGIN_SRC js
   import { Route } from 'react-router-dom'
 #+END_SRC

 Lastly, we bring in our different pages, which we can navigate between using a nice lil' tab and navlinks..
 #+NAME: import components
 #+BEGIN_SRC js
   import Header from './header'
   import Footer from './footer'
   import MainPage from '../pages/main-page.js'
 #+END_SRC

 #+RESULTS: import components

***** The overall Layout
      The general shape of this template is here:
    #+NAME: App Layout
    #+BEGIN_SRC js
      class App extends Component {
        render(){
          return (
            <div id='app'>
              <Header />
              <<Routes>>
              <Footer />
            </div>
          )
        }
      }

      export default App
    #+END_SRC

***** the Navlinks

    the navlinks will be visual components that act like standard links;  and so ~exact to~ acts like href.

    #+NAME: Nav Links
    #+BEGIN_SRC js :tangle no
      <div id='nav'>
        <NavLink exact to='/'>Audits</NavLink>
      </div>
    #+END_SRC
***** the Routes
    The routes listen to the paths chosen by nav and routes to the correct component.  So the components don't show unless the url path matches their route.
    #+NAME: Routes
    #+BEGIN_SRC js :tangle no
        <Route exact path='/' component={MainPage} />
    #+END_SRC
** Pages
   We are following a convention where, if a component acts as its own route and holds many different components within it, then it's called a page.  Think of navigating between different pages in a site, and each one is made up of several diff. section.  It is the same here, just that we are navigating between JS dispalying different Page components.
*** MainPage
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/pages/main-page.js
    :END:
    This will hold all the names taken from conformance-gce dashboard_tab.name
      #+BEGIN_SRC js
        import React, { Component } from 'react'
        import { connect } from 'react-redux'

        import { fetchAudits } from '../actions/audits-actions'
        import { fetchStatistics } from '../actions/statistics-actions'
        import { fetchSunbursts } from '../actions/sunbursts-actions'
        import SunburstSegment from '../components/sunburst-segment'
        import BranchList from '../components/branch-list'

        class MainPage extends Component {
          componentDidMount() {
            this.props.fetchAudits()
            this.props.fetchStatistics()
            this.props.fetchSunbursts()
          }

          render(){
            return (
                <main id='main-splash' className='min-vh-100'>
                  {this.props.sunbursts.length !== 0 && <SunburstSegment version={this.props.sunbursts[0].name} sunburst={this.props.sunbursts[0]}/>}
                <div id='branch-statistics'>
                <BranchList statistics={this.props.statistics} />
                </div>
                  <h1>This Page Will Have</h1>
                  <h2>Number of Sunbursts: {this.props.sunbursts.length}</h2>
                  <ul>
                  <li>existing sunburst visualization</li>
                  <li>tag cloud as taken from our audits</li>
                  <li>information about sigs when a sig-tag is present.</li>
                  <li>A dropdown for the sunburst to filter by user-agent</li>
                  </ul>
                </main>
            )
          }
        }

        function mapStateToProps (state) {
          return {
            sunbursts: state.sunburstsStore.sunbursts,
            statistics: state.statisticsStore.statistics
          }
        }

        export default connect(mapStateToProps, {fetchAudits, fetchSunbursts, fetchStatistics})(MainPage)
      #+END_SRC
** Components
The various visual parts of the app.  For the most part, we want these to be as dumb as possible--they present the stuff they're given, and if they have to do any interactive stuff it remains contained to within itself.  Any other changes should be handled outside of the component through actionCreators our and reducer updating the global state of the app.  In other words, the components display the state as it is now, and they can trigger events which update the state, but they always simply display it as it is now.
*** Header
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/header.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <header className='flex flex-row pt2 pb2 pl4 pr4 items-center justify-between bg-light-gray black shadow-3'>
            <div id='logo' className= 'flex flex-wrap items-center'>
            <img className='h2' src='./apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
            <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
            </div>
            <div id='source-code' className='flex items-center'>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
              <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
            </div>
          </header>
      )
    #+END_SRC

    #+RESULTS: Header

*** Footer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/components/footer.js
    :END:
    The classic APISnoop header, rendered in short and sweet tachyons
    #+NAME: Header
    #+BEGIN_SRC js
      import React from 'react'

      export default () => (
          <footer className='flex flex-row pt2 pb2 pl4 pr4 items-center justify-between bg-black black shadow-3'>
            <div id='logo' className= 'flex flex-wrap items-center'>
            <img className='mw2' src='./apisnoop_logo_v1.png' alt='logo for apisnoop, a magnifying glass with a sunburst graph inside.' />
            <h1 className='ma0 f4 fw4 pl2 avenir'>APISnoop</h1>
            </div>
            <div id='source-code' className='flex items-center'>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
              <a href='https://github.com/cncf/apisnoop' title='github repo for apisnoop' className='link f7 pl1'>Source Code</a>
            </div>
          </footer>
      )
    #+END_SRC

    #+RESULTS: Header

*** Sunburst
**** Sunburst Segment
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/sunburst-segment.js
     :END:
     This is the section of the site dedicated to the sunburst, including any additional text we want to include or a nice header or anything like that.
     #+NAME: Sunburst Segment
     #+BEGIN_SRC js
       import React, { Component } from 'react'

       import SunburstChart from './sunburst-chart'

       class SunburstSegment extends Component {
         constructor (props) {
           super(props)
           this.state = {
             agentFilter: 'e2e',
             filteredSunburst: {}
           }
           this.filterByAgent = this.filterByAgent.bind(this)
         }

         componentdidMount(){
           var sunburst = this.props.sunburst.data.tree
           var agent = this.state.agentFilter
           sunburst = this.filterByAgent(sunburst, agent)
         }

         filterByAgent (obj, agent) {
           return agents.includes('e2e')
           if (obj.children) {
             for (child in obj.children) {
               if (child.children) {
                 for
               }
             }
             filterByAgent(obj, agent)
           }
           return obj
         }

       render() {
         return (
             <div id='sunburst-segment' className='bg_washed-red pa4'>
             <h2>{this.props.version} Sunburst Graph</h2>
             // <SunburstChart sunburst={this.props.sunburst}/>
           </div>
         )
       }

       }

       export default SunburstSegment
     #+END_SRC

     #+RESULTS: Sunburst Segment
**** SunburstChart
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/sunburst-chart.js
     :END:
***** Introduction
     We will be using react-vis' basic sunburst example as our guide for this, as it is the closest to what we want.  Our goal is to add in zoom animation and percentages in the center area, but for now let's just get this loading.

    Use code layout to see how it all fits, then check out each thing in specifics in the headers below.
***** Import Modules
      The example uses extended discrete color range and label series, and both are referencing something with the files themselves.  I believe that we can just use labelseries since we are bringing in sunburst from react-vis, and the theme was just to help make the fill, which we can use with other colors instead.

     We'll bring in the flareData and Sample Data to try switching between the two.
      #+NAME: Import Modules
      #+BEGIN_SRC js :tangle no
        import React, { Component } from 'react';
        import { connect } from 'react-redux'
        import { Sunburst, LabelSeries } from 'react-vis'
      #+END_SRC
***** Code Layout
      #+NAME: Code Layout
      #+BEGIN_SRC js
        <<License>>
        <<Import Modules>>

        <<Set Styling for Label>>
        // Mapping of step names to colors.
        var colors = {
          'level.alpha': '#e6194b',
          'level.beta': '#0082c8',
          'level.stable': '#3cb44b',
          'category.unused': '#ffffff'
        }

        var categories = [
          "admissionregistration",
          "apiextensions",
          "apiregistration",
          "apis",
          "apps",
          "authentication",
          "authorization",
          "autoscaling",
          "batch",
          "certificates",
          "core",
          "events",
          "extensions",
          "logs",
          "networking",
          "policy",
          "rbacAuthorization",
          "scheduling",
          "settings",
          "storage",
          "version"
        ]

        var more_colors = [
          "#b71c1c", "#880E4F", "#4A148C", "#311B92", "#1A237E", "#0D47A1",
          "#01579B", "#006064", "#004D40", "#1B5E20", "#33691E", "#827717",
          "#F57F17", "#FF6F00", "#E65100", "#BF360C", "#f44336", "#E91E63",
          "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4",
          "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107",
          "#FF9800", "#FF5722"
        ]

        for (var catidx = 0; catidx < categories.length; catidx++) {
          var category = categories[catidx]
          colors['category.' + category] = more_colors[(catidx * 3) % more_colors.length]
        }

        class BasicSunburst extends Component {
            <<SB Setup Constructor>>
            <<SB Define componentDidMount>>
            <<Define getKeyPath>>
            <<Define updateData>>
            render() {
              const {clicked, data, finalValue, pathValue} = this.state
              const updateData = this.updateData
              const decoratedData = this.decoratedData
              const getKeyPath = this.getKeyPath
              return (
                  <div className='basic-sunburst-wrapper'>
                  <<SB Click/Unclick Indicator>>
                  <Sunburst
                animation
                className='basic-sunburst-example'
                hideRootNode
                  <<SB onValueMouseOver>>
                  <<SB onValueMouseOut>>
                  onValueClick={()=> this.setState({clicked: !clicked})}
                style={{
                  stroke: '#ddd',
                  strokeOpacity: 0.3,
                  strokeWidth: '0.5'
                }}
                colorType="literal" // a style for react-vis. literal means 'literally the color palette given'
                getSize={d => d.size + 1} // d refers to data, will need to be set differently for audit log
                getColor={d => colors[d.color]}  // same
                data={data} // Make sure you're actually providing data to the chart!
                height={900}
                width={1000}
                  >
                  <<SB Display Center finalValue>>
                  </Sunburst>
                  <div className='basic-sunburst-example-path-name'>{pathValue}</div>
                  </div>
              )
            }
        }

        function mapStateToProps (state) {
          return {
            flareData: state.D3FlareStore.data
          }
        }

        export default connect(mapStateToProps)(BasicSunburst)
      #+END_SRC

      #+RESULTS: Code Layout

***** License
      #+NAME: License
      #+BEGIN_SRC js :tangle no
        // Copyright (c) 2016 - 2017 Uber Technologies, Inc.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a copy
        // of this software and associated documentation files (the "Software"), to deal
        // in the Software without restriction, including without limitation the rights
        // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        // copies of the Software, and to permit persons to whom the Software is
        // furnished to do so, subject to the following conditions:
        //
        // The above copyright notice and this permission notice shall be included in
        // all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        // THE SOFTWARE.
      #+END_SRC
***** Set Styling For Label
      This will be used for our LabelSeries later, defining how it should look.
      #+NAME: Set Styling for Label
      #+BEGIN_SRC js :tangle no
        const LABEL_STYLE = {
          fontSize: '20px',
          textAnchor: 'middle'
        }
      #+END_SRC
      It's written in the JSX style, so it's equal to a div having a 'style='font-size: 8px;', but in reactLand you can't just have the equal things be equal...we gotta do this camelCase stuff.
***** Setup Constructor
      #+NAME: SB Setup Constructor
      #+BEGIN_SRC js :tangle no
        constructor(props) {
          super(props)
          this.state = {
            pathValue: false,
            data: {},
            finalValue: 'SUNBURST',
            clicked: false
          }
          this.decoratedData = {}
          this.updateData = this.updateData.bind(this)
          this.getKeyPath = this.getKeyPath.bind(this)
        }


      #+END_SRC

      The constructor sets up the component-specific state; which helps us contain all the function and data within the component  itself.  So we set up the state for the component with the following values:
- pathValue :: When you hover over a node, shows the path you took to get to that node.  Will end up being the array created by getKeyPath joined together into a string.
- data :: the data given to us by our store.  Right now it is flareData, but it will one day be a specific build.
- finalValue :: the name of the node you are on, essentially.  For the path it took through the url's to get to this node.  So this could be our literal endpoints.
- clicked :: true/false on whether we've clicked to lock our current node path.

We have to do some kinda verbose binding of our functions.  The point of this is so we can have this function show multiple times throughout the page and not have the results leak out into other components, it prevents bugs and strange behavior, essentially.
***** Define componentDidMount
      #+NAME: SB Define componentDidMount
      #+BEGIN_SRC js :tangle no
        componentDidMount() {
          var sunburst = this.props.sunburst
          if (Object.keys(sunburst).length !== 0) {
            sunburst = sunburst.data.tree
            this.decoratedData = this.updateData(sunburst, false)
            this.setState({data: this.decoratedData})
          }
        }
      #+END_SRC

      We don't want to hard-code the state of our component based on props, because then if the props change, the component itself doesn't.  Instead, we mount it on the page, and then update the state based on the props given.  This ensures that the component will always appear properly.  So here we are saying, "When the graph appears, take the props given to us by our state (the flareData) and decorate it.  Then, set the data in our state to this new decorated data.  The sunburst component renders whatever is in this.state.data, and so it will render now the json from our store.

      This is a common pattern with react components.  Let the initial state be a fairly solid thing, that then gets set again by actions after its already been mounted.

***** Define getKeyPath
      #+NAME: Define getKeyPath
      #+BEGIN_SRC js :tangle no
        /**
         ,* Recursively work backwards from highlighted node to find path of valid nodes
         ,* @param {Object} node - the current node being considered
         ,* @returns {Array} - an array of strings describing the key route to teh current node.
         ,*/

        getKeyPath (node) {
          console.log({node})
          if (!node.parent) {
            return ['root']
          }

          return [(node.data && node.data.name) || node.name].concat(
            this.getKeyPath(node.parent)
          )
        }
      #+END_SRC

      This tree map is tracing the path of nodes through the JSON tree, like tracing the url path of a singular webpage within a website.  This is the function that defines this path.

      IT does so recursively.  For each node it asks, 'do you have a parent?' if it doesn't we know it's root and we'll return 'root.'   If it does, we will return the node's name and its' data (or just its name if no data is available).  Then, we'll [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat][concatenate]]  this array to whatever array is returned when we apply the same function to this node's parent.  So we'll end up with an array of strings, where each one is chained as a parent to the one before.

      This is explained well in the code example too, so we keeping it.
***** Define updateData
     #+NAME: Define updateData
      #+BEGIN_SRC js :tangle no
       updateData (data, keyPath) {
         if (Object.keys(data).length !== 0) {
           if (data.children) {
             data.children.map(child => this.updateData(child,  keyPath))
           }
           // add a fill to all the uncolored cells
           if (!data.color) {
             data.style = { fill: 'lightgray' }
           }
           data.style = {
             ...data.style,
             fillOpacity: keyPath && !keyPath[data.name] ? 0.2 : 1
             // if there's a keypath AND that keypath has a data.name, then 0.2
           }

           return data
         }
       }
      #+END_SRC

       This takes care of when the graph is first loaded, and upon mouse hover events.  It essentially adds a fill color to each node if it's part of the path we current have our mouse on.
    It's another recursive one, applying the fill at the very bottom and moving up.
 from the sites definition:
    Recursivey modify data depending on whetehr or not each cell has been selected by the hover/hlighlight
    @param {Object} data - the current node being considered
    @param {Object|Boolean} keyPath - a map of keys that are in the highlight path
       //if this is false then all nodes are marked as selected.//
    @returns {Object} Updated tree structure

***** Click/Unclick Indicator
      #+NAME: SB Click/Unclick Indicator
      #+BEGIN_SRC js :tangle no
          <div>
          {clicked ? 'click to unlock selection' : 'click to lock selection'}
        </div>
      #+END_SRC

      This checks the component's state, if click is true, then let them know you can unlock selection.  otherwise, let them know they can click to lock.

***** onValueMouseOver
      #+NAME: SB onValueMouseOver
      #+BEGIN_SRC js :tangle no
        onValueMouseOver={(node, dom) => {
          if (clicked) {
            return
          }
          console.log({hoverNode: node, dom})
          const path = getKeyPath(node).reverse()
          const pathAsMap = path.reduce((res, row) => {
            res[row] = true
            return res
          }, {})
          this.setState({
            finalValue: `tested: ${node.tested}`,
            pathValue: path.join(' > '),
            data: updateData(decoratedData, pathAsMap)
          })
        }}
      #+END_SRC

      This is a value that is part of the react-vis api.  From that doc, this is a function that accepts (arc node, domEvent) as arguments.  In other words, we'll know the exact node upon which the mouse is over, and all the values given from our browser about that node element.

      We know that getKeyPath returns an array of strings, each subsequent one being the parent of the node string prior.  So here we set the path to being that array reversed, so it goes from root to smallest child.

      pathAsMap, to be honest, I don't fully understand.  It's used to decorate the data, and the data colors up a cell based on each section of the map being true or false.  So It hink it's saying "if this cell is in the path, mark it as true, otherwise it be false".

      Then, we set the state with these values.  finalValue is going to be the last node string in our path and pathValue is going to be the full path outlined like so: 'root > child1 > child2 > lastChild'

      Everytime you set the state with a react Component the whole component rerenders.  We will have things later down that are meant to display the pathVAlue and finalValue...so since we are setting them in the state and rendering the component again it's going to continually update what these show.

***** onValueMouseOut
 #+NAME: SB onValueMouseOut
 #+BEGIN_SRC js :tangle no
   onValueMouseOut={()=>
       clicked
       ? () => {} // an empty function, essentially 'do nothing'
       : this.setState({
         pathValue: false,
         finalValue: false,
         data: updateData(decoratedData, false)
       })
     }
 #+END_SRC

 This is like onValueMouseOver, but handling when we leave the chart.  Clicking locks the arc's position--and so, if it's clicked we do nothing...we keep all the coloring and info as it is as it's locked in place.

 If clicked isn't set, and we've left the chart, then return everything back to nothing.  No finalVAlue, no path that we're on, and update the data so all cells are colored again.

***** Display Center finalValue
      #+NAME: SB Display Center finalValue
      #+BEGIN_SRC js :tangle no
        {finalValue && (
            <LabelSeries
          data={[{x: 0, y: 0, label: finalValue, style: LABEL_STYLE}]}
            />
        )}
      #+END_SRC

      LabelSeries is another component given to us by react-vis.  The data will want to know where the label will be placed, what it should be labelling, and what it should look like.  We are saying 'put it right in the center: x0/y0 and display the final node we are highlighting.'

**** Example Data for Sunburst
***** Basic Sample Data
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/sample-data/sampleData.json
     :END:
     #+NAME: Example Data
     #+BEGIN_SRC js
        {
         "title": "analytics",
         "color": "#12939A",
         "children": [
           {
             "title": "cluster",
             "children": [
               {"title": "AgglomerativeCluster", "color": "#12939A", "size": 3938},
               {"title": "CommunityStructure", "color": "#12939A", "size": 3812},
               {"title": "HierarchicalCluster", "color": "#12939A", "size": 6714},
               {"title": "MergeEdge", "color": "#12939A", "size": 743}
             ]
           },
           {
             "title": "graph",
             "children": [
               {"title": "BetweennessCentrality", "color": "#12939A", "size": 3534},
               {"title": "LinkDistance", "color": "#12939A", "size": 5731},
               {"title": "MaxFlowMinCut", "color": "#12939A", "size": 7840},
               {"title": "ShortestPaths", "color": "#12939A", "size": 5914},
               {"title": "SpanningTree", "color": "#12939A", "size": 3416}
             ]
           },
           {
             "title": "optimization",
             "children": [
               {"title": "AspectRatioBanker", "color": "#12939A", "size": 7074}
             ]
           }
         ]
       }
     #+END_SRC
***** D3 Flare Data Visualization
      :PROPERTIES:
      :header-args: :noweb yes :tangle ./client/src/sample-data/flareData.json
      :END:
      so I can make sure our chart look's like react-vis'
      #+NAME: flareData
      #+BEGIN_SRC js
        {
          "children": [
            {
              "name": "analytics",
              "hex": "#12939A",
              "children": [
                {
                  "name": "cluster",
                  "children": [
                    {"name": "AgglomerativeCluster", "hex": "#12939A", "value": 3938},
                    {"name": "CommunityStructure", "hex": "#12939A", "value": 3812},
                    {"name": "HierarchicalCluster", "hex": "#12939A", "value": 6714},
                    {"name": "MergeEdge", "hex": "#12939A", "value": 743}
                  ]
                },
                {
                  "name": "graph",
                  "children": [
                    {"name": "BetweennessCentrality", "hex": "#12939A", "value": 3534},
                    {"name": "LinkDistance", "hex": "#12939A", "value": 5731},
                    {"name": "MaxFlowMinCut", "hex": "#12939A", "value": 7840},
                    {"name": "ShortestPaths", "hex": "#12939A", "value": 5914},
                    {"name": "SpanningTree", "hex": "#12939A", "value": 3416}
                  ]
                },
                {
                  "name": "optimization",
                  "children": [
                    {"name": "AspectRatioBanker", "hex": "#12939A", "value": 7074}
                  ]
                }
              ]
            },
            {
              "name": "animate",
              "children": [
                {"name": "Easing", "hex": "#12939A", "value": 17010},
                {"name": "FunctionSequence", "hex": "#12939A", "value": 5842},
                {
                  "name": "interpolate",
                  "children": [
                    {"name": "ArrayInterpolator", "hex": "#12939A", "value": 1983},
                    {"name": "hexInterpolator", "hex": "#12939A", "value": 2047},
                    {"name": "DateInterpolator", "hex": "#12939A", "value": 1375},
                    {"name": "Interpolator", "hex": "#12939A", "value": 8746},
                    {"name": "MatrixInterpolator", "hex": "#12939A", "value": 2202},
                    {"name": "NumberInterpolator", "hex": "#12939A", "value": 1382},
                    {"name": "ObjectInterpolator", "hex": "#12939A", "value": 1629},
                    {"name": "PointInterpolator", "hex": "#12939A", "value": 1675},
                    {"name": "RectangleInterpolator", "hex": "#12939A", "value": 2042}
                  ]
                },
                {"name": "ISchedulable", "hex": "#12939A", "value": 1041},
                {"name": "Parallel", "hex": "#12939A", "value": 5176},
                {"name": "Pause", "hex": "#12939A", "value": 449},
                {"name": "Scheduler", "hex": "#12939A", "value": 5593},
                {"name": "Sequence", "hex": "#12939A", "value": 5534},
                {"name": "Transition", "hex": "#12939A", "value": 9201},
                {"name": "Transitioner", "hex": "#12939A", "value": 19975},
                {"name": "TransitionEvent", "hex": "#12939A", "value": 1116},
                {"name": "Neonate", "hex": "#12939A", "value": 6006}
              ]
            },
            {
              "name": "data",
              "children": [
                {
                  "name": "converters",
                  "children": [
                    {"name": "Converters", "hex": "#12939A", "value": 721},
                    {"name": "DelimitedTextConverter", "hex": "#12939A", "value": 4294},
                    {"name": "GraphMLConverter", "hex": "#12939A", "value": 9800},
                    {"name": "IDataConverter", "hex": "#12939A", "value": 1314},
                    {"name": "JSONConverter", "hex": "#12939A", "value": 2220}
                  ]
                },
                {"name": "DataField", "hex": "#12939A", "value": 1759},
                {"name": "DataSchema", "hex": "#12939A", "value": 2165},
                {"name": "DataSet", "hex": "#12939A", "value": 586},
                {"name": "DataSource", "hex": "#12939A", "value": 3331},
                {"name": "DataTable", "hex": "#12939A", "value": 772},
                {"name": "DataUtil", "hex": "#12939A", "value": 3322}
              ]
            },
            {
              "name": "display",
              "children": [
                {"name": "DirtySprite", "hex": "#12939A", "value": 8833},
                {"name": "LineSprite", "hex": "#12939A", "value": 1732},
                {"name": "RectSprite", "hex": "#12939A", "value": 3623},
                {"name": "TextSprite", "hex": "#12939A", "value": 10066}
              ]
            },
            {
              "name": "flex",
              "children": [
                {"name": "FlareVis", "hex": "#12939A", "value": 4116}
              ]
            },
            {
              "name": "physics",
              "children": [
                {"name": "DragForce", "hex": "#12939A", "value": 1082},
                {"name": "GravityForce", "hex": "#12939A", "value": 1336},
                {"name": "IForce", "hex": "#12939A", "value": 319},
                {"name": "NBodyForce", "hex": "#12939A", "value": 10498},
                {"name": "Particle", "hex": "#12939A", "value": 2822},
                {"name": "Simulation", "hex": "#12939A", "value": 9983},
                {"name": "Spring", "hex": "#12939A", "value": 2213},
                {"name": "SpringForce", "hex": "#12939A", "value": 1681}
              ]
            },
            {
              "name": "query",
              "children": [
                {"name": "AggregateExpression", "hex": "#12939A", "value": 1616},
                {"name": "And", "hex": "#12939A", "value": 1027},
                {"name": "Arithmetic", "hex": "#12939A", "value": 3891},
                {"name": "Average", "hex": "#12939A", "value": 891},
                {"name": "BinaryExpression", "hex": "#12939A", "value": 2893},
                {"name": "Comparison", "hex": "#12939A", "value": 5103},
                {"name": "CompositeExpression", "hex": "#12939A", "value": 3677},
                {"name": "Count", "hex": "#12939A", "value": 781},
                {"name": "DateUtil", "hex": "#12939A", "value": 4141},
                {"name": "Distinct", "hex": "#12939A", "value": 933},
                {"name": "Expression", "hex": "#12939A", "value": 5130},
                {"name": "ExpressionIterator", "hex": "#12939A", "value": 3617},
                {"name": "Fn", "hex": "#12939A", "value": 3240},
                {"name": "If", "hex": "#12939A", "value": 2732},
                {"name": "IsA", "hex": "#12939A", "value": 2039},
                {"name": "Literal", "hex": "#12939A", "value": 1214},
                {"name": "Match", "hex": "#12939A", "value": 3748},
                {"name": "Maximum", "hex": "#12939A", "value": 843},
                {
                  "name": "methods",
                  "children": [
                    {"name": "add", "hex": "#12939A", "value": 593},
                    {"name": "and", "hex": "#12939A", "value": 330},
                    {"name": "average", "hex": "#12939A", "value": 287},
                    {"name": "count", "hex": "#12939A", "value": 277},
                    {"name": "distinct", "hex": "#12939A", "value": 292},
                    {"name": "div", "hex": "#12939A", "value": 595},
                    {"name": "eq", "hex": "#12939A", "value": 594},
                    {"name": "fn", "hex": "#12939A", "value": 460},
                    {"name": "gt", "hex": "#12939A", "value": 603},
                    {"name": "gte", "hex": "#12939A", "value": 625},
                    {"name": "iff", "hex": "#12939A", "value": 748},
                    {"name": "isa", "hex": "#12939A", "value": 461},
                    {"name": "lt", "hex": "#12939A", "value": 597},
                    {"name": "lte", "hex": "#12939A", "value": 619},
                    {"name": "max", "hex": "#12939A", "value": 283},
                    {"name": "min", "hex": "#12939A", "value": 283},
                    {"name": "mod", "hex": "#12939A", "value": 591},
                    {"name": "mul", "hex": "#12939A", "value": 603},
                    {"name": "neq", "hex": "#12939A", "value": 599},
                    {"name": "not", "hex": "#12939A", "value": 386},
                    {"name": "or", "hex": "#12939A", "value": 323},
                    {"name": "orderby", "hex": "#12939A", "value": 307},
                    {"name": "range", "hex": "#12939A", "value": 772},
                    {"name": "select", "hex": "#12939A", "value": 296},
                    {"name": "stddev", "hex": "#12939A", "value": 363},
                    {"name": "sub", "hex": "#12939A", "value": 600},
                    {"name": "sum", "hex": "#12939A", "value": 280},
                    {"name": "update", "hex": "#12939A", "value": 307},
                    {"name": "variance", "hex": "#12939A", "value": 335},
                    {"name": "where", "hex": "#12939A", "value": 299},
                    {"name": "xor", "hex": "#12939A", "value": 354},
                    {"name": "_", "hex": "#12939A", "value": 264}
                  ]
                },
                {"name": "Minimum", "hex": "#12939A", "value": 843},
                {"name": "Not", "hex": "#12939A", "value": 1554},
                {"name": "Or", "hex": "#12939A", "value": 970},
                {"name": "Query", "hex": "#12939A", "value": 13896},
                {"name": "Range", "hex": "#12939A", "value": 1594},
                {"name": "StringUtil", "hex": "#12939A", "value": 4130},
                {"name": "Sum", "hex": "#12939A", "value": 791},
                {"name": "Variable", "hex": "#12939A", "value": 1124},
                {"name": "Variance", "hex": "#12939A", "value": 1876},
                {"name": "Xor", "hex": "#12939A", "value": 1101}
              ]
            },
            {
              "name": "scale",
              "children": [
                {"name": "IScaleMap", "hex": "#FF9833", "value": 2105},
                {"name": "LinearScale", "hex": "#FF9833", "value": 1316},
                {"name": "LogScale", "hex": "#FF9833", "value": 3151},
                {"name": "OrdinalScale", "hex": "#FF9833", "value": 3770},
                {"name": "QuantileScale", "hex": "#1A3177", "value": 2435},
                {"name": "QuantitativeScale", "hex": "#FF9833", "value": 4839},
                {"name": "RootScale", "hex": "#FF9833", "value": 1756},
                {"name": "Scale", "hex": "#FF9833", "value": 4268},
                {"name": "ScaleType", "hex": "#FF9833", "value": 1821},
                {"name": "TimeScale", "hex": "#FF9833", "value": 5833}
              ]
            },
            {
              "name": "util",
              "children": [
                {"name": "Arrays", "hex": "#12939A", "value": 8258},
                {"name": "hexs", "hex": "#12939A", "value": 10001},
                {"name": "Dates", "hex": "#12939A", "value": 8217},
                {"name": "Displays", "hex": "#12939A", "value": 12555},
                {"name": "Filter", "hex": "#12939A", "value": 2324},
                {"name": "Geometry", "hex": "#12939A", "value": 10993},
                {
                  "name": "heap",
                  "children": [
                    {"name": "FibonacciHeap", "hex": "#12939A", "value": 9354},
                    {"name": "HeapNode", "hex": "#12939A", "value": 1233}
                  ]
                },
                {"name": "IEvaluable", "hex": "#12939A", "value": 335},
                {"name": "IPredicate", "hex": "#12939A", "value": 383},
                {"name": "IValueProxy", "hex": "#12939A", "value": 874},
                {
                  "name": "math",
                  "children": [
                    {"name": "DenseMatrix", "hex": "#12939A", "value": 3165},
                    {"name": "IMatrix", "hex": "#12939A", "value": 2815},
                    {"name": "SparseMatrix", "hex": "#12939A", "value": 3366}
                  ]
                },
                {"name": "Maths", "hex": "#12939A", "value": 17705},
                {"name": "Orientation", "hex": "#12939A", "value": 1486},
                {
                  "name": "palette",
                  "children": [
                    {"name": "hexPalette", "hex": "#12939A", "value": 6367},
                    {"name": "Palette", "hex": "#12939A", "value": 1229},
                    {"name": "ShapePalette", "hex": "#12939A", "value": 2059},
                    {"name": "valuePalette", "hex": "#12939A", "value": 2291}
                  ]
                },
                {"name": "Property", "hex": "#12939A", "value": 5559},
                {"name": "Shapes", "hex": "#12939A", "value": 19118},
                {"name": "Sort", "hex": "#12939A", "value": 6887},
                {"name": "Stats", "hex": "#12939A", "value": 6557},
                {"name": "Strings", "hex": "#12939A", "value": 22026}
              ]
            },
            {
              "name": "vis",
              "children": [
                {
                  "name": "axis",
                  "children": [
                    {"name": "Axes", "hex": "#12939A", "value": 1302},
                    {"name": "Axis", "hex": "#12939A", "value": 24593},
                    {"name": "AxisGridLine", "hex": "#12939A", "value": 652},
                    {"name": "AxisLabel", "hex": "#12939A", "value": 636},
                    {"name": "CartesianAxes", "hex": "#12939A", "value": 6703}
                  ]
                },
                {
                  "name": "controls",
                  "children": [
                    {"name": "AnchorControl", "hex": "#12939A", "value": 2138},
                    {"name": "ClickControl", "hex": "#12939A", "value": 3824},
                    {"name": "Control", "hex": "#12939A", "value": 1353},
                    {"name": "ControlList", "hex": "#12939A", "value": 4665},
                    {"name": "DragControl", "hex": "#12939A", "value": 2649},
                    {"name": "ExpandControl", "hex": "#12939A", "value": 2832},
                    {"name": "HoverControl", "hex": "#12939A", "value": 4896},
                    {"name": "IControl", "hex": "#12939A", "value": 763},
                    {"name": "PanZoomControl", "hex": "#12939A", "value": 5222},
                    {"name": "SelectionControl", "hex": "#12939A", "value": 7862},
                    {"name": "TooltipControl", "hex": "#12939A", "value": 8435}
                  ]
                },
                {
                  "name": "data",
                  "children": [
                    {"name": "Data", "hex": "#12939A", "value": 20544},
                    {"name": "DataList", "hex": "#12939A", "value": 19788},
                    {"name": "DataSprite", "hex": "#12939A", "value": 10349},
                    {"name": "EdgeSprite", "hex": "#12939A", "value": 3301},
                    {"name": "NodeSprite", "hex": "#12939A", "value": 19382},
                    {
                      "name": "render",
                      "children": [
                        {"name": "ArrowType", "hex": "#12939A", "value": 698},
                        {"name": "EdgeRenderer", "hex": "#12939A", "value": 5569},
                        {"name": "IRenderer", "hex": "#12939A", "value": 353},
                        {"name": "ShapeRenderer", "hex": "#12939A", "value": 2247}
                      ]
                    },
                    {"name": "ScaleBinding", "hex": "#12939A", "value": 11275},
                    {"name": "Tree", "hex": "#12939A", "value": 7147},
                    {"name": "TreeBuilder", "hex": "#12939A", "value": 9930}
                  ]
                },
                {
                  "name": "events",
                  "children": [
                    {"name": "DataEvent", "hex": "#12939A", "value": 2313},
                    {"name": "SelectionEvent", "hex": "#12939A", "value": 1880},
                    {"name": "TooltipEvent", "hex": "#12939A", "value": 1701},
                    {"name": "VisualizationEvent", "hex": "#12939A", "value": 1117}
                  ]
                },
                {
                  "name": "legend",
                  "children": [
                    {"name": "Legend", "hex": "#12939A", "value": 20859},
                    {"name": "LegendItem", "hex": "#12939A", "value": 4614},
                    {"name": "LegendRange", "hex": "#12939A", "value": 10530}
                  ]
                },
                {
                  "name": "operator",
                  "children": [
                    {
                      "name": "distortion",
                      "children": [
                        {"name": "BifocalDistortion", "hex": "#12939A", "value": 4461},
                        {"name": "Distortion", "hex": "#12939A", "value": 6314},
                        {"name": "FisheyeDistortion", "hex": "#12939A", "value": 3444}
                      ]
                    },
                    {
                      "name": "encoder",
                      "children": [
                        {"name": "hexEncoder", "hex": "#12939A", "value": 3179},
                        {"name": "Encoder", "hex": "#12939A", "value": 4060},
                        {"name": "PropertyEncoder", "hex": "#12939A", "value": 4138},
                        {"name": "ShapeEncoder", "hex": "#12939A", "value": 1690},
                        {"name": "valueEncoder", "hex": "#12939A", "value": 1830}
                      ]
                    },
                    {
                      "name": "filter",
                      "children": [
                        {"name": "FisheyeTreeFilter", "hex": "#12939A", "value": 5219},
                        {"name": "GraphDistanceFilter", "hex": "#12939A", "value": 3165},
                        {"name": "VisibilityFilter", "hex": "#12939A", "value": 3509}
                      ]
                    },
                    {"name": "IOperator", "hex": "#12939A", "value": 1286},
                    {
                      "name": "label",
                      "children": [
                        {"name": "Labeler", "hex": "#12939A", "value": 9956},
                        {"name": "RadialLabeler", "hex": "#12939A", "value": 3899},
                        {"name": "StackedAreaLabeler", "hex": "#12939A", "value": 3202}
                      ]
                    },
                    {
                      "name": "layout",
                      "children": [
                        {"name": "AxisLayout", "hex": "#12939A", "value": 6725},
                        {"name": "BundledEdgeRouter", "hex": "#12939A", "value": 3727},
                        {"name": "CircleLayout", "hex": "#12939A", "value": 9317},
                        {"name": "CirclePackingLayout", "hex": "#12939A", "value": 12003},
                        {"name": "DendrogramLayout", "hex": "#12939A", "value": 4853},
                        {"name": "ForceDirectedLayout", "hex": "#12939A", "value": 8411},
                        {"name": "IcicleTreeLayout", "hex": "#12939A", "value": 4864},
                        {"name": "IndentedTreeLayout", "hex": "#12939A", "value": 3174},
                        {"name": "Layout", "hex": "#12939A", "value": 7881},
                        {"name": "NodeLinkTreeLayout", "hex": "#12939A", "value": 12870},
                        {"name": "PieLayout", "hex": "#12939A", "value": 2728},
                        {"name": "RadialTreeLayout", "hex": "#12939A", "value": 12348},
                        {"name": "RandomLayout", "hex": "#12939A", "value": 870},
                        {"name": "StackedAreaLayout", "hex": "#12939A", "value": 9121},
                        {"name": "TreeMapLayout", "hex": "#12939A", "value": 9191}
                      ]
                    },
                    {"name": "Operator", "hex": "#12939A", "value": 2490},
                    {"name": "OperatorList", "hex": "#12939A", "value": 5248},
                    {"name": "OperatorSequence", "hex": "#12939A", "value": 4190},
                    {"name": "OperatorSwitch", "hex": "#12939A", "value": 2581},
                    {"name": "SortOperator", "hex": "#12939A", "value": 2023}
                  ]
                },
                {"name": "Visualization", "hex": "#12939A", "value": 16540}
              ]
            }
          ]
        }
      #+END_SRC
*** Branch Statistics
**** Introduction
     This is pulling from our statistics service, showing top-level things like # of endpoints hit and how many there are in total, and maybe a basic percentage.  In the future, it'd be cool to have each one be clickable and lead to that particular branch.
**** Branch List
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/branch-list.js
     :END:
     #+NAME: Branch List
     #+BEGIN_SRC js
       import React from 'react'

       import BranchCard from './branch-card'

       export default function BranchList ({statistics}) {
         var sortedStats = statistics.sort((a,b) => {
           return a - b
         })
         console.log(sortedStats)

         const list = () => {
           return statistics.map(statistic => {
             return(
                 <BranchCard key={statistic._id} statistic={statistic}/>
             )
           })
         }

         return(
           <div>
             <ul className='list'>
             { list() }
             </ul>
           </div>
         )
       }

     #+END_SRC
**** Branch Card
     :PROPERTIES:
     :header-args: :noweb yes :tangle ./client/src/components/branch-card.js
     :END:
     #+NAME: Branch Card
     #+BEGIN_SRC js
       import React from 'react'

       export default function BranchCard({statistic}) {
         console.log({statistic})
         var stat = statistic.data
         var version = (name, version) => {
           return (
             <div>
               <h3>{name}</h3>
               <p className="f6 f5-ns lh-copy measure mv0">
               {percentage(version.total, version.hit)} endpoints hit
             </p>
               <p className="f6 f5-ns lh-copy measure mv0">
               {version.total} Total
             </p>
               <p className="f6 f5-ns lh-copy measure mv0">
               {version.hit} Hit
             </p>
               </div>
           )
         }


         return(
             <li className="center mw5 mw6-ns hidden ba mv4">
             <h2 className="f4 bg-near-black white mv0 pv2 ph3">{statistic.name}</h2>
             <div className="pa3 bt">
             {version('Alpha', stat.alpha)}
             {version('Beta', stat.beta)}
             {version('Stable', stat.stable)}
             </div>
             </li>
         )
         function percentage (total, hit) {
           return ((hit / total) * 100).toFixed(2) + '%'
         }
       }

     #+END_SRC
** Lib
*** Utilities
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/lib/utils.js
    :END:
    This is just holding our buildJsonHierarchy utility for right now, but could potentially expand as needed.
    #+Utils
    #+BEGIN_SRC js
      export function formatForSunburst (audit) {
        console.log({audit})
          var json = buildHierarchy(audit.data)
          return json
        }


      function buildHierarchy(csv) {
        var root = createNode('root')
        var parentNode;
        var levelNode;
        var categoryNode;
        for (var i = 0; i < csv.length; i++) {
          var level = csv[i]['level']
          var category = csv[i]['category']
          var method_url = csv[i]['method + url']
          var size = +csv[i]['count'];
          if (isNaN(size)) { // e.g. if this is a header row
            continue;
          }

          var node = findChild(root, level)
          if (node == null) {
            node = createNode(level, {
              'color': 'level.' + level
            })
            root['children'].push(node)
          }
          parentNode = levelNode = node

          node = findChild(parentNode, category)
          if (node == null) {
            node = createNode(category,  {
              'color': 'category.' + category
            })
            parentNode['children'].push(node)
          }
          parentNode = categoryNode = node

          node = findChild(parentNode, method_url)
          if (node == null) {
            if (method_url === 'unused') {
              method_url = 'untested'
              var attrs = {'color': 'category.unused'}
              categoryNode.untested += size
              levelNode.untested += size
              root.untested += size
            } else {
              attrs = {'color': 'category.' + category}
              categoryNode.tested += size
              levelNode.tested += size
              root.tested += size
            }
            categoryNode.total += size
            levelNode.total += size
            root.total += size
            attrs.url = method_url
            node = createEndNode(method_url, attrs)
            parentNode['children'].push(node)
          }
          node['size'] = size
        }
        return root;
      }

      function findChild(parentNode, nodeName) {
        var children = parentNode.children;
        for (var k = 0; k < children.length; k++) {
          if (children[k]["name"] === nodeName) {
            return children[k];
          }
        }
        return null
      }

      function createNode(name, attrs) {
        var node = {
          "name": name,
          "children": [],
          'tested': 0,
          'untested': 0,
          'total': 0,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

      function createEndNode(name, attrs) {
        var node = {
          "name": name,
        };
        if (attrs) {
          node = Object.assign(node, attrs)
        }
        return node
      }

    #+END_SRC
    I don't think I need the colors in here.  They will likely end up in our sunburst component.
*** Service workers
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/lib/service-workers.js
    :END:
    #+BEGIN_SRC js
      // In production, we register a service worker to serve assets from local cache.

      // This lets the app load faster on subsequent visits in production, and gives
      // it offline capabilities. However, it also means that developers (and users)
      // will only see deployed updates on the "N+1" visit to a page, since previously
      // cached resources are updated in the background.

      // To learn more about the benefits of this model, read https://goo.gl/KwvDNy.
      // This link also includes instructions on opting out of this behavior.

      const isLocalhost = Boolean(
        window.location.hostname === 'localhost' ||
          // [::1] is the IPv6 localhost address.
        window.location.hostname === '[::1]' ||
          // 127.0.0.1/8 is considered localhost for IPv4.
        window.location.hostname.match(
          /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
        )
      );

      export default function register() {
        if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
          // The URL constructor is available in all browsers that support SW.
          const publicUrl = new URL(process.env.PUBLIC_URL, window.location);
          if (publicUrl.origin !== window.location.origin) {
            // Our service worker won't work if PUBLIC_URL is on a different origin
            // from what our page is served on. This might happen if a CDN is used to
            // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374
            return;
          }

          window.addEventListener('load', () => {
            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

            if (!isLocalhost) {
              // Is not local host. Just register service worker
              registerValidSW(swUrl);
            } else {
              // This is running on localhost. Lets check if a service worker still exists or not.
              checkValidServiceWorker(swUrl);
            }
          });
        }
      }

      function registerValidSW(swUrl) {
        navigator.serviceWorker
          .register(swUrl)
          .then(registration => {
            registration.onupdatefound = () => {
              const installingWorker = registration.installing;
              installingWorker.onstatechange = () => {
                if (installingWorker.state === 'installed') {
                  if (navigator.serviceWorker.controller) {
                    // At this point, the old content will have been purged and
                    // the fresh content will have been added to the cache.
                    // It's the perfect time to display a "New content is
                    // available; please refresh." message in your web app.
                    console.log('New content is available; please refresh.');
                  } else {
                    // At this point, everything has been precached.
                    // It's the perfect time to display a
                    // "Content is cached for offline use." message.
                    console.log('Content is cached for offline use.');
                  }
                }
              };
            };
          })
          .catch(error => {
            console.error('Error during service worker registration:', error);
          });
      }

      function checkValidServiceWorker(swUrl) {
        // Check if the service worker can be found. If it can't reload the page.
        fetch(swUrl)
          .then(response => {
            // Ensure service worker exists, and that we really are getting a JS file.
            if (
              response.status === 404 ||
                response.headers.get('content-type').indexOf('javascript') === -1
            ) {
              // No service worker found. Probably a different app. Reload the page.
              navigator.serviceWorker.ready.then(registration => {
                registration.unregister().then(() => {
                  window.location.reload();
                });
              });
            } else {
              // Service worker found. Proceed as normal.
              registerValidSW(swUrl);
            }
          })
          .catch(() => {
            console.log(
              'No internet connection found. App is running in offline mode.'
            );
          });
      }

      export function unregister() {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.ready.then(registration => {
            registration.unregister();
          });
        }
      }

    #+END_SRC

** Actions
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/index.js
    :END:
    We'll use the index page of the actions to set up our axios client.  axios handles our fetch requests, since we'll be fetching from another server and not from a data file within this app.  Axios is an http request client that uses promises (a new javascript convention for handling asynchronous calls).[[https://www.npmjs.com/package/axios][ Axios page on NPM]]

    We'll want to configure a client app for axios, that sets the host we are trying to connect to and the type of information we are expecting to get.  Since we are working with a feathers api, then we know we just need to grab JSON.
    #+NAME: axios_config
    #+BEGIN_SRC js
      import axios from 'axios'

      export const client = axios.create({
        baseURL: "http://apisnoop.cncf.io:3030",
        headers: {
          "Content-Type": "application/json"
        }
      })
    #+END_SRC
   These work with redux to deliver our store an object that has a 'type' and a payload.  So the type tells our store reducers what to do with it, and the payload is the data that is being added to the global state.

*** Config Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/config-actions.js
    :END:
**** Requirements
    We are going to ping our feathers database to grab our contacts.  We've set up an axios client (in index.js) to handle these types of requests, so we'll bring it in, and use the client to grab data.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

      const url = '/config'

    #+END_SRC
**** Fetching Config
      The dispatch is being used so our redux stores can hear an action took place.  So we are sending out a broadcast(dispatch) that says 'FETCH CONFIG HAPPENED!' and we're bringing with it a payload.  Redux will hear this action, and assign the payload to the correct part of the app's state.
      #+NAME: config-actions.js
      #+BEGIN_SRC js

        export function fetchConfig () {
          return dispatch => {
            dispatch({
              type: 'FETCH_CONFIG',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC

  When this is pinged it'll create a few new type of actions:
    + 'FETCH_CONFIG_PENDING'
    + 'FETCH_CONFIG_FULFILLED'
    + 'FETCH_CONFIG_REJECTED'

  This is done automatically, and so we don't need to create action creators for these various actions, we just need to tell our reducer to listen to the 'FETCH_CONFIG_FULFILLED' action and handle the payload appropriately.
**** Fetch Particular Dashboard
**** Fetch Particular Testgroup
*** Audits Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/audits-actions.js
    :END:
**** Requirements
    We are going to ping our feathers database to grab our contacts.  We've set up an axios client (in index.js) to handle these types of requests, so we'll bring it in, and use the client to grab data.
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

    #+END_SRC
**** Fetching Audits
      The dispatch is being used so our redux stores can hear an action took place.  So we are sending out a broadcast(dispatch) that says 'FETCH AUDITS HAPPENED!' and we're bringing with it a payload.  Redux will hear this action, and assign the payload to the correct part of the app's state.
      #+NAME: audits-actions.js
      #+BEGIN_SRC js
      const url = '/api/v1/audits'
        export function fetchAudits () {
          return dispatch => {
            dispatch({
              type: 'FETCH_AUDITS',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC

  When this is pinged it'll create a few new type of actions:
    + 'FETCH_AUDITS_PENDING'
    + 'FETCH_AUDITS_FULFILLED'
    + 'FETCH_AUDITS_REJECTED'

  This is done automatically, and so we don't need to create action creators for these various actions, we just need to tell our reducer to listen to the 'FETCH_AUDITS_FULFILLED' action and handle the payload appropriately.
*** Statistics Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/statistics-actions.js
    :END:
**** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

    #+END_SRC
**** Fetching Statistics
      The dispatch is being used so our redux stores can hear an action took place.  So we are sending out a broadcast(dispatch) that says 'FETCH AUDITS HAPPENED!' and we're bringing with it a payload.  Redux will hear this action, and assign the payload to the correct part of the app's state.
      #+NAME: audits-actions.js
      #+BEGIN_SRC js
      const url = '/api/v1/statistics'
        export function fetchStatistics () {
          return dispatch => {
            dispatch({
              type: 'FETCH_STATISTICS',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC
*** Sunbursts Actions
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/actions/sunbursts-actions.js
    :END:
**** Requirements
    #+NAME: Requirements
    #+BEGIN_SRC js
      import { client } from './'

    #+END_SRC
**** Fetching Sunbursts
      #+NAME: Fetch Sunbursts
      #+BEGIN_SRC js
      const url = '/api/v1/sunbursts'
        export function fetchSunbursts () {
          return dispatch => {
            dispatch({
              type: 'FETCH_SUNBURSTS',
              payload: client.get(url)
            })
          }
        }
      #+END_SRC
*** Fun
** Reducers
*** index.js
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/index.js
    :END:
    Here we combine all our different reducers into one big one.  This lets us think about the app in different, focused concerns that then get added to the larger application seamlessly.

    #+NAME: Requirements
    #+BEGIN_SRC js
      import { combineReducers } from 'redux'

      import AuditsReducer from './audits-reducer'
      import StatisticsReducer from './statistics-reducer'
      import SunburstsReducer from './sunbursts-reducer'
      import D3FlareReducer from './flare-reducer'
    #+END_SRC

    #+NAME: Reducers
    #+BEGIN_SRC js
      const reducers = {
        auditsStore: AuditsReducer,
        statisticsStore: StatisticsReducer,
        sunburstsStore: SunburstsReducer,
        D3FlareStore: D3FlareReducer
      }

      const rootReducer = combineReducers(reducers)

      export default rootReducer
    #+END_SRC
*** Audits Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/audits-reducer.js
    :END:
**** Initial State
    We'll first create the initial state for our contact, so we don't get a null error before we have any data.  It'll either be an empty object, or an object filled with data from our server.  In either case, we are giving our components a structure for what they can expect to display, and then the data to display.
#+NAME: Audits Initial State
#+BEGIN_SRC js
  const defaultState = {
    audits: [],
    loading: true,
    errors: {}
  }

#+END_SRC

**** The Reducer
     #+NAME: The Audits Reducer
     #+BEGIN_SRC js
       export default (state = defaultState, action = {}) => {
         switch (action.type) {
           case 'FETCH_AUDITS_FULFILLED': {
             return {
               ...state,
               audits: action.payload.data,
               loading: false
             }
           }
           default:
             return state;
         }
       }

     #+END_SRC
*** Statistics Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/statistics-reducer.js
    :END:
**** Initial State
    We'll first create the initial state for our contact, so we don't get a null error before we have any data.  It'll either be an empty object, or an object filled with data from our server.  In either case, we are giving our components a structure for what they can expect to display, and then the data to display.
#+NAME: Statistics Initial State
#+BEGIN_SRC js
  const defaultState = {
    statistics: [],
    loading: true,
    errors: {}
  }

#+END_SRC

**** The Reducer
     #+NAME: The Statistics Reducer
     #+BEGIN_SRC js
       export default (state = defaultState, action = {}) => {
         switch (action.type) {
           case 'FETCH_STATISTICS_FULFILLED': {
             return {
               ...state,
               statistics: action.payload.data,
               loading: false
             }
           }
           default:
             return state;
         }
       }

     #+END_SRC
*** Sunbursts Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/sunbursts-reducer.js
    :END:
**** Initial State
    We'll first create the initial state for our contact, so we don't get a null error before we have any data.  It'll either be an empty object, or an object filled with data from our server.  In either case, we are giving our components a structure for what they can expect to display, and then the data to display.
#+NAME: Sunbursts Initial State
#+BEGIN_SRC js
  const defaultState = {
    sunbursts: [],
    loading: true,
    errors: {}
  }

#+END_SRC

**** The Reducer
     #+NAME: The Sunbursts Reducer
     #+BEGIN_SRC js
       export default (state = defaultState, action = {}) => {
         switch (action.type) {
           case 'FETCH_SUNBURSTS_FULFILLED': {
             return {
               ...state,
               sunbursts: action.payload.data,
               loading: false
             }
           }
           default:
             return state;
         }
       }

     #+END_SRC
*** flare Reducer
    :PROPERTIES:
    :header-args: :noweb yes :tangle ./client/src/reducers/flare-reducer.js
    :END:
    This is just a sample to grab our json from redux instead of directly froma  file.  The idea is when this works, we can then change the logic to pull from our audits file instead which includes the nice json of info we need.
    #+NAME: Flare Reducer
    #+BEGIN_SRC js
      const D3FlareData = require('../sample-data/flareData.json')

      const initialState = {
        data: D3FlareData
      }

      export default (state = initialState, action = {}) => {
        switch (action.type) {
        default:
          return state
        }
      }
    #+END_SRC

* Process
** Working with d3
*** Introduction
   d3 is the data visualization library that was used to make our original sunburst.  The way it works is to mount itself to the dom, and then appends new elements to the dom based on the data it was given. If that data changes, it transforms the elements as needed.

   The way react works is it attaches itself to the dom, then creates a //shadow dom// that it is continually listening to, adding and removing elements in this dom as needed based on the data(the state) it was given.

   In other words, they work in largely the same way, and both wanna attach themselves to the dom and manipulate it.  This...isn't good.  We want to have /1/ thing making shadow doms and calls on the website, and so it is a bit tricky to get react and d3 working together.

The upside is that a number of people have tackled this challenge and created different react/d3 libraries for how the two can work together.  The downside is that I'm not sure yet which is the best to do.

Put simply, it is not easy to take our existing sunburst code and just paste it into our new app.  We are going to need to transform it in some way based on the guidance of the library we are using.

So the question is why we are putting ourselves into this trouble?
*** WHY WE ARE PUTTING OURSELVES INTO THIS TROUBLE
    My assumption with all of this is that when people hear 'apisnoop', they are thinking of the site in which you can see the data visualziations.  And so the webapp is important for the project and will be expanded.  React would be great for this in the long run.

Similarly, I am expecting that we are going to have more types of visualizations than just the sunburst--and that even the sunburst may change.  So we are going to want to have an understanding for a language in which we can make a //bunch// of visualizations. d3 is great for this.

If we do it right, we can have reusable components too that other teams could use for their own k8s projects, and that we could use ourselves.  For example--displaying two sunburst charts side by side would be much easier in react/d3 then what i ws trying to do before (appending both to the same id on a standard html document.)  This requires that I move through some d3 tutorials though.

At the end of this, though, we will have a backend server that is easy to setup and can ping different url's (github repos or testgrid artifacts) and grab their data.  Then, we can manipulate that data in whatever way we want but also pass it along to our frontend.  This front-end can then have different options and tags setto really dive in and explore.

If this is the purpose of apisnoop then let's do it.  If it's too much overkill though, then I can try a simpler solution.
*** Possible Process to get going
**** Setup a simple d3 visualization to understand the process
**** pipe data into this simple visualization through our redux state.
**** Pore over the original code again (the original blog post) to see how to best convert it
**** Change the sunburst's origin point from a CSV file to JSON
**** Change the sunbursts origin point from JSON to our redux store.
*** Second Process
**** Setup different pages for different d3-react libraries that already have ubilt components.
**** explore piping our data into the one we like.
**** Use testgrid conformance data and make simple visualizations to it.
     We are wanting to keep the data retrieval tied into the visualizing, so we dont' end up with a pretty graph that can't be used for what we have.  So we can grab the testgrid stuff now and see what we can do with it.


**** Use that going forward.
*** Possible Libraries to use
**** Victory
     https://formidable.com/open-source/victory/
**** Britecharts react
     https://eventbrite.github.io/britecharts-react/
**** Recharts
     http://recharts.org/en-US/
** Plan for Demo
- show our sunburst
- show a cloud of all tags.
- show a dropdown for user-agent
- if you chooose a tag, the user-agent dropdown reduces to just tests run by that tag.
- If you click on a sig tag, pull its general info from kubernetes/community/sigs.yaml
- when you hover over an endpoint, show a list of tests that also hit that endpoint. and nubmer of times that test hits that endpoint.
* Footnotes
** Understand the config.yaml file and what it's pointing to.
*** TestGrid
    Our testgrid is located at: https://k8s-testgrid.appspot.com/

 https://github.com/kubernetes/test-infra/blob/master/testgrid/config.yaml#L3028
 Dashboard Config for conformance-all: https://github.com/kubernetes/test-infra/blob/master/testgrid/config.yaml#L3231
 Production instance of conformance-all: https://k8s-testgrid.appspot.com/conformance-all

 GCE https://k8s-testgrid.appspot.com/conformance-all#GCE,%20master%20(dev)

 JOBS for GCE 1.12-dev https://k8s-gubernator.appspot.com/builds/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12
 Historical artifa8cts, including latest:
 https://k8s-gubernator.appspot.com/builds/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12
 The specific latest build:
 https://k8s-gubernator.appspot.com/build/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/
 Grab SOMETHING from the artifact folder for this job:
 http://gcsweb.k8s.io/gcs/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/
 The audit log: https://storage.googleapis.com/kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-latest-1-12/168/artifacts/bootstrap-e2e-master/kube-apiserver-audit.log
*** Navigating the config.yaml
    Starting at , here is how to relate the url view with the info on
    <<
**** [[file:config_yamls/config.yaml::dashboard_groups:][dashboard_groups:]]

    These top level dashboard groups are what populate the top level of [[https://k8s-testgrid.appspot.com][k8s-testgrid.appspot.com]]
***** [[file:config_yamls/config.yaml::dashboards:][dashboards:]]
****** [[file:config_yamls/config.yaml::test_groups:][test_groups:]]

**** Example [[file:config_yamls/config.yaml::-%20name:%20conformance-gce][For dashboard: conformance-gce]]
  if you were to look at
  dashboards.name['conformance-gce'].dashboard_tab, that ties to the summary tab you see at [[https://k8s-testgrid.appspot.com/conformance-gce][k8s-testgrid.appspot.com/conformance-gce]]
**** Test groups
     k8s
    Every testgroup name you find at:
   ~dashboards.name['conformance-gce'].dashboard_tab.name~
   has a section called 'test_group_name', and each test group name has its gcs_prefix (GCS standing for 'Google Cloud Services')

   For example, the test group name 'ci-kubernetes-gce-conformance-stable-1-12' has a gcs prefix of 'kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-stable-1-12'.

   The json path for this testgroup gcs prefix would be:
   test_groups.name['ci-kubernetes-gce-conformance-stable-1-12'].gcs_prefix

   which takes you here: [[file:config_yamls/config.yaml::gcs_prefix:%20kubernetes-jenkins/logs/ci-kubernetes-gce-conformance-stable-1-12][gce-conformance-latest-1-12 gcs_prefix]]

   We could then...point that to a url where we'd grab the artifacts?
   like:
  http://gcsweb.k8s.io/gcs/$GCS_PREFIX

  we want to grab the latest text build, which is found at
  http://gcsweb.k8s.io/gcs/$GCS_PREFIX/latest-build.txt
   The goal now is to try to get as much done on the server, instead of trying to do it upon page requests in the client.  So what we would like is to have a server with an api that the client can ping that would give back the data needed based on the branch.  So I could do a request in the client for gce-conformance branch 1.12(dev), and that'd tie to some easy to reason about api path (/branches/1.12-dev), and this gives us the name of the latest build and the data taken from kube-servers api log.

So ultimately we want to be bringing down the gigs of data for the audit-logs and converted into something that can be rendered into a graph.
** Resources
*** d3
**** [[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][interactive applications with react-d3]]
     this is really good.
**** [[https://www.smashingmagazine.com/2018/02/react-d3-ecosystem/][Bringing Together react, d3, and their ecosystem]]
**** [[http://www.adeveloperdiary.com/react-js/integrate-react-and-d3/][How to Integrate React and d3 the right way]]
**** [[https://bost.ocks.org/mike/join/][Thinking with Joins]]

** Process
** isocket
*** Connecting the left pair / isocket

 ssh needs '-t' twice because it needs to be forced to allocate a remote terminal
 _even_ when we don't have have local one (within emacs)


#+NAME: left_session_create
#+BEGIN_SRC shell :var session="zz-left" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n emacs \
      emacs --fg-daemon=$session" \
  &
#+END_SRC

#+NAME: left_session_setup
#+BEGIN_SRC shell :var session="zz-left" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  ssh -att $user@$host \
  "tmate -S /tmp/.$session.isocket \
        new-window \
        -n client" \
   "emacsclient -nw \
              --socket-name $session \
              ~/apisnoop/webui/web_ui.org"
#+END_SRC

 #+NAME: left_session
 #+BEGIN_SRC shell :wrap "SRC text :noeval" :results verbatim :var session="zz-left" user="zz" host="apisnoop.cncf.io" :results silen
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket wait tmate-ready > /dev/null &&
  ssh -att $user@$host \
    tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\' 2> /dev/null
# ssh -tt root@apisnoop.cncf.io \
#  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS: left_session
 #+BEGIN_SRC text :noeval
 #+END_SRC

**** Connecting to emacs daemon

 #+NAME: alse run emacsclient
 #+BEGIN_SRC tmate :noeval
 export SESSION=lt-emacs
 emacsclient --socket-name $SESSION
 #+END_SRC

*** Connecting the right pair / isocket

#+NAME: right_session_create
#+BEGIN_SRC shell :var session="zz-right" terminal_exec="xterm -e" user="zz" host="apisnoop.cncf.io" :session nil :results silent
  $terminal_exec \
      "ssh -att \
           -L /tmp/.$session.isocket:/tmp/.$session.isocket \
           -l $user \
           $host \
      tmate -S /tmp/.$session.isocket \
            new-session \
            -A \
            -s $session \
            -n misc" \
  &
#+END_SRC


 #+NAME: right_session_join
 #+BEGIN_SRC shell :results silent
 export SESSION=api-snoop
 export XTERM_EXEC="roxterm -e"
 $XTERM_EXEC ssh -Att root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
   at \; sleep 9999
 #+END_SRC

 #+NAME: right_session_setup
 #+BEGIN_SRC shell :results verbatim
 export SESSION=api-snoop
 echo ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket \
    new-window -n session \
     bash
 #+END_SRC

 #+NAME: right_session
 #+BEGIN_SRC shell :cache yes :wrap "SRC text :noeval" :results verbatim
 export SESSION=api-snoop
 ssh -tt root@apisnoop.cncf.io \
  tmate -S /tmp/.$SESSION.isocket display -p \'#{tmate_ssh}\'
 #+END_SRC

 #+RESULTS[dd96525b42bbbe741e292e99ad5f3592a7163025]: right_session
 #+BEGIN_SRC text :noeval
 ssh mJrsCgvGTOTOFagYpBKvRf7EE@sf2.tmate.io
 #+END_SRC





 #+NAME: give this to your pair
 #+BEGIN_SRC bash :noweb yes :var left_session=left_session() right_session=right_session()
 echo "ii pair session ready
 left: $left_session
 right: $right_session
 "
 #+END_SRC

 #+RESULTS: give this to your pair
 | ii     | pair | session | ready |
 | left:  | nil  |         |       |
 | right: | nil  |         |       |
 |        |      |         |       |

*** TODO Sharing your eyes

#+NAME: give this to your pair
#+BEGIN_SRC bash :noweb yes :var left_session=left_session() :var right_session=right_session()
echo "ii pair session ready
left: $left_session
right: $right_session
"
#+END_SRC
* Experiment
  :PROPERTIES:
  :header-args: :dir (concat (file-name-directory buffer-file-name) "client")
  :header-args:tmate: :socket "/tmp/.zz-right.isocket"
  :header-args:tmate: :session "zz-right"
  :END:

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
* TODO have config.yaml pull from local file instead of from github repo
